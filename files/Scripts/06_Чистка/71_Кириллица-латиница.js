//======================================
//             «Кириллица-латиница»
//  Скрипт тестировался в FBE v.2.7.7 (win XP, IE8 и win 7, IE11)
//======================================
//  Скрипт предназначен для восстановления текста, написанного смесью латиницы, кириллицы, цифр и греческих букв.
//  * История изменений в конце скрипта
//======================================

function Run() {

 var ScriptName="«Кириллица-латиница»";
 var NumerusVersion="1.6";
 var Ts=new Date().getTime();

//--------------------------------------------------------------------
                 ///  НАСТРОЙКИ
//--------------------------------------------------------------------

// Обработка текста внутри «Истории изменений файла»

 var ObrabotkaHistory_on_off = 1;      // 0 ; 1 //      ("0" — отключить, "1" — включить)

// ---------------------------------------------------------------

// Преобразовывать отдельностоящие буквы (A, B, C, K, O, Α, Β, Κ, Ο, a, c, o, u, y, ĸ, κ, ο) в русские
// * Это могут быть как предлоги, так и переменные или какие-то обозначения
// ** Если текст книги никак не соприкасается с математикой или лингвистикой, то ошибки обработки крайне маловероятны

 var Obrabotka_Predlogov = 2;      // 0 ; 1 //      ("0" — Нет,   "1" — Да,   "2" — всегда спрашивать)

// ---------------------------------------------------------------

         //  Заменять латинские буквы <á, é, ú, ó, ό, ò, ý> на русские буквы со стандартным знаком ударе́ния (&#769;)

 var Ud_on_off = 1;      // 0 ; 1 //      ("0" — отключить эту операцию, "1" — включить)

// ---------------------------------------------------------------

         //  Автоматическое повышение версии файла и запись в историю изменений.

 var Version_on_off = 1;      // 0 ; 1 //      ("0" — отключить, "1" — включить)

//  Добавлять, если не сделано ни одного исправления
 var Vsegda_on_off = 0;      // 0 ; 1 //      ("0" — отключить, "1" — включить)

//   Имя используемое в добавленной записи:
 var youName = "Зорро";

//  * Для записи имени можно использовать почти любые символы.
//     Исключения:   |  "  |  \  |    Но и любой из этих знаков можно добавить, если поставить перед ним наклонную черту ("\"), например: "\\" = "\"
//     Или можно оставить кавычки пустыми (""), тогда строка в истории будет без имени.

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОБЩИЕ ПЕРЕМЕННЫЕ

//   Неразрывный пробел из настроек FBE
 try  {
         var nbspEntity=window.external.GetNBSP();   //  Получаем выбранный символ неразрывного пробела.
         if (nbspEntity.charCodeAt(0) == 160)   //  Если используется стандартный символ...
                 nbspEntity = "&nbsp;";   //  то заменяем его на стандартный код.
         }
 catch(e) {            //  Если команда для получения символа н/р пробела вызывает ошибку...
         var nbspEntity="&nbsp;";   //  то используем стандартный код н/р пробела.
         }

 var fbwBody=document.getElementById("fbw_body");

var ObrabotkaHistory = (ObrabotkaHistory_on_off ==1);

 var n;
 var k;
 var FalseSim="&0&"; // Неповторимый набор символов для нескольких небольших эпизодов

 var RU = "А-яЁёѢѣѲѳ́";           //  Все символы русских слов.
 var RU_ = "А-яЁёѢѣѲѳ";           //  Все символы русских слов  без знака ударения.
 var LA = "A-Za-zÀ-ÖØ-öø-ÿĸ́";  //  Все символы латинских слов.
 var LA_ = "A-Za-zÀ-ÖØ-öø-ÿĸ";  //  Все символы латинских слов  без знака ударения.
 var EL = "ΆΈ-ώ́";              //  Все символы греческих слов.
 var EL_ = "ΆΈ-ώ";              //  Все символы греческих слов  без знака ударения.
 var ud = "́";              //  Знака ударения.

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 ///  ФУНКЦИЯ ПОВЫШЕНИЯ ВЕРСИИ ФАЙЛА И ЗАПИСЬ В ИСТОРИЮ ИЗМЕНЕНИЙ

 function HistoryChange(Script_Name, youName) {


         // Получение раздела истории

// var fbwBody=document.getElementById("fbw_body");   //  **  эта строка уже есть в скрипте  **
 var History=fbwBody.firstChild;   //  Предполагаемый раздел истории.

 //  Поиск раздела "историй"
 while (History != null  &&  History.className != "history")    //  Пока не найдем настоящий раздел истории, или окажется, что истории нет в тексте...
         History = History.nextSibling;         //  переходим на следующий раздел.

//  Добавление раздела истории
 if (History==null)  {                 //   Если нет истории...
         History = document.createElement("DIV");     //   Создание нового раздела
         var Annotation=fbwBody.firstChild;
         while (Annotation!=null  &&  Annotation.className!="annotation") Annotation=Annotation.nextSibling;   //  Поиск аннотации к книге
         if (Annotation!=null)  Annotation.insertAdjacentElement("afterEnd",History);      //  Размещаем новый раздел    или после аннотации (если она есть)...
                 else  fbwBody.insertAdjacentElement("afterBegin",History);                //  ...или в начале "fbwBody"
         History.className = "history";      //  Присваиваем новому разделу    класс "история" и необходимые атрибуты
         History.setAttribute("xmlns:l", xlNS);    //  "xlNS" и "fbNS" - переменные из "main.js"
         History.setAttribute("xmlns:f", fbNS);
         History.insertAdjacentElement("beforeEnd",document.createElement("P"));     //  Добавляем пустую строку
         window.external.inflateBlock(History.lastChild)=true;
         }


         //  Создание массива с прошедшими датами

 var mDate=[];         //  Массив с прошедшими датами.
 var D = new Date().getTime();   //  Начальное значение даты.
 var fullDate;
 var Day;
 var Month;
 var Year;

 for (var j=0; j<10; j++) {              //  Запускаем цикл для получения недавних дат, в котором...
         fullDate = new Date(D);                         //  получаем полную дату,
         Day = fullDate.getDate();                            //  день месяца,
         Month = ("0" + (1+fullDate.getMonth())).replace(/^.*?(\d\d)$/g, "$1");   //  месяц,
         Year = ("0" + fullDate.getFullYear()).replace(/^.*?(\d\d)$/g, "$1");       //  год,
         mDate[j] = Day + "." + Month + "." + Year;             //  и заполняем массив текстом очередной даты (Д.ММ.ГГ).
         D -= 86400000;                       //  При этом каждый раз уменьшаем проверяемую дату на один день.
         }


         //  Поиск недавней записи в "истории"

 var povtorD = false;   //  Индикатор повторной обработки в последние 10 дней.
 var mP = History.getElementsByTagName("P");   //  Получение всех строк в "Истории".
 var s="";               //  Содержимое строки.
 var k=0;               //  Счетчик цикла.

fff:
 for (j=mP.length-1;  j>0;  j--) {    //  Последовательный просмотр строк истории.
         s = mP[j].innerHTML;                //  Содержимое строки.
         for (k=0; k<10; k++) {                //  и запускаем цикл для проверки даты.
                 if (s.search(mDate[k]) !=-1) {   //  Если проверяемая дата есть в строке истории...
                         povtorD = true;                    //  то отмечаем это,
                         break fff;                            //  и прерываем оба цикла проверки.
                         }
                 }
         }


         //  Обновление записи в истории изменений

 try  { youName = fbeUserName }   //  Если есть строка:   var fbeUserName = "Имя";   в файле "main.js"  --  Изменение имени в соответствии с глобальной переменной.
 catch(e)  {}                                            //  Если глобальная переменная отсутствует - пропуск операции по изменению имени.

 var textYouName = youName+"";    //  Имя в тексте.
 if (youName!="")                           //  Если есть заполненное имя...
         textYouName += ", ";   //  то добавляем к текстовой записи запятую.

 var reHist00s = new RegExp("[^А-яЁёA-Za-z0-9]"+Script_Name+"[^А-яЁёA-Za-z0-9]","g");   //  Стартовая.
 //  Добавление точки с запятой
 var reHist01 = new RegExp("(.[^…\\\?!\\\.,;:—])(\\\s|"+nbspEntity+")(— \\\("+textYouName+mDate[k]+"\\\))","g");
 var reHist01_ = "$1; $3";
 //  Добавление слова "Скрипт"
 var reHist02 = new RegExp("(.)(\\\s|"+nbspEntity+")(— \\\("+textYouName+mDate[k]+"\\\))","g");
 var reHist02_ = "$1 Скрипт: $3";
 //  Добавление имени скрипта
 var reHist03 = new RegExp("(.)(\\\s|"+nbspEntity+")(— \\\("+textYouName+mDate[k]+"\\\))","g");
 var reHist03_ = "$1 "+Script_Name+" $3";

 if (povtorD) {                                         //  Если найдена запись с недавней датой...
         if (s.search(reHist03) !=-1) {    //  и если в строке имя пользователя и дата записаны по форме: "— (Имя, Дата)"...
                 if (s.search(reHist00s) ==-1) {    //  то проверяем строку на наличие записи имени скрипта, и если этой записи нет...
                         if (s.search(/([Сс]крипт):/) !=-1)  s = s.replace(/([Сс]крипт):/g, "$1ы:");   //  то заменяем при необходимости слово "Скрипт" на "Скрипты",
                         if (s.search(reHist01) !=-1)  s = s.replace(reHist01, reHist01_);                   //  добавляем при необходимости точку с запятой,
                         if (s.search(/[Сс]крипты?:/) ==-1)  s = s.replace(reHist02, reHist02_);   //  добавляем при необходимости слово "Скрипт"
                         s = s.replace(reHist03, reHist03_);      //  и добавляем имя скрипта.
                         }
                 if (k != 0)                                                    //  Затем проверяем дату, и если она не сегодняшняя...
                         s = s.replace(mDate[k], mDate[0]);   //  то заменяем на сегодняшнюю.
                 if (mP[j].innerHTML != s) {                //  Затем проверяем изменилась ли строка истории, и если она изменилась...
                         mP[j].innerHTML = s;          //  то сохраняем её в тексте
                         HiCh=3;   //  и отмечаем это на индикаторе.
                         }
                 }
             else                                  // Если же есть недавняя дата, но запись сделана не по форме...
                 povtorD = false;   //  Объявляем, что недавняя дата - посторонняя, и надо повышать версию и добавлять новую строку в историю.
         }

 if (povtorD)  return;   //  Если производилась обработка записи в истории - выход из функции.


         //  Повышение версии

 var versionText = "";           //  Текст с версией в истории изменений.

 //  Проверка на валидность версии файла
 var ValidationVersion=(versionFile.length <=10  &&  versionFile.search(/^\d{0,10}(\.\d{1,8})?$/g) !=-1);    //  сравнение с шаблоном:  "цифры + (точка + цифры)"

 //   Изменение версии файла
 if (ValidationVersion) {
         if (versionFile =="")          //  Если версия не заполнена...
                 versionFile = "1.0";    //  то изменяем начальную версию на "1.0".
         if (versionFile.search(/^\d+$/g) !=-1)   //  Если версия без точки...
                 newVersion = versionFile + ".1";     //  то для новой версии добавляем ".1".
             else {                                                                                         //  Если в версии есть точка...
                     newVersion = +versionFile.replace(/^\d+\./g, "");  //  извлекаем цифры после точки,
                     newVersion++;                                                                                           //  увеличиваем полученное число на единицу
                     newVersion = versionFile.replace(/\.\d+$/g, "")+"."+newVersion;   //   и добавляем к нему первую группу цифр.
                     }
         if (newVersion.length <=10)                                        //  Если новая версия валидна...
                 document.getElementById("diVersion").value=newVersion;   //  то изменяем версию в файле,
                 VersionUp=true;                                                          //  отмечаем это на индикаторе
                 var versionText="v."+newVersion+" — ";    //  и создаем текст для истории.
         }


         //   Добавление строк в историю изменений

 var reHist11 = new RegExp("^(\\\s|"+nbspEntity+"){0,}$","g");   //  Признак пустой строки.
 var reHist12 = new RegExp("(^|\\n)[^0-9]{0,12}"+versionFile.replace(/\./, "\\.")+"([^0-9]|$)","g");   //  Поиск старой версии.

 //   Добавление строки с информацией о старой версии
 if (ValidationVersion  &&  History.innerText.search(reHist12)==-1) {       //  Если в истории нет записи о старой версии...
         if (History.lastChild.innerHTML.search(reHist11)==-1)                                               //  то проверяем наличие пустой строки в конце истории
                 History.insertAdjacentElement("beforeEnd",document.createElement("P"));       //  и если ее нет - добавляем новую.
         History.lastChild.innerHTML = "v."+versionFile+" — ?";  //  Затем добавляем в строку информацию о старой версии
         HiCh++;                                        //  и изменяем индикатор истории.
         }

 //   Добавление строки с информацией о новой версии
 if (History.lastChild.innerHTML.search(reHist11)==-1)                                   //  Если в конце истории нет готовой пустой строки...
         History.insertAdjacentElement("beforeEnd",document.createElement("P"));   //  то добавляем новую строку.
 History.lastChild.innerHTML = versionText+" Скрипт: "+Script_Name+" — ("+textYouName+mDate[0]+")";  //  Добавляем в строку информацию о новой версии.
 HiCh++;                       //  Изменяем индикатор истории.

 }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ФУНКЦИЯ "Генератор случайных чисел, с округлением"

 function Rn_(rndN) {
         return Math.floor(("0000000"+Math.tan(Ts+Math.random()*2000)).replace(/[\.\-]/g, "").replace(/.+(\d\d\d\d\d\d)\d$/g, "0.$1")*rndN);  //  Генерация случайных чисел от 0 до "rndN".
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ФУНКЦИЯ ПЕРЕХОДА

// * В отличии от встроенной функции "GoTo", положение курсора не меняется, но есть прокрутка влево.

 function GoTo_0(elem) {
         var b=elem.getBoundingClientRect();                  //  Получение координат элемента.
         var c=fbwBody.parentNode.getBoundingClientRect();        //  Получение координат раздела <BODY>.
         if (b.bottom-b.top <= window.external.getViewHeight())                                                  //  Если высота элемента меньше высоты окна...
                 window.scrollBy(c.left, (b.top+b.bottom-window.external.getViewHeight())/2);   //  то переставляем середину элемента на середину окна.
             else  window.scrollBy(c.left, b.top);                                //  А если нет - то переставляем начало элемента в начало окна.
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ФУНКЦИЯ СКЛОНЕНИЯ ПО ПАДЕЖАМ В ЗАВИСИМОСТИ ОТ ЧИСЛА

 var ok=0;

 function pad(Numer) {
         var m1;
         var m2;
         var Numer;
         ok=2;
         m1=Numer % 10;
         m2=Numer % 100;
         if (m2<11 || m2>19) {
                 if (m1==1) ok=0;
                 else  if (m1==2 || m1==3 || m1==4) ok=1;    }
         return ok;
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ФУНКЦИЯ КОНВЕРТАЦИИ ВРЕМЕНИ  (мс  => мин., с)

 var tempus=0;
 var T;

 function time(T) {

         var Tmin  = Math.floor(T/60000);
         var TsecD = (T%60000)/1000;
         var Tsec = Math.floor(TsecD);

         if (Tmin ==0)
                 tempus = (+(TsecD+"").replace(/(.{1,5}).*/g, "$1")+"").replace(".", ",")+" сек";
             else {
                     tempus = Tmin+" мин";
                     if (Tsec !=0)
                             tempus += " " + Tsec+ " с" }

         return tempus;

         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ПРОВЕРКА РЕЖИМА

 if (fbwBody.style.display == "none") {
         window.external.SetStatusBarText("  •  Скрипт "+ScriptName+" v." + NumerusVersion + " можно запустить только в режиме «B» (Дизайн)");
         return;
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ФОРМИРОВАНИЕ ВОПРОСА по предлогам
                 //      (регулярные выражения)

// Удаление тегов
 var reCT = new RegExp("(<.+?>)","g");
 var reCT_ = "";

 var mV05=[];   //  Сохраненные фрагменты
 var count_V07 = 0;   //  Счетчик номеров для фрагмента
 var count_V08 = 0;   //  Общий счетчик форматов

//  Стартовая формула
 var reVs = new RegExp("[ABCKOΑΒΚΟacouyĸκο]","g");


       //  Создание фрагментов для предлогов  :::  a, c, o, u, y, ĸ, κ, ο

//  Стартовая формула
 var reV01s = new RegExp("["+RU+"][,»\\\"“]{0,2}((\\\s|"+nbspEntity+")[—–\\\-]){0,1}(\\\s|"+nbspEntity+")[acouyĸκο](\\\s|"+nbspEntity+")[«\\\"„]{0,2}["+RU+"]","g");
//  Формула извлечения текста для добавления в массив
 var reV02 = new RegExp("(^|[^"+LA+RU+EL+"\\\-])["+LA+RU+EL+"\\\-]{0,17}.{0,32}?["+RU+"][,»\\\"“]{0,2}((\\\s|"+nbspEntity+")[—–\\\-]){0,1}(\\\s|"+nbspEntity+")[acouyĸκο](\\\s|"+nbspEntity+")[«\\\"„]{0,2}["+RU+"].{0,37}["+LA+RU+EL+"\\\-]{0,17}(?=[^"+LA+RU+EL+"\\\-]|$)","g");
//  Для вставки подстрочных знаков подчеркивания
var reV03 = new RegExp("(["+RU+"][,»\\\"“]{0,2})((\\\s|"+nbspEntity+")[—–\\\-]){0,1}(\\\s|"+nbspEntity+")([acouyĸκο])(\\\s|"+nbspEntity+")(?=[«\\\"„]{0,2}["+RU+"])","g");
 var reV03_ = "$1$2 ̲$5̲ ";


       //  Создание фрагментов для предлогов  :::  A, B, C, K, O, Α, Β, Κ, Ο

//  Стартовая формула
 var reV11s = new RegExp("(^|[…\\\.\\\?!](\\\s|"+nbspEntity+"))([—–\\\-](\\\s|"+nbspEntity+")){0,1}[ABCKOΑΒΚΟ](\\\s|"+nbspEntity+")[«\\\"„]{0,1}["+RU+"]","g");
//  Формула извлечения текста для добавления в массив
 var reV12 = new RegExp("(^|(^|[^"+LA+RU+EL+"\\\-])["+LA+RU+EL+"\\\-]{0,17}.{0,32}?[…\\\.\\\?!](\\\s|"+nbspEntity+"))([—–\\\-](\\\s|"+nbspEntity+")){0,1}[ABCKOΑΒΚΟ](\\\s|"+nbspEntity+")[«\\\"„]{0,1}["+RU+"].{0,37}["+LA+RU+EL+"\\\-]{0,17}(?=[^"+LA+RU+EL+"\\\-]|$)","g");
//  Для вставки подстрочных знаков подчеркивания
var reV13 = new RegExp("(^|[…\\\.\\\?!](\\\s|"+nbspEntity+"))([—–\\\-](\\\s|"+nbspEntity+")){0,1}([ABCKOΑΒΚΟ])(\\\s|"+nbspEntity+")(?=[«\\\"„]{0,1}["+RU+"])","g");
 var reV13_ = "$1$3̲$5̲ ";

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ФОРМИРОВАНИЕ ВОПРОСА по предлогам
                 //      (сборка функции "Vopros")

 var max0=24;  //   Максимальное количество найденных строк в окне вопроса
 var M=[];  //   Сохраненные фрагменты из одной строки


 function Vopros(ptr) {

 s=ptr.innerHTML;  // оригинальный абзац

 if (s.search(reVs) != -1) {

         if (s.search(reV01s) != -1) {                   //  Если в строке есть иностранная буква (a, c, o, y, ĸ, κ, ο) между русскими словами...
                 if (count_V07<max0)  {                                        //  Проверяем: вместится ли новая строка в окно вопроса.  Если вместится...
                         if (s.search(/</g)!=-1)  s=s.replace(reCT, reCT_);   //  удаляем из строки все внутренние теги и
                         M=s.match(reV02);                                                    //  сохраняем фрагменты текста с такой буквой.
                         for (n=0;  n < M.length;  n++)                                 //  Запускаем цикл для всех найденных фрагментов.
                                 if (count_V07< max0) {                                                          //  Если ещё одна строка поместится в окно вопроса...
                                         mV05[count_V07]=M[n].replace(reV03, reV03_);  //   сохраняем фрагмент в основном массиве
                                         count_V07++;    }                                              //  и увеличиваем счетчик найденных фрагментов.
                                     else  count_V08++;                 //  А если не поместится, то увеличиваем счетчик пропущенных фрагментов без сохранения в основном массиве.
                         }
                     else                                                 //  Если же проверка места в окне не пройдена на раннем этапе...
                             count_V08+=s.match(reV01s).length;   //  то добавляем в счетчик пропущенных фрагментов все найденные фрагменты.
                 }

         if (s.search(reV11s) != -1) {                   //  Если в строке есть иностранная буква (A, B, C, K, O, Α, Β, Κ, Ο) между русскими словами...
                 if (count_V07<max0)  {                                        //  Проверяем: вместится ли новая строка в окно вопроса.  Если вместится...
                         if (s.search(/</g)!=-1)  s=s.replace(reCT, reCT_);   //  удаляем из строки все внутренние теги и
                         M=s.match(reV12);                                                    //  сохраняем фрагменты текста с такой буквой.
                         for (n=0;  n < M.length;  n++)                                 //  Запускаем цикл для всех найденных фрагментов.
                                 if (count_V07< max0) {                                                          //  Если ещё одна строка поместится в окно вопроса...
                                         mV05[count_V07]=M[n].replace(reV13, reV13_);  //   сохраняем фрагмент в основном массиве
                                         count_V07++;    }                                              //  и увеличиваем счетчик найденных фрагментов.
                                     else  count_V08++;                 //  А если не поместится, то увеличиваем счетчик пропущенных фрагментов без сохранения в основном массиве.
                         }
                     else                                                 //  Если же проверка места в окне не пройдена на раннем этапе...
                             count_V08+=s.match(reV11s).length;   //  то добавляем в счетчик пропущенных фрагментов все найденные фрагменты.
                 }
         }

 }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ФОРМИРОВАНИЕ ВОПРОСА по предлогам
                 //      (применение функции "Vopros")

 var div;    //  Один из дочерних разделов "fbw_body".
 var mP;    //  Массив с параграфами корневого раздела.
 var mPL;    //  Длина этого массива.
 var j;      //  Счетчик цикла.
 var jj;     //  Счетчик цикла.
 var ptr;   //  Параграф.

 var mChild = fbwBody.children;     //  Массив дочерних разделов "fbw_body".

 if (Obrabotka_Predlogov==2)  {                  //  Если в настройках включен просмотр возможных предлогов...
         for (j=0;  j<mChild.length;  j++) {                               //  Запускаем цикл для дочерних разделов "fbw_body".
                 div = mChild[j];
                 if (div.className != "history" || ObrabotkaHistory) {        //  Если найденный раздел не история (при отказе от ее обработки)...
                         mP = div.getElementsByTagName("P");          //  получаем все строки в этом разделе,
                         mPL = mP.length;                                                 //  количество строк
                         for (jj=0;  jj<mPL;  jj++)                              //  и запускаем еще один цикл для строк найденного раздела,
                                 Vopros(mP[jj]);                                //   в котором для каждой строки применяем функцию "Vopros".
                         }
                 }
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ФОРМИРОВАНИЕ ВОПРОСА по предлогам
                 //      (обработка и применение полученных данных)

 var T_pause = 0;  //  Продолжительность диалоговых пауз.
 var otvet = false;


           // Создание текста и окна вопроса

 if (count_V07!=0) {     //  Если найден хотя бы один фрагмент с возможным предлогом...
         var vop = "";
         var fragmentov=["похожий фрагмент", "похожих фрагмента", "похожих фрагментов"];

           // Добавление многоточий
         var reF01 = new RegExp("^[^"+LA+RU+EL+"0-9«„“»”\\\"̲]{0,5}|(.)[^"+LA+RU+EL+"0-9«„“»”\\\"̲]{0,5}$","g");
         var reF01_ = "$1...";

           // Удвоение пробелов для лучшей картинки
         var reF02 = new RegExp("(\\\s|"+nbspEntity+")","g");
         var reF02_ = "  ";

         for (n=0; n<count_V07; n++)             //  Запускаем цикл для найденных фрагментов,  в котором
                vop += "\n"+mV05[n].replace(reF01, reF01_).replace(reF02, reF02_)+"  \n";   //  каждую строку обрабатываем, и создаем из них строки текста.
         if (count_V08>0)                                                                          //  Если есть пропущенные фрагменты...
                 vop = vop.replace(/\n.+\n$/, "\n   * В тексте есть ещё  "+(count_V08+1)+"  "+fragmentov[pad(count_V08+1)]+"\n");   //  заменяем последнюю строку на другую запись.
         T_pause -= new Date().getTime();
         otvet = AskYesNo(" ◊ Сделать подчеркнутые буквы русскими?   \n"+
                                         "-----------------------------------------------------------\n"+
                                         vop);                              //  И получаем ответ на собранный вопрос.
         T_pause += new Date().getTime();
         }

   // Окончательный ответ
 otvet = (Obrabotka_Predlogov==1  ||  otvet);

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОБРАБОТКА ТЕКСТА
                 //      (регулярные выражения)

 //  Общая стартовая формула.
 var re000s = new RegExp("["+LA+EL+"0236]|Х([^"+RU+"]|$)","");


         //   Русские «Х, С, М» и греческие «Ι, Χ, Μ»  в римских числах   :::   В числах

  var RO = "IVXLCDM";   //  Все римские цифры.
  var neRO = "ΙΧΜХСМ";   //  Все буквы, которые могут быть заменены на римские цифры.

 //  Стартовая формула.
 var re001s = new RegExp("["+RO+"]","");

 //  Для добавление меток перед римскими числами.
 var re002 = new RegExp("(^|[^"+LA+RU+EL+"])([ΧХ]{2,}|["+RO+neRO+"]{0,}(["+RO+"]["+neRO+"]|["+neRO+"]["+RO+"])["+RO+neRO+"]{0,})(?=[^"+LA+RU+EL+"]|$)","g");
 var re002_ = "$1"+FalseSim+"$2";

 //  Для извлечение римских чисел в массив.
 var re003 = new RegExp(FalseSim+"["+RO+neRO+"]{1,}","g");

 //  Для возвращения обработанных римских чисел (модификатора "g" здесь нет, поэтому возвращение будет происходить по одному числу).
 var re004 = new RegExp(FalseSim+"["+RO+neRO+"]{1,}","");

 var count_001=0;    //  Счетчик замен.


         //   Замена латинских и греческих букв на русские буквы   :::   В русских словах

 //  Заменяемые символы.
 if (Ud_on_off)
         var mRus  = [ ["[AΑ]", "a", "[BΒ]", "C", "c", "[EΕ]", "e", "Ë", "ë", "[HΗ]", "[KΚ]", "[ĸκ]", "[MΜ]", "[OΟ]", "[oο]", "[PΡ]", "[pρ]", "[TΤ]", "[XΧ]", "x", "y", "Γ", "Π", "Φ", "á", "é", "ú", "[óòό]", "ý"],
                                     [ "А",      "а",   "В",      "С", "с",  "Е",      "е", "Ё", "ё",   "Н",        "К",        "к",       "М",        "О",        "о",       "Р",       "р",       "Т",       "Х",     "х", "у",  "Г", "П", "Ф", "а́", "е́", "и́",  "о́",        "у́"] ];
 else  var mRus  = [ ["[AΑ]", "a", "[BΒ]", "C", "c", "[EΕ]", "e", "Ë", "ë", "[HΗ]", "[KΚ]", "[ĸκ]", "[MΜ]", "[OΟ]", "[oο]", "[PΡ]", "[pρ]", "[TΤ]", "[XΧ]", "x", "y", "Γ", "Π", "Φ"],
                                       [ "А",      "а",   "В",      "С", "с",  "Е",      "е", "Ё", "ё",   "Н",        "К",        "к",       "М",        "О",        "о",       "Р",       "р",       "Т",       "Х",     "х", "у",  "Г", "П", "Ф"] ];

 var length_Rus = mRus[0].length;    //   Длина первой части этого массива.

 //  Все иностранные буквы, которые могут быть заменены русскими.
 if (Ud_on_off)
         var neRU = "AaBCcEeËëHKĸMOoPpTXxyΑΒΓΕΗΚκΜΟοΠΡρΤΦΧáéúóòýό";
     else var neRU = "AaBCcEeËëHKĸMOoPpTXxyΑΒΓΕΗΚκΜΟοΠΡρΤΦΧ";

 //  Стартовая формула.
 var re101s = new RegExp("["+RU+"]["+neRU+"]|["+neRU+"]["+RU+"]","g");

 //  Для добавление меток перед словами со смесью иностранных букв и кириллицы.
 var re102 = new RegExp("(^|[^"+LA+RU+EL+"])(["+RU+neRU+"]{0,}(["+RU+"]["+neRU+"]|["+neRU+"]["+RU+"])["+RU+neRU+"]{0,})(?=[^"+LA+RU+EL+"]|$)","g");
 var re102_ = "$1"+FalseSim+"$2";

 //  Для извлечение слов  в массив.
 var re103 = new RegExp(FalseSim+"["+LA+RU+EL+"]{2,}","g");

 var re104 = new RegExp("[БГДЁЖ-ЙЛПУФЦ-ЯѢѲбвдёжзй-нфц-яѣѳ]","");    //  Однозначно русские буквы (достаточно 1 шт.)
 var re105 = new RegExp("["+RU_+"]","g");                               //  Русские буквы (достаточно 2 шт.)

 //  Словарик для проверки слов из 2-х букв ("i" - регистронезависимый режим).
 var re106 = new RegExp("^(аи|ан|АО|ар|ас|ат|ау|ах|во|Вт|га|го|гр|гс|ее|ем|ер|иа|их|ка|кв|кг|км|кн|ко|кр|ку|мА|мВ|ми|ме|мм|мн|мс|му|на|не|ни|нм|но|нс|ну|ом|он|оп|ор|от|ох|па|пе|пи|по|пр|пс|ре|ро|рт|св|си|се|см|со|ср|ст|су|та|ТВ|те|то|ту|ус|ух|ха|хе|хи|хм|хо)$","i");

 //  Словарик для проверки слов из 3-х букв ("i" - регистронезависимый режим).
 var re107 = new RegExp("^(авт|ага|агу|аир|акр|акт|Ане|ант|АОН|арт|арх|аса|асе|асс|асу|атм|АТС|ату|аут|ахи|ВАК|вам|ван|вар|вас|ВВС|век|вес|виг|ВИП|вир|вис|вне|вое|вон|вор|вот|все|гит|гер|гоп|гос|гот|Ева|Еве|евр|его|ера|еси|иго|игу|ига|иге|исп|ист|исх|как|кап|кат|ква|КВН|кво|кВт|кис|кит|КНР|кое|кок|ком|кон|коп|кот|Кох|кси|кто|кур|кус|кут|кхе|маг|мае|мак|мат|мах|МВт|мга|мес|мех|миг|мир|мне|моа|мОм|мор|мот|мох|нам|нар|нас|нег|нее|нем|нет|нит|них|нок|ном|нос|ноу|НТВ|НТО|НТР|нут|ОАО|ого|Ока|Оке|око|окр|она|ООН|ООО|опа|опт|орг|орт|оса|осе|оси|осн|ост|осу|отв|ОТК|ото|охи|пае|пар|пас|пат|пах|пес|пир|поп|пор|пос|пот|про|пси|пру|пуп|пух|рае|рак|РАО|рев|Рио|рис|Риу|рее|РНК|ров|рог|рое|рок|ром|рот|Рур|рус|сак|сам|сан|сап|СВО|сев|сет|сиг|сие|сии|сип|сир|сиу|сих|сое|сок|сом|сон|сор|спр|ста|сто|стр|суп|сут|таи|так|там|тат|тау|тег|тем|тес|тет|тех|тип|тир|тис|тих|тов|ток|том|тон|топ|тор|тот|три|тсс|тур|тут|уги|угу|упр|ура|ути|уха|ухе|ухи|ухо|уху|хам|хан|хау|хек|хит|хна|хон|хоп|хор)$","i");

 //  Для возвращения обработанных слов (модификатора "g" здесь нет, поэтому замена будет происходить по одному слову).
 var re108 = new RegExp(FalseSim+"["+LA+RU+EL+"]{2,}","");

 var wrd;                     //  Слово.
 var count_101=0;    //  Счетчик замен.


         //   Замена цифр на русские буквы   :::   В строке

 var re200s = new RegExp("[03]","g");

 //  Цифра "3" в начале слова + (три строчные буквы)   ›››   Буква "З".
 var re201 = new RegExp("(^|[^"+LA+RU+EL+"0-9])(3)(?=[а-яёѣѳ]{3})","g");
 var re201_ = "$1"+"З";

 //  Цифра "0" + (3 строчные буквы, или указанные буквы)   ›››   Буква "О".
 var re221 = new RegExp("(^|[^"+LA+RU+EL+"0-9])(0)(?=[а-яёѣѳ]{3}|(н|на|но|ни)([^"+LA+RU+EL+"0-9]|$))","g");
 var re221_ = "$1"+"О";

 var count_201=0;   //  Счетчик замен.


         //   Замена русских и греческих букв на латиницу   :::   В латиноязычных словах

 //  Заменяемые символы.
 var mLat  = [ ["[АΑ]", "а", "[ВΒ]", "С", "с", "[ЕΕ]", "е", "[НΗ]", "[КΚ]", "[МΜ]", "[ОΟ]", "[оο]", "[РΡ]", "р", "[ТΤ]", "[ХΧ]", "х", "у", "Ζ", "Ι", "Ν"],
                            [ "A",      "a",   "B",      "C", "c",  "E",      "e",   "H",        "K",       "M",         "O",       "o",       "P",     "p",    "T",       "X",     "x", "y", "Z", "I", "N"] ];
 var length_Lat = mLat[0].length;    //   Длина первой части этого массива.

 var neLA = "АаВСсЕеНКМОоРрТХхуΑΒΕΖΗΙΚΜΝΟοΡΤΧ";   //  Все русские и греческие буквы, которые могут быть заменены латинскими.

 //  Стартовая формула.
 var re301s = new RegExp("["+LA+"]["+neLA+"]|["+neLA+"]["+LA+"]","g");

 //  Для добавление меток перед словами со смесью латинских, русских и греческих букв.
 var re302 = new RegExp("(^|[^"+LA+RU+EL+"])(["+LA+neLA+"]{0,}(["+LA+"]["+neLA+"]|["+neLA+"]["+LA+"])["+LA+neLA+"]{0,})(?=[^"+LA+RU+EL+"]|$)","g");
 var re302_ = "$1"+FalseSim+"$2";

 //  Для извлечение слов  в массив.
 var re303 = new RegExp(FalseSim+"["+LA+RU+EL+"]{2,}","g");

 var re304 = new RegExp("[DFGLNQRUYZbdfklqtzÀÂÃÅÊÌÍÎÐÑÒÔÕØ-àâãåêìíîðñôõøùûüþ]","");    //  Однозначно латинские буквы (достаточно 1 шт.)
 var re305 = new RegExp("["+LA_+"]","g");    //  Латинские буквы (достаточно 2 шт.)

 //  Для возвращения обработанных слов (модификатора "g" здесь нет, поэтому замена будет происходить по одному слову).
 var re308 = new RegExp(FalseSim+"["+LA+RU+EL+"]{2,}","");

 var count_301=0;    //  Счетчик замен.


         //   Замена русских и латинских букв на греческие буквы   :::   В греческих словах

 //  Заменяемые символы.
 var mEll  = [ ["[АA]", "[ВB]", "Г", "[ЕE]", "[НH]", "[КK]", "к", "[МM]", "[ОO]", "[оo]", "П", "[РP]", "р", "[ТT]", "Ф", "[ХX]", "Z", "I", "N"],
                           [ "Α",        "Β",     "Γ",    "Ε",       "Η",        "Κ",     "κ",    "Μ",         "Ο",      "ο",     "Π",   "Ρ",     "ρ",    "Τ",     "Φ",   "Χ",     "Ζ", "Ι", "Ν"] ];
 var length_Ell = mEll[0].length;    //   Длина первой части этого массива.

 var neEL = "АВГЕНКкМОоПРрТФХABEZHIKMNOoPTX";   //  Все русские и латинские буквы, которые могут быть заменены греческими.

 //  Стартовая формула.
 var re401s = new RegExp("["+EL+"]["+neEL+"]|["+neEL+"]["+EL+"]","g");

 //  Для добавление меток перед словами со смесью латинских, русских и греческих букв.
 var re402 = new RegExp("(^|[^"+LA+RU+EL+"])(["+EL+neEL+"]{0,}(["+EL+"]["+neEL+"]|["+neEL+"]["+EL+"])["+EL+neEL+"]{0,})(?=[^"+LA+RU+EL+"]|$)","g");
 var re402_ = "$1"+FalseSim+"$2";

 //  Для извлечение слов  в массив.
 var re403 = new RegExp(FalseSim+"["+LA+RU+EL+"]{2,}","g");

 var re405 = new RegExp("["+EL_+"]","g");    //  Греческие буквы (достаточно 2 шт.)

 //  Для возвращения обработанных слов (модификатора "g" здесь нет, поэтому замена будет происходить по одному слову).
 var re408 = new RegExp(FalseSim+"["+LA+RU+EL+"]{2,}","");

 var count_401=0;    //  Счетчик замен.


         //   Замена иностранных букв в предлогах на русские буквы   :::   В строке

 //  Стартовая формула.
 var re501s = new RegExp("[ABCKOΑΒΚΟacouyĸκο]","g");

 //  Заменяемые символы.
 var mPred  = [ ["[AΑ]", "[BΒ]", "C", "[KΚ]", "[OΟ]", "a", "c", "[oο]", "u", "y", "[ĸκ]"],
                               [ "А",        "В",      "С",   "К",        "О",     "а", "с",    "о",    "и", "у",   "к"] ];
 var length_Pred = mPred[0].length;    //   Длина первой части этого массива.

 var rePred  = [];
 var rePred_  = [];

 //  Формулы для замены латинских и греческих букв (A, B, C, K, O, Α, Β, Κ, Ο) на русские предлоги
 for (n=0; n<5; n++) {
         rePred[n] = new RegExp("(^|[…\\\.\\\?!](\\\s|"+nbspEntity+"))([—–\\\-](\\\s|"+nbspEntity+")){0,1}"+mPred[0][n]+"(\\\s|"+nbspEntity+")(?=[«\\\"„]{0,1}["+RU+"])","g");
         rePred_[n] = "$1$3"+mPred[1][n]+"$5";
         }

 //  Формулы для замены латинских и греческих букв (a, c, o, u, y, ĸ, κ, ο) на русские предлоги
 for ( ; n<length_Pred; n++) {
         rePred[n] = new RegExp("(["+RU+"][,»\\\"“]{0,2})((\\\s|"+nbspEntity+")[—–\\\-]){0,1}(\\\s|"+nbspEntity+")"+mPred[0][n]+"(\\\s|"+nbspEntity+")(?=[«\\\"„]{0,2}["+RU+"])","g");
         rePred_[n] = "$1$2$4"+mPred[1][n]+"$5";
         }

 var count_501=0;   //  Счетчик замен.


         //   Замена некоторых отдельностоящих букв "Х", "Χ", "Ι" на латинские "X", "I"   :::   В строке

 var re010s = new RegExp("(^|[^"+LA+RU+EL+"])[ΧХΙ]([^"+LA+RU+EL+"]|$)","g");

 //  "Х", "Χ"

 //  Глава/Часть/Том/Книга Х      или     Х в./вв./век/съезд       + склонение по падежам ([А-я]{0,3}) + Возможный капс в заголовках
 var re012 = new RegExp("(^|[^"+LA+RU+EL+"])([Гг]лав|ГЛАВ|[Чч]аст|ЧАСТ|[Тт]ом|ТОМ|[Кк]ниг|КНИГ)([А-я]{0,3})(\\\s|"+nbspEntity+")[ΧХ]([^"+LA+RU+EL+"]|$)|(^|[^"+LA+RU+EL+"])[ΧХ](\\\s|"+nbspEntity+")([Вв]\\\.|ВВ\\\.|вв\\\.|[Вв]ек[а-я]{0,3}|ВЕК[А-Я]{0,3}|[Сс]ъезд[а-я]{0,3}|СЪЕЗД[А-Я]{0,3})([^"+LA+RU+EL+"]|$)","g");
 var re012_ = "$1$2$3$4$6X$5$7$8$9";

 //  Карл Х, Пий Х и т.д.  (исключаются точка, дефис, тире и т.д. в конце из-за инициалов, сокращений и т.п.)
 var re013 = new RegExp("(^|[^"+LA+RU+EL+"])([А-ЯA-ZѲѢ][а-яa-zёѣѳ]{1,})(\\\s|"+nbspEntity+")[ΧХ]([,:;\\\?!\\\)\\\]»”\\\"]|\\\s|"+nbspEntity+"|$)","g");
 var re013_ = "$1$2$3X$4";

 //  Промежуток:   Х – [римское число из правильных цифр]
 var re014 = new RegExp("(^|[^"+LA+RU+EL+"])[ΧХ](\\\s|"+nbspEntity+"){0,1}([—–\\\-])(\\\s|"+nbspEntity+"){0,1}(["+RO+"]{2,})([^"+LA+RU+EL+"]|$)","g");
 var re014_ = "$1X$2$3$4$5$6";

 //  Промежуток:   [римское число из правильных цифр] – Х
 var re015 = new RegExp("(^|[^"+LA+RU+EL+"])(["+RO+"]{1,})(\\\s|"+nbspEntity+"){0,1}([—–\\\-])(\\\s|"+nbspEntity+"){0,1}[ΧХ]([^"+LA+RU+EL+"]|$)","g");
 var re015_ = "$1$2$3$4$5X$6";

 //   "Ι"

 var re022 = new RegExp("(^|[^"+LA+RU+EL+"])([Гг]лав|ГЛАВ|[Чч]аст|ЧАСТ|[Тт]ом|ТОМ|[Кк]ниг|КНИГ)([А-я]{0,3})(\\\s|"+nbspEntity+")Ι([^"+LA+RU+EL+"]|$)|(^|[^"+LA+RU+EL+"])Ι(\\\s|"+nbspEntity+")([Вв]\\\.|ВВ\\\.|вв\\\.|[Вв]ек[а-я]{0,3}|ВЕК[А-Я]{0,3}|[Сс]ъезд[а-я]{0,3}|СЪЕЗД[А-Я]{0,3})([^"+LA+RU+EL+"]|$)","g");
 var re022_ = "$1$2$3$4$6I$5$7$8$9";

 var re023 = new RegExp("(^|[^"+LA+RU+EL+"])([А-ЯA-ZѲѢ][а-яa-zёѣѳ]{1,})(\\\s|"+nbspEntity+")Ι([,:;\\\?!\\\)\\\]»”\\\"]|\\\s|"+nbspEntity+"|$)","g");
 var re023_ = "$1$2$3I$4";

 var re024 = new RegExp("(^|[^"+LA+RU+EL+"])Ι(\\\s|"+nbspEntity+"){0,1}([—–\\\-])(\\\s|"+nbspEntity+"){0,1}(["+RO+"]{2,})([^"+LA+RU+EL+"]|$)","g");
 var re024_ = "$1I$2$3$4$5$6";

 var re025 = new RegExp("(^|[^"+LA+RU+EL+"])(["+RO+"]{1,})(\\\s|"+nbspEntity+"){0,1}([—–\\\-])(\\\s|"+nbspEntity+"){0,1}Ι([^"+LA+RU+EL+"]|$)","g");
 var re025_ = "$1$2$3$4$5I$6";

 // используется счетчик "count_001"



         //   Поиск потерянных русских слов

 var neRUfull = "AaBCcEeËëHKĸMOoPpTXxyΑΒβΓΕΗΚκΜΟοΠΡρΤΦΧáéúóòýόmnru036";

 var re900s = new RegExp("["+RU+"]["+neRUfull+"]|["+neRUfull+"]["+RU+"]|[аеиоуыэюя]2|(^|[^"+LA+RU+EL+"0-9])([AaBCcEeHKMnOoPpTXxy]{2,4})([^"+LA+RU+EL+"0-9]|$)","g");
 var re901 = new RegExp("(^|[^"+LA+RU+EL+"0-9])((["+RU+neRUfull+"]{0,}(["+RU_+"]"+ud+"{0,1}["+neRUfull+"]|["+neRUfull+"]"+ud+"{0,1}["+RU_+"]|[аеиоуыэюя]2)["+RU+neRUfull+"]{0,})|(Ax|ax|Ay|ay|Bo|CM|CO|Co|co|Cp|cp|Ee|ee|Ha|HE|He|Ho|Hy|KB|no|Ox|ox|Ta|Te|To|Xa|xa|Xe|xe|Xo|xo|yx|AKT|APT|Apx|apx|BAC|Bac|BCE|Bce|CTO|Hac|HET|Hoc|KAK|KOE|Koe|KTO|Kxe|MHE|Mop|Mox|OAO|Oca|oca|OOH|OOO|OTK|pae|pee|PHK|Pyc|pyc|TAK|TAM|Tcc|TEM|Tex|TOM|Typ|ypa|yxa|yxe|yxo|yxy|Bcex|Capa|CCCP|HACA|HATO|Mapc|Mope|MXAT|TACC|Xaoc|xaoc|Xoce))(?=[^"+LA+RU+EL+"0-9>][^>]{0,}(<|$)|<|$)","g");
 var m901=[];                 //  Найденные строки с ошибками.
 var m901_num = [];            //  Номера этих строк.


         //   Поиск потерянных латинских слов

 var neLAfull = "АаВСсЕеЁёНКМОоРрТХхуΑΒβΕΖΗΙΚΜΝΟοΡρΤΧтпги01";

 var re910s = new RegExp("["+LA+"]["+neLAfull+"]|["+neLAfull+"]["+LA+"]","g");
 var re911 = new RegExp("(^|[^"+LA+RU+EL+"0-9])(["+LA+neLAfull+"]{0,}(["+LA_+"]"+ud+"{0,1}["+neLAfull+"]|["+neLAfull+"]"+ud+"{0,1}["+LA_+"])["+LA+neLAfull+"]{0,})(?=[^"+LA+RU+EL+"0-9>][^>]{0,}(<|$)|<|$)","g");
 var m911=[];                 //  Найденные строки с ошибками.
 var m911_num = [];            //  Номера этих строк


         //   Поиск потерянных греческих слов   //

 var neELfull = "АВГЕНКкМОоПРрТФХABEZHIKMNOoPpTX0";

 var re920s = new RegExp("(["+EL+"]["+neELfull+"]|["+neELfull+"]["+EL+"])","g");
 var re921 = new RegExp("(^|[^"+LA+RU+EL+"0-9])(["+EL+neELfull+"]{0,}(["+EL_+"]"+ud+"{0,1}["+neELfull+"]|["+neELfull+"]"+ud+"{0,1}["+EL_+"])["+EL+neELfull+"]{0,})(?=[^"+LA+RU+EL+"0-9>][^>]{0,}(<|$)|<|$)","g");
 var m921=[];                 //  Найденные строки с ошибками.
 var m921_num = [];            //  Номера этих строк

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОБРАБОТКА ТЕКСТА
                 //      (сборка функции "HandleP")

 var s="";                   //  Содержание строки.
 var sTxt="";                //  Текст строки.
 var count_P=0;        // Счетчик строк.
 var count_all=0;        // Счетчик исправленных строк.
 var mChangeP = [];  // массив с индикаторами изменения каждой строки.


 // функция, обрабатывающая абзац P
 function HandleP(ptr) {

 sTxt=ptr.innerText;    //  Текст строки.
 count_P++;          //  Увеличение счетчика строк.

 if (sTxt.search(re000s)<0)   //  Если в строке нет ни цифр, ни иностранных букв...
         return;               //  выходим из функции.

 s=ptr.innerHTML;    //  Содержание строки.

         //  Замена русских и греческих букв на латинские  :::  В римских числах

 if (sTxt.search(re001s)>=0  &&  s.search(re002)>=0) {   //  Если в строке найдено римские числа, которые можно исправить...
         s=s.replace(re002, re002_);                  //  то добавляем перед ними метки
         M = s.match(re003);                             //  и отправляем эти числа в массив.
         for (n=0; n<M.length; n++)  {                             //  Запускаем цикл для этих чисел, в котором...
                 M[n]=M[n].replace(FalseSim, "");                                   //  удаляем метку,
                 if (M[n].search(/Ι/)>=0)  M[n]=M[n].replace(/Ι/g, "I");         //  заменяем все греческие буквы "Ι" на латинскую "I",
                 if (M[n].search(/[ΧХ]/)>=0)  M[n]=M[n].replace(/[ΧХ]/g, "X");         //  заменяем все греческие/русские буквы "Х" на латинскую "X",
                 if (M[n].search(/С/)>=0)  M[n]=M[n].replace(/С/g, "C");         //  заменяем все русские буквы "С" на латинскую "C",
                 if (M[n].search(/[ΜМ]/)>=0)  M[n]=M[n].replace(/[ΜМ]/g, "M");         //  заменяем все греческие/русские буквы "М" на латинскую "M",
                 s=s.replace(re004, M[n]);                        //  возвращаем обработанное число обратно в строку
                 count_001++;                                         //  и увеличиваем счетчик замен.
                 }
         }

         //  Замена латиницы на нормальные буквы   :::   В словах

 if (sTxt.search(re101s)>=0  &&  s.search(re102)>=0) {   //  Если в строке найдены русские слова с добавлением иностранных букв...
         s=s.replace(re102, re102_);                  //  то добавляем перед ними метки
         M = s.match(re103);                             //  и отправляем эти слова в массив.
         for (n=0; n<M.length; n++)  {                     //  Запускаем цикл для этих слов, в котором...
                 M[n]=M[n].replace(FalseSim, "");   //  удаляем метку и
                 wrd=M[n];                                                //  сохраняем слово в переменной.
                 for (k=0; k<length_Rus; k++)                              //  Запускаем внутренний цикл для пробной замены букв, в котором...
                         if (wrd.search(mRus[0][k])>=0)                       //  если будет найдена очередная заменяемая иностранная буква из массива...
                                 wrd=wrd.replace(new RegExp(mRus[0][k],"g"), mRus[1][k]);    //  то заменяем её на соответствующую русскую.
                 //  Если в первоначальном слове есть одна однозначно русская буква, или две любые русские буквы. Или если измененное слово есть в словариках...
                 if (M[n].search(re104)>=0  ||  M[n].search(re105)>=0  &&  M[n].match(re105).length>=2  ||  wrd.search(re106)>=0  ||  wrd.search(re107)>=0) {
                         count_101++;     //  то увеличиваем счетчик замен
                         M[n]=wrd;   //  и утверждаем замену.
                         }
                 s=s.replace(re108, M[n]);   //  В конце основного цикла возвращаем обработанное слово.
                 }
         }

         //  Замена цифр на нормальные буквы   :::   В строке

 if (sTxt.search(re200s)>=0)  {
         if (s.search(re201)>=0)       { count_201 += s.match(re201).length;    s=s.replace(re201, re201_);  }
         if (s.search(re221)>=0)       { count_201 += s.match(re221).length;    s=s.replace(re221, re221_);  }
         }

         //  Замена кириллицы на латиницу   :::   В словах

 if (sTxt.search(re301s)>=0  &&  s.search(re302)>=0) {   //  Если в строке найдены латиноязычные слова с добавлением русских букв...
         s=s.replace(re302, re302_);                  //  то добавляем перед ними метки
         M = s.match(re303);                             //  и отправляем эти слова в массив.
         for (n=0; n<M.length; n++)  {                     //  Запускаем цикл для этих слов, в котором...
                 wrd=M[n];                                                //  сохраняем слово в переменной,
                 wrd=wrd.replace(FalseSim, "");               //  удаляем метку.
                 if (wrd.search(re304)>=0  ||  wrd.search(re305)>=0  &&  wrd.match(re305).length>=2) {   //  Если в слове есть одна однозначно латинская буква, или две любые латинские буквы...
                         count_301++;                                                     //  то увеличиваем счетчик замен.
                         for (k=0; k<length_Lat; k++)                              //  Запускаем внутренний цикл для замены букв, в котором...
                                 if (wrd.search(mLat[0][k])>=0)                       //  если будет найдена очередная заменяемая русская буква из массива...
                                         wrd=wrd.replace(new RegExp(mLat[0][k],"g"), mLat[1][k]);    //  то заменяем её на соответствующую латинскую.
                         }
                 s=s.replace(re308, wrd);   //  В конце основного цикла возвращаем обработанное слово.
                 }
         }


         //  Замена кириллицы на греческие буквы   :::   В словах

 if (sTxt.search(re401s)>=0  &&  s.search(re402)>=0) {   //  Если в строке найдены греческие слова с добавлением русских букв...
         s=s.replace(re402, re402_);                  //  то добавляем перед ними метки
         M = s.match(re403);                             //  и отправляем эти слова в массив.
         for (n=0; n<M.length; n++)  {                     //  Запускаем цикл для этих слов, в котором...
                 wrd=M[n];                                                //  сохраняем слово в переменной,
                 wrd=wrd.replace(FalseSim, "");              //  удаляем метку.
                 if (wrd.search(re405)>=0  &&  wrd.match(re405).length>=2) {             //  Если в нем есть две любые греческие буквы...
                         count_401++;                                                     //  то увеличиваем счетчик замен;
                         for (k=0; k<length_Ell; k++)                              //  Запускаем внутренний цикл для замены букв, в котором...
                                 if (wrd.search(mEll[0][k])>=0)                       //  если будет найдена очередная заменяемая русская буква из массива...
                                         wrd=wrd.replace(new RegExp(mEll[0][k],"g"), mEll[1][k]);    //  то заменяем её на соответствующую греческую.
                         }
                 s=s.replace(re408, wrd);   //  В конце основного цикла возвращаем обработанное слово.
                 }
         }


         //  Замена иностранных букв в предлогах на нормальные буквы   :::   В строке

 if(otvet  &&  sTxt.search(re501s)>=0)
         for (n=0; n<length_Pred; n++)
                 if (s.search(rePred[n])>=0) {
                         count_501 += s.match(rePred[n]).length;
                         s=s.replace(rePred[n], rePred_[n]);
                         }


         //  Замена некоторых отдельностоящих букв "Х", "Χ", "Ι" на латинские "X", "I"   :::   В строке

 if (sTxt.search(re010s)>=0) {
         if (s.search(re012)>=0)       { count_001 += s.match(re012).length;    s=s.replace(re012, re012_);  }
         if (s.search(re013)>=0)       { count_001 += s.match(re013).length;    s=s.replace(re013, re013_);  }
         if (s.search(re014)>=0)       { count_001 += s.match(re014).length;    s=s.replace(re014, re014_);  }
         if (s.search(re015)>=0)       { count_001 += s.match(re015).length;    s=s.replace(re015, re015_);  }

         if (s.search(re022)>=0)       { count_001 += s.match(re022).length;    s=s.replace(re022, re022_);  }
         if (s.search(re023)>=0)       { count_001 += s.match(re023).length;    s=s.replace(re023, re023_);  }
         if (s.search(re024)>=0)       { count_001 += s.match(re024).length;    s=s.replace(re024, re024_);  }
         if (s.search(re025)>=0)       { count_001 += s.match(re025).length;    s=s.replace(re025, re025_);  }
         }

         //  Сохранение строки

 if (ptr.innerHTML != s)  {   //  Если строка была изменена...
         ptr.innerHTML=s;         //  сохраняем её в тексте,
         count_all++;                           //  увеличиваем счетчик измененных строк
         mChangeP[count_P]=true;   // и ставим отдельную отметку об изменении именно этой строки.
         }

         //   Поиск пропущенных слов

 if (sTxt.search(re900s)>=0  &&  s.search(re901)>=0) {   //  Если в строке найдены пропущенные слова, которые можно транслитерировать в русское слово...
         m901.push(ptr);                                //  то добавляем строку в массив
         m901_num.push(count_P);    //  и записываем номер этой строки.
         }

 if (sTxt.search(re910s)>=0  &&  s.search(re911)>=0) {   //  Если в строке найдены пропущенные слова, которые можно транслитерировать в латинское слово...
         m911.push(ptr);                                //  то добавляем строку в массив
         m911_num.push(count_P);    //  и записываем номер этой строки.
         }

 if (sTxt.search(re920s)>=0  &&  s.search(re921)>=0) {   //  Если в строке найдены пропущенные слова, которые можно транслитерировать в греческое слово...
         m921.push(ptr);                                //  то добавляем строку в массив
         m921_num.push(count_P);    //  и записываем номер этой строки.
         }

 }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОБРАБОТКА ТЕКСТА
                 //      (применение функции "HandleP")

 window.external.BeginUndoUnit(document, ScriptName + " v."+NumerusVersion);    // Начало записи в систему отмен.


 for (j=0;  j<mChild.length;  j++) {                               //  Запускаем цикл для дочерних разделов "fbw_body".
         div = mChild[j];
         if (div.className != "history" || ObrabotkaHistory) {        //  Если найденный раздел не история (при отказе от ее обработки)...
                 mP = div.getElementsByTagName("P");          //  получаем все строки в этом разделе,
                 mPL = mP.length;                                                 //  количество строк
                 for (jj=0;  jj<mPL;  jj++)                              //  и запускаем еще один цикл для строк найденного раздела,
                         HandleP(mP[jj]);                                //   в котором для каждой строки применяем функцию "HandleP".
                 }
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ПОСТОБРАБОТКА  :  Полуавтоматические исправления

 var mElem=[];   var elem1="";   var elem2="";   //  для элементов <LABEL>
 var otvet_txt;   var msgTitle="";   var msg="";   //  для диалога
 var otmena = false;    //  индикатор кнопки "Отмена"

 var Dict1 = [];   //  словарь заменяемых слов
 var count_Dict1=0;
 var Dict2 = [];   //  словарь правильных слов
 var Dict3 = [];   //  словарь пропущенных слов
 var count_Dict3=0;

         // Функция добавления стиля для выделения
 function LABELstyle(el) {
         el.style.color="#005B32";
         el.style.backgroundColor="#EDEDED";
         el.style.fontSize="110%";
         el.style.paddingLeft="1px";
         el.style.paddingRight="1px";
         el.style.paddingBottom="1px";
         }

         // Функция очистки стиля для выделения
 function LABELstyleOf(el) {
         el.style.border = "1px solid #005B32"
         el.style.removeAttribute("color");
         el.style.removeAttribute("backgroundColor");
         el.style.removeAttribute("fontSize");
         el.innerHTML = el.innerHTML.replace(/<\/?FONT[^>]*>/g, "");
         }

         // Функция обработки ответа
 function HandleOtvet() {
         if (otvet == 6)  {                                                   // "Да":  исправление ошибки и запоминание слов
                 if (otvet_txt.search(/^ *$/g)==-1  &&  otvet_txt != elem1)  { mElem[n].innerHTML = otvet_txt; Dict2[count_Dict1] = otvet_txt }
                     else  { mElem[n].innerHTML = elem2;  Dict2[count_Dict1] = elem2 }
                 Dict1[count_Dict1] = elem1;
                 count_Dict1++;
                 return 1;    }
         if (otvet == 7)  {                                                   // "Нет":  запоминание пропущенного слова
                 Dict3[count_Dict3] = elem1;
                 count_Dict3++;
                 return 0;    }
         }


         // Транслитерация пропущенных русских слов

 var length901=m901.length;    //  Длина массива с найденными строками.

// повтор // var re901 = new RegExp("(^|[^"+LA+RU+EL+"0-9])((["+RU+neRUfull+"]{0,}(["+RU_+"]"+ud+"{0,1}["+neRUfull+"]|["+neRUfull+"]"+ud+"{0,1}["+RU_+"]|[аеиоуыэюя]2)["+RU+neRUfull+"]{0,})|(Ax|ax|Ay|ay|Bo|CM|CO|Co|co|Cp|cp|Ee|ee|Ha|HE|He|Ho|Hy|KB|no|Ox|ox|Ta|Te|To|Xa|xa|Xe|xe|Xo|xo|yx|AKT|APT|Apx|apx|BAC|Bac|BCE|Bce|CTO|Hac|HET|Hoc|KAK|KOE|Koe|KTO|Kxe|MHE|Mop|Mox|OAO|Oca|oca|OOH|OOO|OTK|pae|pee|PHK|Pyc|pyc|TAK|TAM|Tcc|TEM|Tex|TOM|Typ|ypa|yxa|yxe|yxo|yxy|Bcex|Capa|CCCP|HACA|HATO|Mapc|Mope|MXAT|TACC|Xaoc|xaoc|Xoce))(?=[^"+LA+RU+EL+"0-9>][^>]{0,}(<|$)|<|$)","g");
 var re901_LABEL = "$1<LABEL>$2</LABEL>";     //  Обрамление тегами   фрагмента с ошибкой.
 var re902 = new RegExp("^((["+RU+neRUfull+"]{0,}(["+RU_+"]"+ud+"{0,1}["+neRUfull+"]|["+neRUfull+"]"+ud+"{0,1}["+RU_+"]|[аеиоуыэюя]2)["+RU+neRUfull+"]{0,})|(Ax|ax|Ay|ay|Bo|CM|CO|Co|co|Cp|cp|Ee|ee|Ha|HE|He|Ho|Hy|KB|no|Ox|ox|Ta|Te|To|Xa|xa|Xe|xe|Xo|xo|yx|AKT|APT|Apx|apx|BAC|Bac|BCE|Bce|CTO|Hac|HET|Hoc|KAK|KOE|Koe|KTO|Kxe|MHE|Mop|Mox|OAO|Oca|oca|OOH|OOO|OTK|pae|pee|PHK|Pyc|pyc|TAK|TAM|Tcc|TEM|Tex|TOM|Typ|ypa|yxa|yxe|yxo|yxy|Bcex|Capa|CCCP|HACA|HATO|Mapc|Mope|MXAT|TACC|Xaoc|xaoc|Xoce))$","g");  //  Дополнительная проверка.
 otmena = false;           //  Индикатор нажатой кнопки "Отмена".
 var count_901 = 0;    //  Счетчик замен.

 //  Заменяемые символы.
 var mRusFull  = [ ["[AΑ]", "a", "[BΒ]", "C", "c", "[EΕ]", "e", "Ë", "ë", "[HΗ]", "[KΚ]", "[ĸκ]", "[MΜ]", "[OΟ0]", "[oο]", "[PΡ]", "[pρ]", "[TΤ]", "[XΧ]", "x", "y", "β", "Γ", "Π", "Φ", "m", "n", "r", "u", "3", "6", "á|а2", "é|е2", "ú|и2", "[óòό]|о2", "ý|у2", "ы2", "э2", "ю2", "я2"],
                                    [  "А",      "а",    "В",     "С", "с",   "Е",     "е", "Ё", "ё",   "Н",        "К",        "к",       "М",        "О",           "о",       "Р",       "р",        "Т",       "Х",    "х", "у", "в", "Г",  "П", "Ф", "т", "п", "г", "и",  "З", "б",   "а́",       "е́",       "и́",        "о́",                "у́",        "ы́",    "э́",    "ю́",   "я́"] ];
 var length_RusFull = mRusFull[0].length;    //   Длина первой части этого массива.

 for (j=0;  j<length901;  j++) {   //  Запускаем основной цикл для проверки всех найденных строк.
         if (otmena)  break;            //  Если была нажата кнопка "Отмена"  -  выходим из цикла.
         ptr=m901[j];                     // Получаем одну из найденных ранее строк
         s=ptr.innerHTML;           //  и содержимое этой строки.
         ptr.innerHTML=s.replace(re901, re901_LABEL);   //  Обрамляем слово с ошибкой тегами <LABEL>
         mElem=ptr.getElementsByTagName("LABEL");       //  и получаем все узлы <LABEL> в строке.
L901:
         for (n=0; n<mElem.length; n++) {     //  Запускаем цикл для проверки отдельных слов.
                 elem1 = mElem[n].innerHTML;         //  Получаем содержимое узла <LABEL>.
                 if (elem1.search(re902)==-1)     //  Если внутри этого узла нет ошибочного слова...
                         continue;                              //  то переходим к следующему узлу <LABEL>.
                 for (k=0; k<count_Dict1; k++) {           //  Запускаем цикл для проверки слова по словарям с уже одобренными словами.
                         if (elem1 == Dict1[k]) {                              //  Если проверяемое слово уже заменялось...
                                 count_901++;  mElem[n].innerHTML = Dict2[k];  //  то повторяем замену пользователя
                                 continue L901;                                     //  и переходим к следующему узлу <LABEL>.
                                 }
                         if (elem1 == Dict2[k])       //  Если проверяемое слово есть среди правильных слов...
                                 continue L901;            //  то переходим к следующему узлу <LABEL>.
                         }
                 for (k=0; k<count_Dict3; k++)   //  Запускаем цикл для проверки слова по словарю с пропущенными словами.
                         if (elem1 == Dict3[k])      //  Если слово ужа пропускалось...
                                 continue L901;       //  и переходим к следующему узлу <LABEL>.
                 elem2=elem1;
                 for (k=0; k<length_RusFull; k++)                              //  Запускаем внутренний цикл для замены букв, в котором...
                         if (elem2.search(mRusFull[0][k])>=0)                       //  если будет найдена очередная заменяемая буква из массива...
                                 elem2=elem2.replace(new RegExp(mRusFull[0][k],"g"), mRusFull[1][k]);    //  то заменяем её на соответствующую русскую.
                 if (s.length<50000)                  //   Если проверяемая строка нормальной длины...
                         GoTo_0(mElem[n]);               // то переходим на узел <LABEL>.
                 msgTitle = " •  Ручное восстановление русских слов  /"+(j+1)+"-я строка из "+length901+"/";  // Создаем заголовок окна,
                 msg = "•   Найдено слово:	" + elem1 + "\n◊  Заменить все красные символы на русские буквы?";  //  текст в окне
                 LABELstyle(mElem[n]);                          // Добавляем стиль слова (фон, цвет и размер шрифта),
                 mElem[n].style.border = "2px solid #A00000";    //  красную рамку.
                 for (k=0; k<length_RusFull; k++)                              //  Запускаем внутренний цикл для поиска букв, в котором...
                         if (mElem[n].innerHTML.search(mRusFull[0][k])>=0)    //  для каждой найденной заменяемой буквы, изменяем ее цвет.
                                 mElem[n].innerHTML=mElem[n].innerHTML.replace(new RegExp("("+mRusFull[0][k]+")(?=[^>]{0,}(<|$))","g"), '<FONT style="color: #A00000">$1</FONT>');
                 T_pause -= new Date().getTime();
                 otvet_txt = window.external.InputBox(msg, msgTitle, elem2);       //  Выводим на экран диалоговое окно, и сохраняем введенный текст.
                 T_pause += new Date().getTime();
                 LABELstyleOf(mElem[n]);                                    //  Удаляем стиль слова.
                 otvet = window.external.GetModalResult();    //  Получаем код нажатой кнопки на диалоговом окне.
                 if (otvet == 2) {    //  Если была нажата кнопка "Отмена"...
                         otmena = true;   //  то отмечаем это на индикаторе
                         break;        //  и прерываем цикл для проверки отдельных слов.
                         }
                 count_901 += HandleOtvet();   //  Запускаем функцию для обработки ответа, и увеличиваем (или не увеличиваем) счетчик замен.
                 }
         for (n=mElem.length-1; n>=0; n--)    //  После обработки всех ошибочных слов в одной строке, запускаем цикл, в котором...
                 mElem[n].removeNode(false);      //  удаляем все форматы <LABEL> с остатками стиля.
         if (s != ptr.innerHTML  &&  ! mChangeP[m901_num[j]]) {    //  Если строка изменена и до этого не изменялась...
                 count_all++;                                               //  то увеличиваем счетчик изменений строк
                 mChangeP[m901_num[j]] = true;   //  и включаем индикатор изменения для этой строки.
                 }
         }


         // Транслитерация пропущенных латинских слов

 otmena = false;
 count_Dict1=0;
 count_Dict3=0;

 var length911=m911.length;    //  Длина массива с найденными строками.

// повтор // var re911 = new RegExp("(^|[^"+LA+RU+EL+"0-9])(["+LA+neLAfull+"]{0,}(["+LA_+"]"+ud+"{0,1}["+neLAfull+"]|["+neLAfull+"]"+ud+"{0,1}["+LA_+"])["+LA+neLAfull+"]{0,})(?=[^"+LA+RU+EL+"0-9>][^>]{0,}(<|$)|<|$)","g");
 var re911_LABEL = "$1<LABEL>$2</LABEL>";     //  Обрамление тегами   фрагмента с ошибкой.
 var re912 = new RegExp("^["+LA+neLAfull+"]{0,}(["+LA_+"]"+ud+"{0,1}["+neLAfull+"]|["+neLAfull+"]"+ud+"{0,1}["+LA_+"])["+LA+neLAfull+"]{0,}$","g");  //  Дополнительная проверка.
 otmena = false;           //  Индикатор нажатой кнопки "Отмена".
 var count_911 = 0;    //  Счетчик замен.

 //  Заменяемые символы.
 var mLAFull  = [ ["[АΑ]", "а", "[ВΒ]", "С", "с", "[ЕΕ]", "е", "Ё", "ё", "[НΗ]", "[КΚ]", "[МΜ]", "[ОΟ0]", "[оο]", "[РΡ]", "[рρ]", "[ТΤ]", "[ХΧ]", "х", "у", "β", "Ζ", "Ι", "Ν", "т",  "п", "г", "и", "1"],
                                   [ "A",     "a",    "B",     "C", "c",   "E",      "e", "Ë", "ë",   "H",       "K",        "M",        "O",           "o",       "P",       "p",      "T",        "X",      "x", "y", "ß", "Z", "I", "N", "m", "n", "r", "u", "I"] ];
 var length_LAFull = mLAFull[0].length;    //   Длина первой части этого массива.

 for (j=0;  j<length911;  j++) {   //  Запускаем основной цикл для проверки всех найденных строк.
         if (otmena)  break;            //  Если была нажата кнопка "Отмена"  -  выходим из цикла.
         ptr=m911[j];                     // Получаем одну из найденных ранее строк
         s=ptr.innerHTML;           //  и содержимое этой строки.
         ptr.innerHTML=s.replace(re911, re911_LABEL);   //  Обрамляем слово с ошибкой тегами <LABEL>
         mElem=ptr.getElementsByTagName("LABEL");       //  и получаем все узлы <LABEL> в строке.
L911:
         for (n=0; n<mElem.length; n++) {     //  Запускаем цикл для проверки отдельных слов.
                 elem1 = mElem[n].innerHTML;         //  Получаем содержимое узла <LABEL>.
                 if (elem1.search(re912)==-1)     //  Если внутри этого узла нет ошибочного слова...
                         continue;                              //  то переходим к следующему узлу <LABEL>.
                 for (k=0; k<count_Dict1; k++) {           //  Запускаем цикл для проверки слова по словарям с уже одобренными словами.
                         if (elem1 == Dict1[k]) {                              //  Если проверяемое слово уже заменялось...
                                 count_911++;  mElem[n].innerHTML = Dict2[k];  //  то повторяем замену пользователя
                                 continue L911;                                     //  и переходим к следующему узлу <LABEL>.
                                 }
                         if (elem1 == Dict2[k])       //  Если проверяемое слово есть среди правильных слов...
                                 continue L911;            //  то переходим к следующему узлу <LABEL>.
                         }
                 for (k=0; k<count_Dict3; k++)   //  Запускаем цикл для проверки слова по словарю с пропущенными словами.
                         if (elem1 == Dict3[k])      //  Если слово ужа пропускалось...
                                 continue L911;       //  и переходим к следующему узлу <LABEL>.
                 elem2=elem1;
                 if (elem2.search(new RegExp("^["+RO+neRO+"1]+$", "g"))>=0)   //  Если "1" найдена среди римских чисел...
                         elem2=elem2.replace(/1/g,"I");                                          //  то заменяем её на "I" (и).  Иначе она в дальнейшем заменится на "l" (эл).
                 if (elem2.search("1")>=0)       //  Если "1" сохранилась...
                         continue L911;            //  то переходим к следующему узлу <LABEL>.
                 for (k=0; k<length_LAFull; k++)                              //  Запускаем внутренний цикл для замены букв, в котором...
                         if (elem2.search(mLAFull[0][k])>=0)                       //  если будет найдена очередная заменяемая буква из массива...
                                 elem2=elem2.replace(new RegExp(mLAFull[0][k],"g"), mLAFull[1][k]);    //  то заменяем её на соответствующую латинскую.
                 if (s.length<50000)                  //   Если проверяемая строка нормальной длины...
                         GoTo_0(mElem[n]);               // то переходим на узел <LABEL>.
                 msgTitle = " •  Ручное восстановление латинских слов  /"+(j+1)+"-я строка из "+length911+"/";  // Создаем заголовок окна,
                 msg = "•   Найдено слово:	" + elem1 + "\n◊  Заменить все красные символы на латинские буквы?";  //  текст в окне
                 LABELstyle(mElem[n]);                          // Добавляем стиль слова (фон, цвет и размер шрифта),
                 mElem[n].style.border = "2px solid #0053A0";    //  синюю рамку.
                 for (k=0; k<length_LAFull; k++)                              //  Запускаем внутренний цикл для поиска букв, в котором...
                         if (mElem[n].innerHTML.search(mLAFull[0][k])>=0)    //  для каждой найденной заменяемой буквы, изменяем ее цвет.
                                 mElem[n].innerHTML=mElem[n].innerHTML.replace(new RegExp("("+mLAFull[0][k]+")(?=[^>]{0,}(<|$))","g"), '<FONT style="color: #A00000">$1</FONT>');
                 T_pause -= new Date().getTime();
                 otvet_txt = window.external.InputBox(msg, msgTitle, elem2);       //  Выводим на экран диалоговое окно, и сохраняем введенный текст.
                 T_pause += new Date().getTime();
                 LABELstyleOf(mElem[n]);                                    //  Удаляем стиль слова.
                 otvet = window.external.GetModalResult();    //  Получаем код нажатой кнопки на диалоговом окне.
                 if (otvet == 2) {    //  Если была нажата кнопка "Отмена"...
                         otmena = true;   //  то отмечаем это на индикаторе
                         break;        //  и прерываем цикл для проверки отдельных слов.
                         }
                 count_911 += HandleOtvet();   //  Запускаем функцию для обработки ответа, и увеличиваем (или не увеличиваем) счетчик замен.
                 }
         for (n=mElem.length-1; n>=0; n--)    //  После обработки всех ошибочных слов в одной строке, запускаем цикл, в котором...
                 mElem[n].removeNode(false);      //  удаляем все форматы <LABEL> с остатками стиля.
         if (s != ptr.innerHTML  &&  ! mChangeP[m911_num[j]]) {    //  Если строка изменена и до этого не изменялась...
                 count_all++;                                               //  то увеличиваем счетчик изменений строк
                 mChangeP[m911_num[j]] = true;   //  и включаем индикатор изменения для этой строки.
                 }
         }


         // Транслитерация пропущенных греческих слов

 otmena = false;
 count_Dict1=0;
 count_Dict3=0;

 var length921=m921.length;    //  Длина массива с найденными строками.

// повтор // var re921 = new RegExp("(^|[^"+LA+RU+EL+"0-9])(["+EL+neELfull+"]{0,}(["+EL_+"]"+ud+"{0,1}["+neELfull+"]|["+neELfull+"]"+ud+"{0,1}["+EL_+"])["+EL+neELfull+"]{0,})(?=[^"+LA+RU+EL+"0-9>][^>]{0,}(<|$)|<|$)","g");
 var re921_LABEL = "$1<LABEL>$2</LABEL>";     //  Обрамление тегами   фрагмента с ошибкой.
 var re922 = new RegExp("^["+EL+neELfull+"]{0,}(["+EL_+"]"+ud+"{0,1}["+neELfull+"]|["+neELfull+"]"+ud+"{0,1}["+EL_+"])["+EL+neELfull+"]{0,}$","g");  //  Дополнительная проверка.
 otmena = false;           //  Индикатор нажатой кнопки "Отмена".
 var count_921 = 0;    //  Счетчик замен.

 //  Заменяемые символы.
 var mELFull  = [ ["[АA]", "[ВB]", "Г", "[ЕE]", "[НH]", "[КK]", "к", "[МM]", "[ОO0]", "[оo]", "П", "[РP]", "[рp]", "[ТT]", "Ф", "[ХX]", "Z", "I", "N"],
                                   [ "Α",        "Β",     "Γ",   "Ε",        "Η",       "Κ",      "κ",   "Μ",         "Ο",          "ο",     "Π",   "Ρ",       "ρ",        "Τ",     "Φ",   "Χ",     "Ζ", "Ι", "Ν"] ];
 var length_ELFull = mELFull[0].length;    //   Длина первой части этого массива.

 for (j=0;  j<length921;  j++) {   //  Запускаем основной цикл для проверки всех найденных строк.
         if (otmena)  break;            //  Если была нажата кнопка "Отмена"  -  выходим из цикла.
         ptr=m921[j];                     // Получаем одну из найденных ранее строк
         s=ptr.innerHTML;           //  и содержимое этой строки.
         ptr.innerHTML=s.replace(re921, re921_LABEL);   //  Обрамляем слово с ошибкой тегами <LABEL>
         mElem=ptr.getElementsByTagName("LABEL");       //  и получаем все узлы <LABEL> в строке.
L921:
         for (n=0; n<mElem.length; n++) {     //  Запускаем цикл для проверки отдельных слов.
                 elem1 = mElem[n].innerHTML;         //  Получаем содержимое узла <LABEL>.
                 if (elem1.search(re922)==-1)     //  Если внутри этого узла нет ошибочного слова...
                         continue;                              //  то переходим к следующему узлу <LABEL>.
                 for (k=0; k<count_Dict1; k++) {           //  Запускаем цикл для проверки слова по словарям с уже одобренными словами.
                         if (elem1 == Dict1[k]) {                              //  Если проверяемое слово уже заменялось...
                                 count_921++;  mElem[n].innerHTML = Dict2[k];  //  то повторяем замену пользователя
                                 continue L921;                                     //  и переходим к следующему узлу <LABEL>.
                                 }
                         if (elem1 == Dict2[k])       //  Если проверяемое слово есть среди правильных слов...
                                 continue L921;            //  то переходим к следующему узлу <LABEL>.
                         }
                 for (k=0; k<count_Dict3; k++)   //  Запускаем цикл для проверки слова по словарю с пропущенными словами.
                         if (elem1 == Dict3[k])      //  Если слово ужа пропускалось...
                                 continue L921;       //  и переходим к следующему узлу <LABEL>.
                 elem2=elem1;
                 for (k=0; k<length_ELFull; k++)                              //  Запускаем внутренний цикл для замены букв, в котором...
                         if (elem2.search(mELFull[0][k])>=0)                       //  если будет найдена очередная заменяемая буква из массива...
                                 elem2=elem2.replace(new RegExp(mELFull[0][k],"g"), mELFull[1][k]);    //  то заменяем её на соответствующую греческую.
                 if (s.length<50000)                  //   Если проверяемая строка нормальной длины...
                         GoTo_0(mElem[n]);               // то переходим на узел <LABEL>.
                 msgTitle = " •  Ручное восстановление греческих слов  /"+(j+1)+"-я строка из "+length921+"/";  // Создаем заголовок окна,
                 msg = "•   Найдено слово:	" + elem1 + "\n◊  Заменить все красные символы на греческие буквы?";  //  текст в окне
                 LABELstyle(mElem[n]);                          // Добавляем стиль слова (фон, цвет и размер шрифта),
                 mElem[n].style.border = "2px solid #66009E";    //  фиолетовую рамку.
                 for (k=0; k<length_ELFull; k++)                              //  Запускаем внутренний цикл для поиска букв, в котором...
                         if (mElem[n].innerHTML.search(mELFull[0][k])>=0)    //  для каждой найденной заменяемой буквы, изменяем ее цвет.
                                 mElem[n].innerHTML=mElem[n].innerHTML.replace(new RegExp("("+mELFull[0][k]+")(?=[^>]{0,}(<|$))","g"), '<FONT style="color: #A00000">$1</FONT>');
                 T_pause -= new Date().getTime();
                 otvet_txt = window.external.InputBox(msg, msgTitle, elem2);       //  Выводим на экран диалоговое окно, и сохраняем введенный текст.
                 T_pause += new Date().getTime();
                 LABELstyleOf(mElem[n]);                                    //  Удаляем стиль слова.
                 otvet = window.external.GetModalResult();    //  Получаем код нажатой кнопки на диалоговом окне.
                 if (otvet == 2) {    //  Если была нажата кнопка "Отмена"...
                         otmena = true;   //  то отмечаем это на индикаторе
                         break;        //  и прерываем цикл для проверки отдельных слов.
                         }
                 count_921 += HandleOtvet();   //  Запускаем функцию для обработки ответа, и увеличиваем (или не увеличиваем) счетчик замен.
                 }
         for (n=mElem.length-1; n>=0; n--)    //  После обработки всех ошибочных слов в одной строке, запускаем цикл, в котором...
                 mElem[n].removeNode(false);      //  удаляем все форматы <LABEL> с остатками стиля.
         if (s != ptr.innerHTML  &&  ! mChangeP[m921_num[j]]) {    //  Если строка изменена и до этого не изменялась...
                 count_all++;                                               //  то увеличиваем счетчик изменений строк
                 mChangeP[m921_num[j]] = true;   //  и включаем индикатор изменения для этой строки.
                 }
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 ///  ПОВЫШЕНИЕ ВЕРСИИ ФАЙЛА И ЗАПИСЬ В ИСТОРИЮ ИЗМЕНЕНИЙ
                 //  (применение функции "HistoryChange")

 var versionFile=document.getElementById("diVersion").value; //  Извлечение значения версии файла.
 var newVersion = versionFile;                                                          //  Значение новой версии.

 var HiCh=0;                     //  Код изменения истории.
 var VersionUp=false;   //  Индикатор повышения версии.

//  Если включено автоматическое повышение версии, а также если есть измененные строки или разрешено повышение версии когда нет изменений...
 if (Version_on_off == 1  &&  (count_all  ||  Vsegda_on_off == 1))
         HistoryChange(ScriptName + " " + NumerusVersion, youName);   //  запускаем функцию для изменения данных истории.

// ---------------------------------------------------------------

 window.external.EndUndoUnit(document);    // Конец записи в систему отмен.

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// СОЗДАНИЕ СПИСКА ЦИТАТ

//  Из книги "Пословицы и поговорки Великой Отечественной войны"
//  (составитель Павел Федорович Лебедев)

 var Kn=[ "Одна у человека мать, одна у него и Родина.",   "Родина любимая – мать родимая.",   "Родина – мать, умей за нее постоять.",   "Где ни жить – Родине служить.",   "С Родиной разлука – одна мука.",   "Всякому мила своя сторона.",   "Своя земля и в горсти мила.",   "На чужой стороне и весна не красна.",   "Где кто родится, там и пригодится.",   "На чужбине родная землица во сне снится.",   "На своей стороне мило, на чужой – постыло.",   "На чужой стороне и сокола зовут вороною.",   "Всякая сосна своему лесу весть подает.",   "Родная страна – колыбель, чужая – дырявое корыто.",   "На солнце тепло, на родине добро.",   "Человек без Родины что соловей без песни.",   "Глупа та птица, которой свое гнездо не мило.",   "Кукушка кукует – по бездомью горюет.",   "Расставшийся с другом плачет семь лет, расставшийся с Родиной – всю жизнь.",   "Нет ничего на свете краше, чем Родина наша.",   "Нашей страны шире не найти в мире.",   "Русское раздолье – человеку приволье.",   "Богата русская земля – говорится не зря.",   "Я тобой горжусь, милая Русь.",   "Человек без Родины что солдат без оружия.",   "Счастье Родины дороже жизни.",   "Береги страну как зеницу ока.",   "Может, и голову сложу, а Родине послужу.",   "Нам Отчизна дорога, охраняем родные берега.",   "Пусть знает ворог: нам край свой дорог.",   "Кто любовь к Отчизне имеет, тот врага одолеет.",   "Мы бережем свою Родину-мать, за нее мы готовы жизнь отдать.",   "С нами родная земля, нам светят звезды Кремля.",   "Великие победы нас ждут впереди под лучами красной звезды.",   "Красная звезда светит всегда.",   "Теперь все дороги ведут в Москву.",   "Москва от глаз далека, да сердцу близка.",   "Москва – наша столица, Москвой народ гордится.",   "Москва – всем столицам голова.",   "Москва – столица, любо подивиться.",   "У русской столицы не видать границы.",   "По Москве ходить – глаз с нее не сводить.",   "Москва – Родины украшенье, врагам устрашение.",   "Кремль тем и красен, что с народом согласен.",   "Наша страна дружбой сильна.",   "У нас все народы живут в ладу – врагам на беду.",   "Солнце не померкнет над нами, братство – наша сила и знамя.",   "Народное братство дороже всякого богатства.",   "Если дружба велика, будет Родина крепка.",   "Дружбу нашу не разделят просторы, моря и горы.",   "Страна растет – врагов метет.",   "Не тот человек, кто для себя живет, а тот человек, кто народу силы отдает.",   "За Родину и народ иду вперед.",   "Человек без народа что дерево без плода.",   "Чтобы с врагами биться, надо всем сплотиться.",   "Не трудно врагов победить, если всем заодно быть.",   "Наш народ сплочен и един, он непобедим.",   "Кто на нас нападает, тот в могилу попадает.",   "Россия с давних пор давала врагу отпор.",   "Никогда Россия ярма не носила.",   "За наше Отечество все человечество.",   "Не летать фашистским стаям над нашим краем.",   "Мы не боимся свинцовой тучи: наши полки могучи.",   "Кто на Советский Союз покушается, тот после раскается.",   "Бей фашистов не в бровь, а в глаз – таков народа наказ.",   "Любовь к народу, ненависть к врагу – душа победы.",   "От Родины награда – сердцу отрада.",   "Отчизна родная – для нас святая.",   "Знает свет: тверже русских нет.",   "Наш народ – герой, ходит на врага стеной.",   "Сыновья русских матерей славятся удалью богатырей.",   "Наша страна героями славится.",   "Кто за Родину горой – тот истинный герой.",   "Без патриотизма не разбить фашизма.",   "Защищай Советскую державу, бей фашистскую ораву.",   "Фашистам смерть неси – не опозорь Руси.",   "Даю Родине слово: мстить фашистам сурово.",   "Во имя Отчизны своей где фашиста увидел – бей.",   "За народное дело бейся смело.",   "Для Родины своей ни сил, ни жизни не жалей.",   "Жизнь отдам, а Родину не продам.",   "С родной земли – умри не сходи.",   "За Родину-мать не страшно умирать.",   "За Родину жизни не пощадим, но врагу ничего не отдадим.",   "Кому нашей земли захочется, тот под ней скорчится.",   "Родину любить – фашистов бить.",   "Бей фашистский сброд – за Родину, за народ.",   "Родину любить – верно Родине служить.",   "Родину беречь – врагов сечь.",   "Для нас война не страх – развеем врага в прах.",   "Гитлер пришел к нам незваным, а уйдет от нас драным.",   "Не придется Гитлеру из Ленинграда сделать море, а из Москвы – поле.",   "Думал Гитлер нашими землями управлять, а придется ему подыхать.",   "Штык советский молодец – скоро Гитлеру конец.",   "У Гитлера не столько расчетов, сколько просчетов.",   "Гитлер предполагает, а Красная Армия располагает.",   "Посмотрим, как Гитлер завоет, когда наши огонь по Берлину откроют.",   "Раздавим Гитлера в блин, как придем в Берлин.",   "Гитлеру-палачу местью отплачу.",   "Пора с Гитлером кончать – хватит ему рычать.",   "Гитлер и его правительство ответят за грабительство.",   "Гитлер кричит, мы весь свет разрушим, а мы Гитлера наперед задушим.",   "Сколько Гитлер ни крути, а от петли не уйти.",   "Гитлер победами хвалится, да в могилу свалится.",   "Хотел Гитлер Россию съесть, да пришлось в лужу сесть.",   "Не довелось свинье на небо дивиться, а Гитлеру в нашем огороде рыться.",   "Медведя знают по когтям, а Геббельса по лживым речам.",   "Фашистские собаки сочиняют враки.",   "Фашист брехней живет.",   "Солдаты у Гитлера вшивы, сводки у Геббельса лживы.",   "От осины не жди ягоды, от фашиста – правды.",   "Геббельс вертит языком без меры, да нет ему веры.",   "Геббельс мелет, да никто ему не верит.",   "Германия вот-вот развалится, а Геббельс все хвалится.",   "Германия пылает, а Геббельс все лает.",   "Врет, как фашистский бюллетень.",   "Как Геббельс ни врет, а наша берет.",   "Против фашистской лжи ухо востро держи.",   "Фашистские оковы всей Европе знакомы.",   "Лучше волку в зубы, чем фашистам в руки.",   "Фашист гладок, да вид его гадок.",   "Фашист от когтей до носа похож на барбоса.",   "Фашист и сатана – сущность одна.",   "Не ищи в фашисте человека – не найдешь.",   "Легче шакала превратить в голубя, чем фашиста в человека.",   "Фашистов легче убить, чем вразумить.",   "Фашистская власть – грабить и красть.",   "У фашистов особый спорт: кто больше добра сопрет.",   "Видно птицу по полету, а фашиста – по грабежам.",   "Сколько фашисту ни воровать, а виселицы не миновать.",   "Для предателя сгори хоть целый свет, лишь бы он был согрет.",   "Змея один раз в год меняет кожу, а предатель – каждый день.",   "Предатель фашисту пятки лизал, а фашист и спасибо не сказал.",   "У предателя ни Родины, ни друзей.",   "Лучше глаза лишиться, чем доброго имени.",   "Героям – слава, предателям – смерть.",   "Слава греет, позор жжет.",   "Бесчестье хуже смерти.",   "Кто с врагами пьет и гуляет, того и земля не принимает.",   "Думал фриц нашим богатством нажиться, да пришлось в могилу ложиться.",   "Не видать свинье неба, а фашистам нашего хлеба.",   "Кого к столу приглашают, а в фашиста пулю сажают.",   "Кому чарка, кому две, а фашисту – камнем по голове.",   "Угостили фашистов не водкой, а прямой наводкой.",   "Врага не уговаривай: с ним штыком разговаривай.",   "Убил фашистского гада – душа рада.",   "Съели бы фашисты русского мужика, да кишка тонка.",   "Одного фашиста убить – сто детей спасти.",   "Фашиста убить что змею: сто грехов простится.",   "Лучше смерть на поле, чем позор в неволе.",   "Чем позор и неволю терпеть, лучше в бою умереть.",   "Лучше биться орлом, чем жить зайцем.",   "Никогда фашистам не властвовать над нами, никогда не будем рабами.",   "Лучше злая пуля, чем клеймо раба.",   "Славная смерть лучше постыдной жизни.",   "Воевать – не галушки жевать.",   "Не воевать – победы не видать.",   "Слабого огонь войны испепеляет, а сильного как сталь закаляет.",   "Кто за правое дело дерется, у того двойная сила берется.",   "Наше дело правое – бей врага браво.",   "Бей фашистских властей всех мастей.",   "С какой злостью превеликой мы расправимся с фашистской кликой.",   "С врагами биться – на пули не скупиться.",   "Винтовка хлоп – и фашист в гроб.",   "Пришел фашист из Берлина – получил земли три аршина.",   "Не важно, чем бил, – важно, что фашиста убил.",   "Каждой фашистской гадине висеть на перекладине.",   "Всякому свой путь: журавлю – в небо, волку – в лес, а фашисту – в могилу.",   "Упрямого выправит дубина, а фашиста – могила.",   "Какую яму фашист копал – в такую и попал.",   "Фашисты научились воровать, а мы научились фашистов убивать.",   "Наш порог не для фашистских сапог.",   "Фашиста согнем в бараний рог, чтоб не переступал наш порог.",   "Лося бьют в осень, а фашиста всегда.",   "Наше дело святое и правое, мы расправимся с фашистскою оравою.",   "С фашистом разговор короткий: круши его прямой наводкой.",   "Кричал фашист «гоп», да получил пулю в лоб.",   "Фашиста умертвить – доброе дело сотворить.",   "На фронте воевать – славу добывать.",   "Фронт гремит – у врага земля горит.",   "Гремят вспышки на горизонте: то бьют фашистов на фронте.",   "Фашистов разгромили – и в селе порядок водворили.",   "Фашист замахнулся, да промахнулся.",   "Дрался фашист пылко, да остался без затылка.",   "Фашисты козыряли, да головы потеряли.",   "Фашисты пять раз на дню попадают в западню.",   "У фашистов брожение: попали в окружение.",   "Фашистам не все напирать – пришлось и умирать.",   "Трави фашистскую силу – огнем и штыком загоняй в могилу.",   "Чокнемся, фашист, я парень не гордый: я – прикладом, а ты – мордой.",   "На то у винтовок и ложи, чтобы бить фашиста по роже.",   "Слава русского штыка не померкнет века.",   "Штык остёр загнал фрицев в «котел».",   "Наши штыки разгромят фашистские полки.",   "Фашисты войну начали, а мы кончим.",   "Славу свою добывай в бою.",   "Почет и славу собирают по капле.",   "Народ того уважает, кто фашистов уничтожает.",   "На то мы и внуки Суворова, чтобы сражаться здорово.",   "Как учил Александр Суворов – будь к врагу суровым.",   "На краю света фашистов найдем и на суд приведем.",   "Зря фашист блиндажи строит: все равно снаряд накроет.",   "Смерть фашистской своре – на берегу и в море!",   "Солдата мать родит, отец растит, а бой учит.",   "Дерево в огне сгорает, а солдат от огня крепче бывает.",   "Кто первый бой начинает, тот скорее побеждает.",   "Пришла пора гнать фашистов со двора.",   "Фашист наступает – кричит «гут», а отступает – «Гитлер капут».",   "Красна девушка косами, солдат – орденами.",   "Ученый водит, а неуч сзади ходит.",   "Птицу обманывают кормом, а человека – словом.",   "Слово, сказанное без соображения, подобно выстрелу без прицела.",   "Говорить впустую что стрелять вхолостую.",   "У осла длинные уши, а у болтуна длинный язык.",   "У короткого ума длинный язык.",   "Слово не воробей: выпустишь – не поймаешь.",   "Скажешь – не воротишь, напишешь – не сотрешь, отрубишь – не приставишь.",   "Лучше один раз увидеть, чем сто раз услышать.",   "Острый язык – дарование, длинный язык – наказание.",   "Не всегда говори то, что знаешь, но всегда знай, что говоришь.",   "Кто много болтает, тот врагу помогает.",   "Кто зевает – победителем не бывает.",   "Храбрость города берет, а бдительность их бережет.",   "Зря не болтай у телефона: болтун – находка для шпиона.",   "Нет друга – так ищи, а найдешь – береги.",   "Ищи себе друзей таких, чтобы не было стыда от них.",   "Не ходи, дружок, в неизвестный кружок: к таким людям зайдешь, что навек пропадешь.",   "Плохой друг подобен тени: только в светлые дни его и видишь.",   "Не та дружба сильна, что в словах заключена, а та, что в бою скреплена.",   "Для друзей – пироги, для врагов – кулаки.",   "В недруге пуля что во пне, а в друге что во мне.",   "Все за одного, один за всех – вот и обеспечен в бою успех.",   "Не имей сто рублей, а имей сто друзей.",   "В дружбе – правда.",   "Кто нашел друга – нашел сокровище.",   "Сам пропадай, а товарища выручай.",   "Один в поле не воин, а вдвоем с товарищем – взвод.",   "Где дружба и лад – там и клад.",   "Где дружба и совет – там и свет.",   "Трусливый друг опаснее врага, ибо врага опасаешься, а на друга опираешься.",   "Не тот друг, кто медом мажет, а тот, кто правду скажет.",   "Недруг поддакивает, а друг спорит.",   "Дружба крепка не лестью, а правдой и честью.",   "Новых друзей наживай, а старых не забывай.",   "Прямо страху в глаза смотри – и страх смигнет.",   "Волков бояться – в лес не ходить.",   "Трус умирает тысячу раз, а смелый всего один раз.",   "Советские воины из металла скроены.",   "Чем больше героев, тем скорее фашистов зароем.",   "Храбрость – сестра победы.",   "На смелого собака лает, а трусливого – рвет.",   "Не числом, а храбростью побеждают.",   "Лучше быть мертвым героем, чем живым трусом.",   "Смелого и пуля облетит, смелый и мину перехитрит.",   "Если не будешь овцой, то волк не съест.",   "Косил Гитлер глаз на Донбасс, а Донбасс опять у нас.",   "И про солдатскую честь пословица есть.",   "Потому и смешно, что фашистам горе пришло.",   "Гитлеровским сателлитам быть разбитым.",   "Знаем, за что бьем, потому и с победой придем.",   "Кто за правое дело стоит, тот всегда победит.",   "У правого сила удвоится, говорит пословица.",   "Будет праздник и на улице нашей, всякого праздника краше.",   "Войну закончим – и мир упрочим.",   "Как фашисты нам ни грозили, а мы их сразили.",   "Фашистов разгромили – добро сотворили.",   "Хотел Гитлер покорить весь мир, да лопнул как мыльный пузырь.",   "Задохнулась фашистская стая девятого мая.",   "Разбили фашистскую орду в сорок пятом году.",   "Прогнали фрицев – можно веселиться.",   "Советская Армия врага разгромила, она стоит на страже мира.",   "Курские леса и дубравы полны легендарной славы.",   "Виден в курских лесах боевой размах.",   "Защитим курские дубравы от фашистской оравы!",   "В курских городах разбили фашистов в прах.",   "Как фашисты ни рвались к Курску – не дали им спуску.",   "Бей врага, Суджа, зарывай глубже." ];

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОКНО РЕЗУЛЬТАТОВ  :  Текущее время и дата

 var currentFullDate = new Date();

 var currentHours = currentFullDate.getHours();
 var currentMinutes = currentFullDate.getMinutes();
 var currentSeconds = currentFullDate.getSeconds();

 if (currentMinutes<10) currentMinutes = "0" + currentMinutes;
 if (currentSeconds<10) currentSeconds = "0" + currentSeconds;

 var currentDay = currentFullDate.getDate();
 var currentMonth = 1+currentFullDate.getMonth();
 var currentYear = currentFullDate.getFullYear();

 if (currentMonth<10) currentMonth = "0" + currentMonth;
currentYear = (currentYear+"").replace(/^.*?(\d{1,2})$/g, "$1");

 var currentTime = currentHours + ":" + currentMinutes + ":" + currentSeconds;
 var currentDate = currentDay + "." + currentMonth + "." + currentYear;

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОКНО РЕЗУЛЬТАТОВ  :  Демонстрационный режим "Показать все строки"

 var VseStroki_on_off = 0;      // 0 ; 1 //      ("0" — отключить, "1" — включить)

 var d=0;
 if (VseStroki_on_off == 1)  d="показать нули";

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОКНО РЕЗУЛЬТАТОВ  :  Сборка массива с результатами обработки

 var Tf=new Date().getTime();
 var mSt=[];
 var ind=0;

                 mSt[ind]=" "+ScriptName+" v."+NumerusVersion;  ind++;
                 mSt[ind]="-------------------------------------------------------";  ind++;
 if (d)  { mSt[ind]=" Демонстрационный режим";  ind++ }
                 mSt[ind]="					   ";  ind++;

                                         mSt[ind]="• СТАТИСТИКА:";  ind++;
                                         mSt[ind]="Вычисления  .  .  .  .  .  .  .  .  .  .  .  .	"+time(Tf - Ts - T_pause);  ind++;
 if (T_pause!=d)       { mSt[ind]="Диалоговые паузы .  .  .  .  .  .  .  .  .	"+time(T_pause);  ind++; }
                                         mSt[ind]="Проверено строк .  .  .  .  .  .  .  .  .  .	"+count_P;  ind++;
 if (count_all!=d)     { mSt[ind]="Исправлено строк  .  .  .  .  .  .  .  .  .	"+count_all;  ind++; }
 if (count_all==0 || d)  { mSt[ind]="";  ind++;
                                         mSt[ind]="   >> Исправлений нет";  ind++; }

var cTaT=ind;  //  число строк в первом разделе

                                         mSt[ind]="";  ind++;
                                         mSt[ind]="• ВОССТАНОВЛЕНЫ:";  ind++;
 if (count_101!=d)   { mSt[ind]="Русские слова  .  .  .  .  .  .  .  .  .  .  .	"+count_101;  ind++ }
 if (count_501!=d)  { mSt[ind]="Русские предлоги  .  .  .  .  .  .  .  .  .	"+count_501;  ind++ }
 if (count_201!=d)  { mSt[ind]="Русские буквы: из цифр  .  .  .  .  .  .	"+count_201;  ind++ }
 if (count_301!=d)  { mSt[ind]="Латинские слова .  .  .  .  .  .  .  .  .  .	"+count_301;  ind++ }
 if (count_401!=d)  { mSt[ind]="Греческие слова .  .  .  .  .  .  .  .  .  .	"+count_401;  ind++ }
 if (count_001!=d)  { mSt[ind]="Римские числа  .  .  .  .  .  .  .  .  .  .  .	"+count_001;  ind++ }
 if (count_901!=d)  { mSt[ind]="Русские слова: ручная правка  .  .  .	"+count_901;  ind++ }
 if (count_911!=d)  { mSt[ind]="Латинские слова: ручная правка	"+count_911;  ind++ }
 if (count_921!=d)  { mSt[ind]="Греческие слова: ручная правка	"+count_921;  ind++ }

 if (cTaT==ind-2)  ind=ind-2;   //  Если нет пунктов с исправлениями - удаление двух последних строк.

//  История
 if (VersionUp ||  HiCh  ||  d)  { mSt[ind]="";  ind++ }
 if (VersionUp  ||  d)                 { mSt[ind]="• Версия файла:  "+versionFile+"  ›››  "+newVersion;  ind++ }
 if (HiCh==1  ||  d)                    { mSt[ind]="• Добавлена новая строка в историю";  ind++ }
 if (HiCh==2  ||  d)                    { mSt[ind]="• Добавлены две строки в историю";  ind++ }
 if (HiCh==3  ||  d)                    { mSt[ind]="• Изменены данные в строке истории";  ind++ }

//  Сборка строк текущей даты и времени
 mSt[ind]="";  ind++;
 mSt[ind]= "• "+currentDate+" • "+currentTime+" •";  ind++;

//  Сборка строк пословицы
 mSt[ind]="";  ind++;
 mSt[ind]="-------------------------------------------------------";  ind++;
 var reZit = new RegExp("([^ ].{0,43})(?=\\\s\\\s.{0,}|$)","g");   // Рег. выражение для разделения цитаты на строки.
 mSt=mSt.concat(Kn[Rn_(Kn.length)].replace(/ /g, "  ").match(reZit));   //  Добавление массива строк цитаты в основной массив.
 for (j=mSt.length-1; j>=ind; j--)  mSt[j]=" "+mSt[j];   //  Добавление отступа.
// for (j=mSt.length-1; j>=ind; j--)  { mSt.splice(j+1, 0, ""+mSt[j].length) }   //  Добавление длины строк цитаты (отключено).
 ind = mSt.length;    //  Определение индекса.

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОКНО РЕЗУЛЬТАТОВ  :  Вывод окна результатов на экран

 var st2="";   //  Текст результатов.

 for  ( n=0; n<ind; n++ )
        st2 += mSt[n]+"\n";   //  Добавление элемента из массива.

 MsgBox (st2);   //  Вывод окна результатов.

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------

}






                 ///  ИСТОРИЯ ИЗМЕНЕНИЙ

//======================================
// v.1.0 — Александр Ка (01.06.2024)
// Создание скрипта
// * В скрипте частично использовались некоторые алгоритмы из скрипта "03_Латиница в Кириллице.js", v.1.2
//======================================
// v.1.1 — Александр Ка (10.07.2024)
// Понижение значения букв "I", "i" в латинском алфавите.
// Добавка букв "Ѣ", "ѣ", "Ѳ", "ѳ" в русский алфавит (это не оказывает никакого влияния на работу с современным русским текстом, но позволяет лучше обрабатывать вставки в старом стиле).
//======================================
// v.1.2 — Александр Ка (11.01.2025)
// Расширена "Латинизация римских чисел": Добавлена обработка отдельностоящих русских букв "Х"
// Расширена "Кириллизация цифр": Добавлена обработка цифры "0"
// Удалены структурные операции (есть в скрипте "Чистка структуры")
// Замена основных циклов на более устойчивые к аномалиям
// Исправлены все ошибки в окнах для win7
//======================================
// v.1.3 — Александр Ка (17.04.2025)
// Добавлены 3 пары букв для замен латиница-кириллица
//  Добавлены греческие символы (62 шт.)
// Добавлены 16 пар букв для замен греческий-кириллица
// Добавлено восстановление греческих слов
// Добавлена замена греческих букв в римских числах
// Латинский алфавит расширен на 63 символа
// Добавлен ещё один частный случай замены отдельностоящей буквы "Х" на римскую цифру "X"
// Добавлена функция повышения версии файла и запись в историю изменений
// Расстановка ударений
// Улучшен алгоритм
//======================================
// v.1.4 — Александр Ка (23.04.2025)
// Добавлена полуавтоматическая обработка слов, пропущенных "автоматом"
// Добавлены пословицы
// Улучшен алгоритм
// Добавлена замена похожих букв "греческий-латиница"
// Греческие символы расширены до 70 символов
// Добавлена замена отдельностоящей греческой буквы "Ι" в римскую цифру "I"
// Понижено значение всех латинских букв, которые похожи на буквы дополнительной кириллицы
// Добавлена замена "u" на "и" в "предлогах"
// Добавлена замена греческой "ό" на русскую "о" с ударением
// Замена цифры "6" на русскую букву "б" перенесена в "ручную правку"
//======================================
// v.1.5 — Александр Ка (25.04.2025)
// Добавлена замена цифры "2" на знак ударения (в ручной правке)
//======================================
// v.1.6 — Александр Ка (10.05.2025)
// Ручная правка латинских слов:   удалена пара "1"-"l" (эл);   добавлена пара "1"-"I" (и) - в римских числах.
//======================================







