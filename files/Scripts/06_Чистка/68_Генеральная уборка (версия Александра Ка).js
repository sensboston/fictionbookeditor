//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//             «Текст-корректор»
// Скрипт тестировался в FBE v.2.7.7 (win XP, IE8 и win 7, IE11)
// * История изменений в конце скрипта
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

function Run() {

 var ScriptName="«Текст-корректор»";
 var NumerusVersion="3.15";
 var Ts=new Date().getTime();

//--------------------------------------------------------------------
                 ///  НАСТРОЙКИ
//--------------------------------------------------------------------

         //   •  Максимум строк в окне результатов
//  * Скрипт постарается не превышать это значение, и при необходимости добавит необходимое количество страниц.

 var Vysota_teksta = 50;      // примерно 30-52 //      Ориентировочный максимум строк в окне результатов

// * Для монитора 1024х768 максимальная высота окна равна 52 строкам (в win XP) и 50 строк (в win 7).

// ---------------------------------------------------------------

         //   •  Обработка текста внутри "Истории изменений файла"

 var ObrabotkaHistory_on_off = 1;      // 0 ; 1 //      ("0" — отключить, "1" — включить)

// ---------------------------------------------------------------

         //   •  Автоматическое повышение версии файла и запись в историю изменений

 var Version_on_off = 0;      // 0 ; 1 //      ("0" — отключить, "1" — включить)

//  Добавлять, если не сделано ни одного исправления
 var Vsegda_on_off = 0;      // 0 ; 1 //      ("0" — отключить, "1" — включить)

//   Имя используемое в добавленной записи:
 var youName = "Зорро";

//  * Можно использовать почти любые символы. Исключения:   |  "  |  \  |    Но и любой из этих знаков можно добавить, если поставить перед ним наклонную черту ("\"), например: "\\" = "\"
//  ** Или можно оставить эти кавычки пустыми (""), тогда строка в истории будет без имени.

// ---------------------------------------------------------------

         //   •  Включить режим "Сохранение дефиса рядом с цифрой"
//   Включает сохранение дефиса внутри буквенно-цифровых кодов при повторной обработке.
//   * Чтобы скрипт смог распознать повторную обработку, в "истории изменений" должна остаться хотя бы одна запись сделанная этим скриптом (а именно — фрагмент текста "ГенУборка–" или "«Текст-корректор»").

 var SaveDef_on_off = 2;      // 0 ; 1 //      ("0" — отключить, "1" — включить, "2" — спрашивать)

// ---------------------------------------------------------------

         //  •  Выбор символа для апострофа  (№107)

 var Apostrof = 0;      // 0 ; 1 //      ("0" —  <'> <U+0027: Apostrophe>;  "1" —  <’> <U+2019: Ringht Single Quotation Mark> <Alt+0146>)

// * В современных fb2-книгах обычно используется символ <U+2019>.

// ---------------------------------------------------------------

         //  •  Заменять символы дробей (¼½¾⅓⅔⅕⅖⅗⅘⅙⅚⅛⅜⅝⅞) на запись с использованием тегов верхнего и нижнего индекса  (№110)

 var Drobi = 1;      // 0 ; 1 //      ("0" — заменять всё, кроме ¼, ½, ¾ ;  "1" — заменять всё)

// ---------------------------------------------------------------

         //  •  Заменять символы надстрочных цифр (¹²³⁴⁵⁶⁷⁸⁹ⁿ) на запись с использованием тегов верхнего индекса  (№111)

 var Nadstrochnye = 1;      // 0 ; 1 //      ("0" — заменять всё, кроме <²>, <³> ;  "1" — заменять всё)

// ---------------------------------------------------------------

          //   •  Закрепление висящих слов

//   Максимальное длина слова в конце АБЗАЦА, которое следует прикрепить к предыдущему слову

 var Abz1 = 2;      // 0 ; 1; 2 ; 3 //      ("0" — отключить)


//   Максимальное длина слова в конце ПРЕДЛОЖЕНИЯ, которое следует прикрепить к предыдущему слову

 var Abz2 = 1;      // 0 ; 1 ; 2 //      ("0" — отключить)


//   Прикреплять некоторые предлоги к следующему слову

 var Abz3 = 1;      // 0 ; 1 //      ("0" — отключить, "1" — включить)


//   Прикреплять однобуквенные слова в начале предложения к следующему слову

 var Abz4 = 0;      // 0 ; 1 //      ("0" — отключить, "1" — включить)

// ---------------------------------------------------------------

         //   •  Расставлять стандартное ударе́ние (&#769;) с помощью следующих операций:
//  220. выделЕние буквы с помощью тегов курсива/жирности ››› ударе́ние
//  911. выделЕние кАпсом  ›››  ударе́ние

 var Ud_on_off = 1;      // 0 ; 1 //      ("0" — отключить эти операции, "1" — включить)

// ---------------------------------------------------------------

       //   •  Особенности переоформления _подчеркивания_ (операции №155, 157)

 var _format_ = 1;      // 0 ; 1 ; 2 ; 3 //

 //  "0" — не трогать
 //  "1" — добавлять формат курсива
 //  "2" — добавлять формат жирности
 //  "3" — добавлять формат жирного курсива

// ---------------------------------------------------------------

       //   •  Особенности переоформления _п_о_д_ч_е_р_к_и_в_а_н_и_я_ (операция №156)

 var _f_o_r_m_a_t_ = 2;      // 0 ; 1 ; 2 ; 3 //

 //  "0" — не трогать
 //  "1" — добавлять формат курсива
 //  "2" — добавлять формат жирности
 //  "3" — добавлять формат жирного курсива

// ---------------------------------------------------------------

       //   •  Особенности переоформления для отдельной _буквы_ с подчеркиванием (операция №158)

 var _bukva_ = 4;      // 0 ; 1 ; 2 ; 3 ; 4 //

 //  "0" — не трогать
 //  "1" — добавлять формат курсива
 //  "2" — добавлять формат жирности
 //  "3" — добавлять формат жирного курсива
 //  "4" — автоматическое определение формата

// ---------------------------------------------------------------

       //   •  Особенности переоформления  р а з р я д к и  (операция №921)

 var formatRazrjadki = 1;      // 0 ; 1 ; 2 ; 3 //

 //  "0" — удалять разрядку, не добавляя формат жирности/курсива
 //  "1" — добавлять формат курсива
 //  "2" — добавлять формат жирности
 //  "3" — добавлять формат жирного курсива

// ---------------------------------------------------------------

       //   •  День рождения
//  Скрипт поздравит вас с Днем Рождения

 var DR = "29.12";      // "1.09" ; "30.11" и т.п. //      дата в указанном формате

//  * Пустые кавычки или неправильное заполнение отключают эту функцию

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОБРАБОТКА НАСТРОЕК

 if ((Abz1+"").search(/^[123]$/) == -1)  Abz1=0;
 if ((Abz2+"").search(/^[12]$/) == -1)  Abz2=0;
 if (Abz3 != 1)  Abz3 = 0;
 if (Abz4 != 1)  Abz4 = 0;
 var Abz5 = 1;
 if (Abz1 != 0) Abz5 = Abz1;
 var Abz6 = 1;  var Abz7 = 0;
 if (Abz2 < 2) { Abz6 = 0; Abz7 = 1 }
 var ObrabotkaHistory = (ObrabotkaHistory_on_off==1);
 if ((_format_+"").search(/^[123]$/) == -1)  _format_=0;
 if ((_f_o_r_m_a_t_+"").search(/^[123]$/) == -1)  _f_o_r_m_a_t_=0;
 if ((_bukva_+"").search(/^[1234]$/) == -1)  _bukva_=0;
 if ((formatRazrjadki+"").search(/^[123]$/) == -1)  formatRazrjadki=0;

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОБЩИЕ ПЕРЕМЕННЫЕ

//   Неразрывный пробел из настроек FBE
 var nbspEntity="&nbsp;";    //  Присваиваем переменной н/р пробела значение стандартного кода.
 try  {
         var nbspChar=window.external.GetNBSP();   //  Получаем выбранный символ неразрывного пробела.
         if (nbspChar.charCodeAt(0) != 160)   //  Если используется нестандартный символ...
                 nbspEntity = nbspChar;   //  то заменяем стандартный код на этот символ.
         }
 catch(e) {            //  Если команда для получения символа н/р пробела вызывает ошибку...
         var nbspChar=String.fromCharCode(160);   //  то используем стандартный символ н/р пробела
         }


var sIB="<EM><STRONG>|<STRONG><EM>|<EM>|<STRONG>";
var fIB="</EM></STRONG>|</STRONG></EM>|</EM>|</STRONG>";
var aIB="<EM><STRONG>|<STRONG><EM>|</EM></STRONG>|</STRONG></EM>|<EM>|<STRONG>|</EM>|</STRONG>";
// Сдвоенные теги должны стоять в начале. Иначе, если в конце рег. выражения стоит ("+_IB+"), то формула находит в тексте только первый тег, а если за ним следует второй тег, то он проигнорируется, и это может привести к ошибке.

var NC="<A href=[^>]{0,}?><SUP>\\\{\\\d{1,5}\\\}</SUP></A>|<A class=note [^<]{1,}?</A>";   //  Любая стандартная сноска (на примечание или на комментарий)

var FalseSim="&&0&"; // Заменитель текста для нескольких небольших эпизодов
var FalseCode="&&1&"; // Заменитель текста для формата <code>
var UrlFalse1="&&2&"; // Заменитель текста для активных ссылок
var UrlFalse3="u&&u"; // Заменитель текста для адреса текстом
var FalseTire="&&3&"; // Заменитель для длинного тире между названиями
var FalseDefis="&&4&"; // Заменитель для дефиса рядом с цифрой
// * Заменитель необходим для того чтобы сохранить текст от изменений
var Ud="́"; // Знак ударения (чтобы был заметным)

 //  Счетчики в циклах
 var n=0;
 var k=0;
 var j=0;
 var jj=0;

  var fbwBody=document.getElementById("fbw_body");

 var T_pause=0;  //  продолжительность диалоговых пауз

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 ///   Функция преобразования в код

 function inCode(text) {      //  Преобразование обычного текста в код.
         return  text.replace(/&/g, "&amp;").replace(/ /g, nbspEntity).replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/­/g, "&shy;");
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 ///  ФУНКЦИЯ ПОВЫШЕНИЯ ВЕРСИИ ФАЙЛА И ЗАПИСЬ В ИСТОРИЮ ИЗМЕНЕНИЙ

 function HistoryChange(Script_Name, youName) {


         // Получение раздела истории

// var fbwBody=document.getElementById("fbw_body");
// var History=fbwBody.firstChild;   //  Предполагаемый раздел истории.

// //  Поиск раздела "историй"
// while (History != null  &&  History.className != "history")    //  Пока не найдем настоящий раздел истории, или окажется, что истории нет в тексте...
//         History = History.nextSibling;         //  переходим на следующий раздел.
//  **  эти строки уже есть в скрипте  **

//  Добавление раздела истории
 if (History==null)  {                 //   Если нет истории...
         History = document.createElement("DIV");     //   Создание нового раздела
         var Annotation=fbwBody.firstChild;
         while (Annotation!=null  &&  Annotation.className!="annotation") Annotation=Annotation.nextSibling;   //  Поиск аннотации к книге
         if (Annotation!=null)  Annotation.insertAdjacentElement("afterEnd",History);      //  Размещаем новый раздел    или после аннотации (если она есть)...
                 else  fbwBody.insertAdjacentElement("afterBegin",History);                //  ...или в начале "fbwBody"
         History.className = "history";      //  Присваиваем новому разделу    класс "история" и необходимые атрибуты
         History.setAttribute("xmlns:l", xlNS);    //  "xlNS" и "fbNS" - переменные из "main.js"
         History.setAttribute("xmlns:f", fbNS);
         History.insertAdjacentElement("beforeEnd",document.createElement("P"));     //  Добавляем пустую строку
         window.external.inflateBlock(History.lastChild)=true;
         }


         //  Создание массива с прошедшими датами

 var mDate=[];         //  Массив с прошедшими датами.
 var D = new Date().getTime();   //  Начальное значение даты.
 var fullDate;
 var Day;
 var Month;
 var Year;

 for (var j=0; j<10; j++) {              //  Запускаем цикл для получения недавних дат, в котором...
         fullDate = new Date(D);                         //  получаем полную дату,
         Day = fullDate.getDate();                            //  день месяца,
         Month = ("0" + (1+fullDate.getMonth())).replace(/^.*?(\d\d)$/g, "$1");   //  месяц,
         Year = fullDate.getFullYear();       //  год,
         mDate[j] = Day + "." + Month + "." + Year;             //  и заполняем массив текстом очередной даты (Д.ММ.ГГ).
         D -= 86400000;                       //  При этом каждый раз уменьшаем проверяемую дату на один день.
         }


         //  Поиск недавней записи в "истории"

 var povtorD = false;   //  Индикатор повторной обработки в последние 10 дней.
 var mP = History.getElementsByTagName("P");   //  Получение всех строк в "Истории".
 var s="";               //  Содержимое строки.
 var k=0;               //  Счетчик цикла.

fff:
 for (j=mP.length-1;  j>=0;  j--) {    //  Последовательный просмотр строк истории.
         s = mP[j].innerHTML;                //  Содержимое строки.
         for (k=0; k<10; k++) {                //  и запускаем цикл для проверки даты.
                 if (s.search(mDate[k]) !=-1) {   //  Если проверяемая дата есть в строке истории...
                         povtorD = true;                    //  то отмечаем это,
                         break fff;                            //  и прерываем оба цикла проверки.
                         }
                 }
         }


         //  Обновление записи в истории изменений

 try  { youName = fbeUserName }   //  Если есть строка:   var fbeUserName = "Имя";   в файле "main.js"  --  Изменение имени в соответствии с глобальной переменной.
 catch(e)  {}                                            //  Если глобальная переменная отсутствует - пропуск операции по изменению имени.

 var textYouName = inCode(youName+"");    //  Имя в тексте.
 if (youName!="")                           //  Если есть заполненное имя...
         textYouName += ", ";   //  то добавляем к текстовой записи запятую.

 Script_Name = inCode(Script_Name);    //  Имя скрипта текстом.

 var reHist00s = new RegExp("[^А-яЁёA-Za-z0-9]"+Script_Name+"[^А-яЁёA-Za-z0-9]","");   //  Стартовая.
 //  Добавление точки с запятой
 var reHist01 = new RegExp("(.[^…\\\?!\\\.,;:—])(\\\s|"+nbspEntity+")(— "+textYouName+mDate[k]+")","");
 var reHist01_ = "$1; $3";
 //  Добавление точки
 var reHist02 = new RegExp("(.[^…\\\?!\\\.,;:—])[,;:]{0,1}(\\\s|"+nbspEntity+")(— "+textYouName+mDate[k]+")","");
 var reHist02_ = "$1. $3";
 //  Добавление слова "Скрипт"
 var reHist03 = new RegExp("(.)(\\\s|"+nbspEntity+")(— "+textYouName+mDate[k]+")","");
 var reHist03_ = "$1 Скрипт: $3";
 //  Добавление имени скрипта
 var reHist04 = new RegExp("(.)(\\\s|"+nbspEntity+")(— "+textYouName+mDate[k]+")","");
 var reHist04_ = "$1 "+Script_Name+" $3";

 if (povtorD) {                                         //  Если найдена запись с недавней датой...
         if (s.search(reHist04) !=-1) {    //  и если в строке имя пользователя и дата записаны по форме: "— (Имя, Дата)"...
                 if (s.search(reHist00s) ==-1) {    //  то проверяем строку на наличие записи имени скрипта, и если этой записи нет...
                         if (s.search(/([Сс]крипт):/) !=-1)  s = s.replace(/([Сс]крипт):/g, "$1ы:");   //  то заменяем при необходимости слово "Скрипт" на "Скрипты",
                         if (s.search(reHist01) !=-1)  s = s.replace(reHist01, reHist01_);                   //  добавляем при необходимости точку с запятой,
                         if (s.search(/[Сс]крипты?:/) ==-1)  s = s.replace(reHist02, reHist02_).replace(reHist03, reHist03_);   //  добавляем при необходимости слово "Скрипт"
                         s = s.replace(reHist04, reHist04_);      //  и добавляем имя скрипта.
                         }
                 if (k != 0)                                                    //  Затем проверяем дату, и если она не сегодняшняя...
                         s = s.replace(mDate[k], mDate[0]);   //  то заменяем на сегодняшнюю.
                 if (mP[j].innerHTML != s) {                //  Затем проверяем изменилась ли строка истории, и если она изменилась...
                         mP[j].innerHTML = s;          //  то сохраняем её в тексте
                         HiCh=3;   //  и отмечаем это на индикаторе.
                         }
                 }
             else                                  // Если же есть недавняя дата, но запись сделана не по форме...
                 povtorD = false;   //  Объявляем, что недавняя дата - посторонняя, и надо повышать версию и добавлять новую строку в историю.
         }

 if (povtorD)  return;   //  Если производилась обработка записи в истории - выход из функции.


         //  Повышение версии

 var versionText = "";           //  Текст с версией в истории изменений.

 //  Проверка на валидность версии файла
 var ValidationVersion=(versionFile.length <=10  &&  versionFile.search(/^\d{0,10}(\.\d{1,8})?$/g) !=-1);    //  сравнение с шаблоном:  "цифры + (точка + цифры)"

 //   Изменение версии файла
 if (ValidationVersion) {
         if (versionFile =="")          //  Если версия не заполнена...
                 versionFile = "1.0";    //  то изменяем начальную версию на "1.0".
         if (versionFile.search(/^\d+$/g) !=-1)   //  Если версия без точки...
                 newVersion = versionFile + ".1";     //  то для новой версии добавляем ".1".
             else {                                                                                         //  Если в версии есть точка...
                     newVersion = +versionFile.replace(/^\d+\./g, "");  //  извлекаем цифры после точки,
                     newVersion++;                                                                                           //  увеличиваем полученное число на единицу
                     newVersion = versionFile.replace(/\.\d+$/g, "")+"."+newVersion;   //   и добавляем к нему первую группу цифр.
                     }
         if (newVersion.length <=10)                                        //  Если новая версия валидна...
                 document.getElementById("diVersion").value=newVersion;   //  то изменяем версию в файле,
                 VersionUp=true;                                                          //  отмечаем это на индикаторе
                 var versionText="v."+newVersion+" — ";    //  и создаем текст для истории.
         }


         //   Добавление строк в историю изменений

 var reHist11 = new RegExp("^(\\\s|"+nbspEntity+"){0,}$","");   //  Признак пустой строки.
 var reHist12 = new RegExp("(^|\\n)[^0-9]{0,12}"+versionFile.replace(/\./, "\\.")+"([^0-9]|$)","");   //  Поиск старой версии.

 //   Добавление строки с информацией о старой версии
 if (ValidationVersion  &&  History.innerText.search(reHist12)==-1) {       //  Если в истории нет записи о старой версии...
         if (History.lastChild.innerHTML.search(reHist11)==-1)                                               //  то проверяем наличие пустой строки в конце истории
                 History.insertAdjacentElement("beforeEnd",document.createElement("P"));       //  и если ее нет - добавляем новую.
         History.lastChild.innerHTML = "v."+versionFile+" — ?";  //  Затем добавляем в строку информацию о старой версии
         HiCh++;                                        //  и изменяем индикатор истории.
         }

 //   Добавление строки с информацией о новой версии
 if (History.lastChild.innerHTML.search(reHist11)==-1)                                   //  Если в конце истории нет готовой пустой строки...
         History.insertAdjacentElement("beforeEnd",document.createElement("P"));   //  то добавляем новую строку.
 History.lastChild.innerHTML = versionText+" Скрипт: "+Script_Name+" — "+textYouName+mDate[0];  //  Добавляем в строку информацию о новой версии.
 HiCh++;                       //  Изменяем индикатор истории.

 }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ФУНКЦИЯ "Генератор случайных чисел, с округлением"

 var T_random = Ts;   //  Показания времени для генератора случайных чисел.
 var rndN;

 function Rn_(rndN) {
         T_random += Math.random()*2000;                  //  Изменение ключевой переменной.
         return Math.floor(("0000000"+Math.tan(T_random)).replace(/[\.\-]/g, "").replace(/.+(\d\d\d\d\d\d)\d$/g, "0.$1")*rndN);  //  Генерация случайных чисел от 0 до "rndN".
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ФУНКЦИЯ ПЕРЕХОДА

// * В отличии от встроенной функции "GoTo", положение курсора не меняется, но есть прокрутка влево.

 function GoTo_0(elem) {
         var b=elem.getBoundingClientRect();                  //  Получение координат элемента.
         var c=fbwBody.parentNode.getBoundingClientRect();        //  Получение координат раздела <BODY>.
         if (b.bottom-b.top <= window.external.getViewHeight())                                                  //  Если высота элемента меньше высоты окна...
                 window.scrollBy(c.left, (b.top+b.bottom-window.external.getViewHeight())/2);   //  то переставляем середину элемента на середину окна.
             else  window.scrollBy(c.left, b.top);                                //  А если нет - то переставляем начало элемента в начало окна.
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ФУНКЦИЯ СКЛОНЕНИЯ ПО ПАДЕЖАМ В ЗАВИСИМОСТИ ОТ ЧИСЛА

 var ok=0;

 function pad(Numer) {
         var m1;
         var m2;
         var Numer;
         ok=2;
         m1=Numer % 10;
         m2=Numer % 100;
         if (m2<11 || m2>19) {
                 if (m1==1) ok=0;
                 else  if (m1==2 || m1==3 || m1==4) ok=1;    }
         return ok;
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ФУНКЦИЯ КОНВЕРТАЦИИ ВРЕМЕНИ  (мс  => мин., с)

 var tempus=0;
 var T;

 function time(T) {

         var Tmin  = Math.floor(T/60000);
         var TsecD = (T%60000)/1000;
         var Tsec = Math.floor(TsecD);

         if (Tmin ==0)
                 tempus = (+(TsecD+"").replace(/(.{1,5}).*/g, "$1")+"").replace(".", ",")+" сек";
             else {
                     tempus = Tmin+" мин";
                     if (Tsec !=0)
                             tempus += " " + Tsec+ " с" }

         return tempus;

         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ПРОВЕРКА РЕЖИМА

 if (fbwBody.style.display == "none") {
         window.external.SetStatusBarText("  •  Скрипт "+ScriptName+" v." + NumerusVersion + " можно запустить только в режиме «B» (Дизайн)");
         return;
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ПРОВЕРКА НА ПОВТОРНОЕ ПРИМЕНЕНИЕ СКРИПТА

 var saveDef=false;                            //  Индикатор сохранения дефиса.
 var saveDef_search=false;                       //  Индикатор для запуска поиска дефисов рядом с цифрами.
 var History=fbwBody.firstChild;   //  Предполагаемый раздел истории.

 //  Поиск раздела "историй"
 while (History != null  &&  History.className != "history")    //  Пока не найдем настоящий раздел истории, или окажется, что истории нет в тексте...
         History = History.nextSibling;         //  переходим на следующий раздел.

 //  Проверка на повторное применение скрипта
 var reSD = new RegExp("ГенУборка–|"+ScriptName, "g");   //  Поиск имени этого скрипта.
 
 if (History != null  &&  History.innerHTML.search(reSD)!=-1) {       //  Если в истории есть имя этого скрипта...
         if (SaveDef_on_off  == 1)       //  Если включено сохранение дефиса...
                 saveDef=true;                                 //  то включаем режим сохранения дефиса рядом с цифрами. 
         if (SaveDef_on_off  == 2)      //  Если выбран вопрос о сохранение дефиса...
                 saveDef_search=true;
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ПРЕДВАРИТЕЛЬНЫЙ АНАЛИЗ
                 //      (регулярные выражения)

// Замена ряда дефисов/тире на одно длинное тире (дубль №152)
 var reA152 = new RegExp("[\\\-–—]((\\\s|"+nbspEntity+"){0,1}[\\\-–—]){1,}","g");
 var reA152_ = "—";


//  Счетчики для дефисов, тире, короткого тире
 var count_D=0;
 var count_T=0;
 var count_K=0;
 
 
         // Поиск дефисов рядом с цифрами  
 var reA100s = new RegExp("\\\-[<0-9]|[0-9>]\\\-([^а-яё]|$)", "");
 var reA100ex = new RegExp("(ISBN|ББК|УДК|ГОСТ)(\\\s|"+nbspEntity+"){0,}[0-9]([0-9\\\-–\\\s]|"+nbspEntity+"){1,}[0-9]","g");
 var reA100 = new RegExp("\\\-(?=("+sIB+"){0,1}[0-9])|([0-9])("+fIB+"){0,1}\\\-(?=[^а-яё]|$)", "g");
 var count_A100 = 0; 

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ПРЕДВАРИТЕЛЬНЫЙ АНАЛИЗ
                 //      (сборка функции "Analiz")

 var s="";

 function Analiz(ptr) {

 s=ptr.innerHTML;  // оригинальный абзац

 if (s.search(reA152)!=-1)  s=s.replace(reA152, reA152_);

 //  Подсчет "черточек"
 if (s.search(/-/g)!=-1)   count_D+=s.match(/-/g).length;
 if (s.search(/—/g)!=-1)   count_T+=s.match(/—/g).length;
 if (s.search(/–/g)!=-1)   count_K+=s.match(/–/g).length;
 
 // Подсчет дефисов рядом с цифрами  
 if (saveDef_search  &&  s.search(reA100s)!=-1) {
         s=s.replace(reA100ex, "");
         if (s.search(reA100)!=-1)
                 count_A100+=s.match(reA100).length;
         }
 
 }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ПРЕДВАРИТЕЛЬНЫЙ АНАЛИЗ
                 //      (применение функции "Analiz")

 var div;
 var mP;
 var mPL;
 var ptr;

 var mChild = fbwBody.children;     //  Получение всех первых разделов "fbw_body"
 for (j=0;  j<mChild.length;  j++) {            //  Последовательный просмотр этих разделов
         div = mChild[j];
         if (div.className != "history"  &&  div.className != "annotation") {        //  выбор раздела (не аннотация и не история)
                 mP = div.getElementsByTagName("P");          //  Получение всех строк в найденном разделе
                 mPL = mP.length;                                       //  Получение количества строк
                 for (jj=0;  jj<mPL;  jj++)                       //  Последовательный просмотр строк
                         Analiz(mP[jj]);                                //   ... и применение к ним функции "Analiz"
                 }
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ПРЕДВАРИТЕЛЬНЫЙ АНАЛИЗ
                 //      (обработка и применение полученных данных)

     //  Анализ дефисов/тире

// Общее число "черточек"
 var count_DTK = count_D+count_T+count_K+0.00003;

 var pеrсent_D = (count_D+0.00001) / count_DTK * 100;    //  Процент дефисов от общего числа "черточек".
 var pеrсent_K = (count_K+0.00001) / count_DTK * 100;    //  Процент короткого тире от общего числа "черточек".

 var R_Def=true;  //  true  —  дефис  рядом с одной буквой   ›››   к/тире;     false  —  дефис  рядом с одной буквой   ›››   тире;

 var R_Tire=true;  //  true  —  тире  рядом с буквами   ›››   тире;     false  —  тире  рядом с буквами   ›››   дефис;
 var R_TireAvto=false;  //  true  —  закрепление за R_Tire значения "false"

 var R_KTi=true;  //  true  —  к/тире  рядом с буквами   ›››   дефис;     false  —  к/тире  рядом с буквами   ›››   тире;
 var R_KTiAvto=false;  //  true  —  закрепление за R_KTi значения "true"

//  Ситуация когда дефисов и к.тире меньше 0,6%, но есть длинные тире (хотя бы 5 шт.) — "тире" рядом с буквами всегда переходит в "дефис"
 R_TireAvto=(pеrсent_D<0.6  &&  pеrсent_K<0.6  &&  count_T>=5);
 if (R_TireAvto)  R_Tire=false;

//  Ситуация когда дефисов меньше 0,6%, но есть тире и короткие тире (хотя бы 5 шт.) — "короткое тире" рядом с буквами всегда переходит в "дефис"
 R_KTiAvto=(pеrсent_D<0.6  &&  count_K>=5);
 if (R_KTiAvto)  R_KTi=true;
 
  
 // Включение режима  "Сохранение дефиса рядом с цифрой"
 var Najdeny = ["Найден", "Найдены", "Найдено"];
 var defisov = ["дефис", "дефиса", "дефисов"];
 var jeti_defisy = ["этот дефис", "эти дефисы", "эти дефисы"];
 if (count_A100 >0) {   //  Если в тексте найдены дефисы рядом с цифрами...
         T_pause -= new Date().getTime();
         saveDef = AskYesNo("• "+Najdeny[pad(count_A100)]+" "+count_A100+" "+defisov[pad(count_A100)]+" рядом с цифрами       \n\n"+
                 "◊ Сохранить "+jeti_defisy[pad(count_A100)]+"? \n");   //  то задаем вопрос об их сохранении и включаем соответствующий режим.
         T_pause += new Date().getTime();
         } 
         
// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ПРОВЕРКА НА КУРСИВ/ЖИРНОСТЬ
                 //       для операций № 155-157, 921

 var reEmStAll = new RegExp("[А-яA-Za-zЁё0-9].{0,}?[А-яA-Za-zЁё0-9]","g"); // Учитывается фрагмент, в котором есть хотя бы две буквы/цифры
 var EmAll  = false;    //  индикатор наличия курсива во всём тексте
 var StAll  = false;     //  индикатор наличия жирности во всём тексте
 var EmStAll  = false;     //  индикатор наличия жирного курсива во всём тексте
 var mBI  = [];     //  массив для жирного курсива
 var count_EmSt = 0;    //  счетчик жирного курсива

 mP = fbwBody.getElementsByTagName("EM");     //  Получение всех фрагментов с курсивом
 var count_Em = mP.length;    //  счетчик курсива

 for (j=0;  j<count_Em;  j++)  {                                         //  Последовательный просмотр этих фрагментов
         if (!EmAll  &&  mP[j].innerText.search(reEmStAll)!=-1)  // Если есть подходящий фрагмент
                 EmAll  = true;                                                          // отмечаем это
         mBI = mP[j].getElementsByTagName("STRONG");    //  Получение в каждом курсиве фрагментов с жирностью
         count_EmSt += mBI.length;    //  счетчик жирного курсива
         for (jj=0;  !EmStAll  &&  jj<mBI.length;  jj++)              //  Последовательный просмотр этих фрагментов  (если подходящий фрагмент ещё не найден)
                 if (mBI[jj].innerText.search(reEmStAll)!=-1)    // Если есть подходящий фрагмент
                         { EmStAll = true;  break }               // отмечаем это и выходим из второстепенного цикла
         }

 mP = fbwBody.getElementsByTagName("STRONG");  //  Получение всех фрагментов с жирностью
 var count_St = mP.length;    //  счетчик жирности

 for (j=0;  j<count_St;  j++)  {                                                 //  Последовательный просмотр этих фрагментов
         if (!StAll  &&  mP[j].innerText.search(reEmStAll)!=-1)  // Если есть подходящий фрагмент
                 StAll  = true;                                                          // отмечаем это
         mBI = mP[j].getElementsByTagName("EM");    //  Получение в каждой жирности фрагментов с курсивом
         count_EmSt += mBI.length;    //  счетчик жирного курсива
         for (jj=0;  !EmStAll  &&  jj<mBI.length;  jj++)               //  Последовательный просмотр этих фрагментов  (если подходящий фрагмент ещё не найден)
                 if (mBI[jj].innerText.search(reEmStAll)!=-1)    // Если есть подходящий фрагмент
                         { EmStAll = true;  break }               // отмечаем это и выходим из второстепенного цикла
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ВОПРОСЫ
                 //      (регулярные выражения)


           // Форматирование "Код"

 var reV01 = new RegExp("(<SPAN class=code>.+?</SPAN>)","g");
 var mV01=[];           //  Сохраненные фрагменты.
 var count_V01=0;   //  Счетчик номеров для фрагмента.
 var count_V01_=0;  //  Счетчик пропущенных фрагментов.


         // Предварительная обработка текста перед поиском дефисов/тире

// Удаление всех тегов
 var reCT = new RegExp("(<.+?>)","g");
 var reCT_ = "";

// Ряд пробелов   ›››   обычный пробел   (копия №120)
 var reV120 = new RegExp("(\\\s|"+nbspEntity+"){2,}","g");
 var reV120_ = " ";

// Замена ряда дефисов/тире на одно длинное тире (копия №152)
 var reV152 = new RegExp("[\\\-–—]((\\\s|"+nbspEntity+"){0,1}[\\\-–—]){1,}","g");
 var reV152_ = "—";


       //  Дефис

// дефис + пробел       между букв   (исключается первая римская цифра - промежутки в римских числах обрабатываются автоматом)
 var reV10s = new RegExp("[А-яABD-HJKM-UWYZa-zЁё“»”\\\"]((\\\-|\\\s|"+nbspEntity+"){2})[А-яA-Za-zЁё«„“\\\"]","g");  //  для поиска
 var reV10 = new RegExp("(^|[^А-яA-Za-zЁё\\\-])[А-яA-Za-zЁё\\\-]{0,17}.{0,32}?[А-яABD-HJKM-UWYZa-zЁё“»”\\\"](\\\-|\\\s|"+nbspEntity+"){2}[А-яA-Za-zЁё«„“\\\"].{0,37}[А-яA-Za-zЁё\\\-]{0,17}(?=[^А-яA-Za-zЁё\\\-]|$)","g");

 //  для вставки квадратных скобок
 var reV11 = new RegExp("([А-яABD-HJKM-UWYZa-zЁё“»”\\\"])((\\\-|\\\s|"+nbspEntity+"){2})(?=[А-яA-Za-zЁё«„“\\\"])","g");
 var reV11_ = "$1[$2]";

 var mDef=[];            //  Сохраненные фрагменты.
 var count_V10=0;   //  Счетчик номеров для фрагмента.
 var count_V10_=0;  //  Счетчик пропущенных фрагментов.


       //  Тире

// (тире    или    тире + пробел)       между букв   (исключается первая римская цифра - промежутки в римских числах обрабатываются автоматом)
 var reV20s = new RegExp("[А-яABD-HJKM-UWYZa-zЁё“»”\\\"](—|(—|\\\s|"+nbspEntity+"){2})[А-яA-Za-zЁё«„“\\\"]","g");
 var reV20 = new RegExp("(^|[^А-яA-Za-zЁё\\\-])[А-яA-Za-zЁё\\\-]{0,17}.{0,32}?[А-яABD-HJKM-UWYZa-zЁё“»”\\\"](—|(—|\\\s|"+nbspEntity+"){2})[А-яA-Za-zЁё«„“\\\"].{0,37}[А-яA-Za-zЁё\\\-]{0,17}(?=[^А-яA-Za-zЁё\\\-]|$)","g");

 //  для вставки квадратных скобок
 var reV21 = new RegExp("([А-яABD-HJKM-UWYZa-zЁё“»”\\\"])(—|(—|\\\s|"+nbspEntity+"){2})(?=[А-яA-Za-zЁё«„“\\\"])","g");
 var reV21_ = "$1[$2]";

 var mTire=[];           //  Сохраненные фрагменты.
 var count_V20=0;   //  Счетчик номеров для фрагмента.
 var count_V20_=0;  //  Счетчик пропущенных фрагментов.


       //  Короткое тире

// к.тире    или    к.тире + пробел       между букв   (исключается первая римская цифра - промежутки в римских числах обрабатываются автоматом)
 var reV30s = new RegExp("[А-яABD-HJKM-UWYZa-zЁё“»”\\\"](–|(–|\\\s|"+nbspEntity+"){2})[А-яA-Za-zЁё«„“\\\"]","g");
 var reV30 = new RegExp("(^|[^А-яA-Za-zЁё\\\-])[А-яA-Za-zЁё\\\-]{0,17}.{0,32}?[А-яABD-HJKM-UWYZa-zЁё“»”\\\"](–|(–|\\\s|"+nbspEntity+"){2})[А-яA-Za-zЁё«„“\\\"].{0,37}[А-яA-Za-zЁё\\\-]{0,17}(?=[^А-яA-Za-zЁё\\\-]|$)","g");
	//  для вставки квадратных скобок
	 var reV31 = new RegExp("([А-яABD-HJKM-UWYZa-zЁё“»”\\\"])(–|(–|\\\s|"+nbspEntity+"){2})(?=[А-яA-Za-zЁё«„“\\\"])","g");
	 var reV31_ = "$1[$2]";

 var mKTi=[];            //  Сохраненные фрагменты.
 var count_V30=0;   //  Счетчик номеров для фрагмента.
 var count_V30_=0;  //  Счетчик пропущенных фрагментов.

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ВОПРОСЫ
                 //      (сборка функции "Vopros")

 var max0=22;  //   Максимум найденных строк в окне вопроса
 var massif=[];  //   Сохраненные фрагменты из одной строки


 function Vopros(ptr) {
 s=ptr.innerHTML;  // оригинальный абзац
  // В оригинальном абзаце ничего не изменяется — можно попортить текст в формате Код
 // Здесь всё только для качественного сохранения фрагментов


   if (s.search(/</g)!=-1  &&  s.search(reV01)!=-1) {    //  Если найден любой тег, и этот тег кода...
           if (count_V01<max0) {                                  //  Проверяем: вместится ли новая строка в окно вопроса.  Если вместится...
                   massif=s.match(reV01);                         //  Сохраняем фрагменты с кодом из всего абзаца.
                   for (n=0;  n < massif.length;  n++)      //  Запускаем цикл для всех найденных фрагментов.
                           if (count_V01< max0) {                                           //  Если ещё одна строка поместится в окно вопроса...
                                   mV01[count_V01]=massif[n].replace(reCT, reCT_);  //   сохраняем фрагмент в основном массиве
                                   count_V01++;    }                                                         //  и увеличиваем счетчик найденных фрагментов.
                               else  count_V01_++;                                       //  А если не поместится, то увеличиваем счетчик пропущенных фрагментов без сохранения в основном массиве.
                   }
               else                                                 //  Если же проверка места в окне не пройдена на раннем этапе...
                   count_V01_+=s.match(reV01).length;   //  то добавляем в счетчик пропущенных фрагментов все найденные фрагмены.
          }


   if (s.search(/</g)!=-1)  s=s.replace(reCT, reCT_);                  //  Удаление всех внутренних тегов строки
   if (s.search(reV120)!=-1)  s=s.replace(reV120, reV120_);      //  ряд пробелов  ›››  пробел
   if (s.search(reV152)!=-1)  s=s.replace(reV152, reV152_);      //  ряд дефисов/тире  ›››  тире


   if (s.search(/-/g)!=-1  &&  s.search(reV10s)!=-1) {    //  Если найден дефис, и этот он рядом с одной буквой...
           if (count_V10<max0) {                                  //  Проверяем: вместится ли новая строка в окно вопроса.  Если вместится...
                   massif=s.match(reV10);                         //  Сохраняем фрагменты с таким дефисом из всего абзаца.
                   for (n=0;  n < massif.length;  n++)      //  Запускаем цикл для всех найденных фрагментов.
                           if (count_V10< max0) {                                           //  Если ещё одна строка поместится в окно вопроса...
                                   mDef[count_V10]=massif[n].replace(reV11, reV11_);  //   сохраняем фрагмент в основном массиве
                                   count_V10++;    }                                                         //  и увеличиваем счетчик найденных фрагментов.
                               else  count_V10_++;                                       //  А если не поместится, то увеличиваем счетчик пропущенных фрагментов без сохранения в основном массиве.
                   }
               else                                                 //  Если же проверка места в окне не пройдена на раннем этапе...
                   count_V10_+=s.match(reV10s).length;   //  то добавляем в счетчик пропущенных фрагментов все найденные фрагмены.
           }

   if (!R_TireAvto  &&  s.search(/—/g)!=-1  &&  s.search(reV20s)!=-1) {   //  Если автомат не сработал, и если найдено тире, и оно рядом с 1-2 буквами...
           if (count_V20<max0) {                                  //  Проверяем: вместится ли новая строка в окно вопроса.  Если вместится...
                   massif=s.match(reV20);                         //  Сохраняем фрагменты с таким тире из всего абзаца.
                   for (n=0;  n < massif.length;  n++)      //  Запускаем цикл для всех найденных фрагментов.
                           if (count_V20< max0) {                                           //  Если ещё одна строка поместится в окно вопроса...
                                   mTire[count_V20]=massif[n].replace(reV21, reV21_);   //  сохраняем фрагмент в основном массиве
                                   count_V20++;    }                                                         //  и увеличиваем счетчик найденных фрагментов.
                               else  count_V20_++;                                       //  А если не поместится, то увеличиваем счетчик пропущенных фрагментов без сохранения в основном массиве.
                   }
               else                                                 //  Если же проверка места в окне не пройдена на раннем этапе...
                   count_V20_+=s.match(reV20s).length;   //  то добавляем в счетчик пропущенных фрагментов все найденные фрагменты.
           }

   if (!R_KTiAvto  &&  s.search(/–/g)!=-1  &&  s.search(reV30s)!=-1) {   //  Если автомат не сработал, и если найдено короткое тире, и оно рядом с 1-2 буквами...
           if (count_V30<max0) {                                  //  Проверяем: вместится ли новая строка в окно вопроса.  Если вместится...
                   massif=s.match(reV30);                         //  Сохраняем фрагменты с таким тире из всего абзаца.
                   for (n=0;  n < massif.length;  n++)      //  Запускаем цикл для всех найденных фрагментов.
                           if (count_V30< max0) {                                           //  Если ещё одна строка поместится в окно вопроса...
                                   mKTi[count_V30]=massif[n].replace(reV31, reV31_);   //  сохраняем фрагмент в основном массиве
                                   count_V30++;    }                                                         //  и увеличиваем счетчик найденных фрагментов.
                               else  count_V30_++;                                       //  А если не поместится, то увеличиваем счетчик пропущенных фрагментов без сохранения в основном массиве.
                   }
               else                                                 //  Если же проверка места в окне не пройдена на раннем этапе...
                   count_V30_+=s.match(reV30s).length;   //  то добавляем в счетчик пропущенных фрагментов все найденные фрагменты.
           }

   }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ВОПРОСЫ
                 //      (применение функции)

 for (j=0;  j<mChild.length;  j++) {            //  Последовательный просмотр всех первых разделов "fbw_body"
         div = mChild[j];
         if (div.className != "history" || ObrabotkaHistory) {        //  выбор раздела (не история при отказе от обработки)
                 mP = div.getElementsByTagName("P");          //  Получение всех строк в найденном разделе
                 mPL = mP.length;                                       //  Получение количества строк
                 for (jj=0;  jj<mPL;  jj++)                       //  Последовательный просмотр строк
                         Vopros(mP[jj]);                              //   ... и применение к ним функции "Vopros"
                 }
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ВОПРОСЫ
                 //      (обработка и применение полученных данных)

   // Обрезка фрагмента (для формата "код")
 var reF01 = new RegExp("^((.{85,110}?)(\\\s|"+nbspEntity+"|$)|(.{110}))(.{0,})$","g");
 var reF01_ = "$1";

   // удвоение пробелов для лучшей картинки
 var reF02 = new RegExp("(\\\s|"+nbspEntity+")","g");
 var reF02_ = "  ";

   // Добавление многоточий в начале и конце фрагмента
 var reF03 = new RegExp("^[^А-яA-Za-zЁё0-9«„“»”\\\"]{0,5}|(.)[^А-яA-Za-zЁё0-9«„“»”\\\"]{0,5}$","g");
 var reF03_ = "$1…";

 var vop="";              //  Текст со всеми фрагментами.
 var pohozhi_fragmentov=["похожий фрагмент", "похожих фрагмента", "похожих фрагментов"];
 var fragmenta = [ " фрагмент", " фрагмента", " фрагментов"];


 var R_Code=true;         //  Индикатор обработки кода.
 if (count_V01!=0) {                //  Если есть строки фрагментов с кодом...
         vop="";
         for (n=0; n<count_V01; n++)                                    //  то запускаем для них цикл,
                vop += "\n"+mV01[n].replace(reF01, reF01_).replace(reF02, reF02_).replace(reF03, reF03_)+"  \n";   //  в котором добавляем все строки в текст,
         if (count_V01_>0)                                                                          //  а если есть пропущенные фрагменты...
                 vop = vop.replace(/\n.+\n$/, "\n   * В тексте есть ещё  "+(count_V01_+1)+"  "+pohozhi_fragmentov[pad(count_V01_+1)]+"\n");   //  добавляем в текст ещё одну запись,
         T_pause -= new Date().getTime();
         R_Code=AskYesNo("•  ОБРАБАТЫВАТЬ  формат  «КОД» ?\n"+
                              "--------------------------------------------------\n"+
                              vop+"\n"+
                              "-----------------------------------------------------------------------\n"+
                              "• ДА  —	Обрабатывать\n"+
                              "• НЕТ —	Экранировать (сохранить оригинальный текст)");      //  и получаем ответ на собранный вопрос.
         T_pause += new Date().getTime();
         }


 if (count_V10!=0) {                //  Если есть строки фрагментов с дефисом рядом с одной буквой...
         vop="";
         for (n=0; n<count_V10; n++) {                                      //  то запускаем для них цикл,
                 vop += "\n"+mDef[n].replace(reF02, reF02_).replace(reF03, reF03_)+"  \n" }   //  в котором добавляем все строки в текст,
         if (count_V10_>0)                                                                          //  а если есть пропущенные фрагменты...
                 vop = vop.replace(/\n.+\n$/, "\n   * В тексте есть ещё  "+(count_V10_+1)+"  "+pohozhi_fragmentov[pad(count_V10_+1)]+"\n");   //  добавляем в текст ещё одну запись,
         T_pause -= new Date().getTime();
         R_Def=AskYesNo("• ДЕФИС РЯДОМ С ОДНОЙ БУКВОЙ\n"+
                              "--------------------------------------------------\n"+
                              vop+"\n"+
                              "-----------------------------------------------------------------------\n"+
                              "• ДА  —	сохранить дефис как  КОРОТКОЕ ТИРЕ\n"+
                              "• НЕТ —	оторвать от букв и заменить на  ДЛИННОЕ ТИРЕ");      //  и получаем ответ на собранный вопрос.
         T_pause += new Date().getTime();
         }

if (count_V30!=0) {                //  Если есть строки фрагментов с коротким тире рядом с одной-двумя буквами...
         vop="";
        for (n=0; n<count_V30; n++) {                                      //  то запускаем для них цикл,
                 vop += "\n"+mKTi[n].replace(reF02, reF02_).replace(reF03, reF03_)+"  \n" }   //  в котором добавляем все строки в текст,
         if (count_V30_>0)                                                                          //  а если есть пропущенные фрагменты...
                 vop = vop.replace(/\n.+\n$/, "\n   * В тексте есть ещё  "+(count_V30_+1)+"  "+pohozhi_fragmentov[pad(count_V30_+1)]+"\n");   //  добавляем в текст ещё одну запись,
         T_pause -= new Date().getTime();
         R_KTi=AskYesNo("• КОРОТКОЕ ТИРЕ РЯДОМ С БУКВАМИ\n"+
                              "--------------------------------------------------\n"+
                              vop+"\n"+
                              "-----------------------------------------------------------------------\n"+
                              "• ДА  —	сохранить как  КОРОТКОЕ ТИРЕ  или  ДЕФИС\n"+
                              "• НЕТ —	оторвать от букв и заменить на  ДЛИННОЕ ТИРЕ");      //  и получаем ответ на собранный вопрос.
         T_pause += new Date().getTime();
         }

if (count_V20!=0) {                //  Если есть строки фрагментов с тире рядом с одной-двумя буквами...
         vop="";
        for (n=0; n<count_V20; n++) {                                      //  то запускаем для них цикл,
                 vop += "\n"+mTire[n].replace(reF02, reF02_).replace(reF03, reF03_)+"  \n" }   //  в котором добавляем все строки в текст,
         if (count_V20_>0)                                                                          //  а если есть пропущенные фрагменты...
                 vop = vop.replace(/\n.+\n$/, "\n   * В тексте есть ещё  "+(count_V20_+1)+"  "+pohozhi_fragmentov[pad(count_V20_+1)]+"\n");   //  добавляем в текст ещё одну запись,
         T_pause -= new Date().getTime();
         R_Tire=AskYesNo("• ДЛИННОЕ ТИРЕ РЯДОМ С БУКВАМИ\n"+
                              "--------------------------------------------------\n"+
                              vop+"\n"+
                              "-----------------------------------------------------------------------\n"+
                              "• ДА  —	сохранить  ДЛИННОЕ ТИРЕ  и оторвать его от букв\n"+
                              "• НЕТ —	заменить на  КОРОТКОЕ ТИРЕ  или  ДЕФИС");      //  и получаем ответ на собранный вопрос.
         T_pause += new Date().getTime();
         }


// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОБРАБОТКА ТЕКСТА
                 //      (регулярные выражения)

// Замена кода   "&nbsp;"   на обычный неразрывный пробел (временно)
 var reNBSPoff = new RegExp(nbspEntity,"g");
 var reNBSPoff_ = nbspChar;

// ---------------------------------------------------------------
/// СКРЫТИЕ АДРЕСОВ И ФОРМАТА КОД
// ---------------------------------------------------------------

// Скрытие и сохранение кода в массиве (временно)
 var reCode1 = new RegExp("(<SPAN class=code>.+?</SPAN>)","g");
 var reCode1_ = FalseCode;   // замена фрагмента на обманку
 var count_Code=0;
 var mCode=[];  //   Массив для сохраненных фрагментов одного абзаца
 var Code_=false;  //   Индикатор сохранения

// Скрытие и сохранение эл. адреса в массиве. (временно)
//   * Все активные ссылки (внутри кавычек href="...")
 var reUrl1_s = new RegExp("href=\\\"","g");
 var reUrl1 = new RegExp("href=\\\"[^&\\\"][^<>\\\"]{0,}","g");
 var reUrl1_ = "href=\""+UrlFalse1;   // замена фрагмента на обманку
 var count_Url1 = 0;
 var mUrl1=[];  //   Массив для сохраненных фрагментов одного абзаца
 var Url1_=false;  //   Индикатор сохранения

// Скрытие и сохранение эл. адреса (текстом) в массиве. (временно)
 var reUrl3 = new RegExp("([a-z]:[\\\\/]|www\\\.|mailto:)[^<>\\\s"+nbspChar+"]{0,}[а-яa-zё0-9]","gi");
 var reUrl3_ = UrlFalse3;   // замена фрагмента на обманку
 var count_Url3 = 0;
 var mUrl3=[];  //   Массив для сохраненных фрагментов одного абзаца
 var Url3_=false;  //   Индикатор сохранения


       // Ошибочное примечание
 var re011 = new RegExp("(<A )class=note (href=\")[^>]{0,}?((http:|mailto:)[^>]{0,}>)","g");
 var re011_ = "$1$2$3";
 var count_011 = 0;

       // Объединение ссылок
 var re012 = new RegExp("(<A [^>]{1,}>)([^<]{0,})</A>([\\\s"+nbspChar+"]{0,})\\1([^<]{0,}</A>)","g");
 var re012_ = "$1$2$3$4";
 var count_012 = 0;

//  Исправление ошибки в сетевом неактивном адресе (пробел перед %+число)
 var re021 = new RegExp("(([a-z]:[\\\\/]|www\\\.|mailto:)[^<>\\\s"+nbspChar+"]{0,})(\\\s|"+nbspChar+")(%[0-9A-F])","g");
 var re021_ = "$1$4";
 var count_021 = 0;

// ---------------------------------------------------------------
/// ПОИСК
// ---------------------------------------------------------------

       // Разделы

// Стихи
 var poem_ = false;


       // Кавычки

//   Угловые кавычки (обе)
 var reQQ = new RegExp("[«»]","g");
 var QQ_  = false;

// Все кавычки
 var reQuQu = new RegExp("[“”«„»\\\"]","g");
 var QuQu_  = false;


       // Дефисы и тире

// Дефисы
 var reDef = new RegExp("\\\-","g");
 var Def_  = false;

// Тире
 var reTire = new RegExp("—","g");
 var Tire_  = false;

// Короткие тире
 var reKTi = new RegExp("–","g");
 var KTi_  = false;

// Дефисы и тире (все)
 var reTiDe = new RegExp("[—–\\\-]","g");
 var TiDe_  = false;


       // Символы

// Многоточия
 var reTTT = new RegExp("…","g");
 var TTT_  = false;

// Неразрывные пробелы
 var reP41 = new RegExp(nbspChar,"g");
 var P41_  = false;

// Знаки вопроса и восклицания
 var reP43 = new RegExp("[\\\?!]","g");
 var P43_  = false;

// Двоеточие или точка-запятая
 var reP48 = new RegExp("[:;]","g");
 var P48_ = false;


       // Разное

// Числа
 var reNN = new RegExp("[0-9]","g");
 var NN_  = false;

// Римские числа
 var reXXI = new RegExp("[IVXLC]","g");
 var XXI_  = false;

// Сокращение + пробел
 var reSokr = new RegExp("\\\.\\\s{0,1}[а-яё]","g");
 var Sokr_  = false;


       // Теги

 //  Все теги
 var reTag = new RegExp("<","g");
 var Tag_  = false;

// Курсив
 var reEm = new RegExp("<EM>","g");
 var Em_  = false;

// Жирность
 var reSt = new RegExp("<STRONG>","g");
 var St_  = false;

// Курсив-жирность
 var EmSt_  = false;

// Индексы
 var reSubSup = new RegExp("<SUB>|<SUP>","g");
 var SubSup_  = false;


// Все сноски
 var reNoCom = new RegExp("<A class=note|><SUP>\\\{\\\d{1,5}\\\}</SUP></A>","g");
 var NoCom_  = false;

// ---------------------------------------------------------------
/// ВАЛИДАЦИЯ ЗНАКОВ ПРЕПИНАНИЯ И Т.П.  :  операции  № 1хх
// ---------------------------------------------------------------

// Удаление спец. символов
// U+00AD; U+200A; U+200B; U+200E; U+200C; U+200D; U+FEFF;
 var re101 = new RegExp("[­ ​‌‍‎﻿]|&shy;","g");
 var re101_ = "";
 var count_101 = 0;

// Замена спец. символов на обычные пробелы
// U+2002; U+2003; U+2004; U+2005; U+2006; U+2007; U+2008; U+2009; U+2028; U+2029; U+3000;
 var re102 = new RegExp("[          　]","g");
 var re102_ = " ";
 var count_102 = 0;
	// Коррекция для стихов
	 var re102a = new RegExp("\\\s(?=\\\s|"+nbspChar+")","g");
	 var re102a_ = nbspChar;

// Замена спец. символа на неразрывный пробел
// U+202F;
 var re103 = new RegExp("[ ]","g");
 var re103_ = nbspChar;
 var count_103 = 0;

// Замена спец. символов на дефисы
// U+2010; U+2011; U+2012;
 var re104 = new RegExp("[‐‑‒]","g");
 var re104_ = "-";
 var count_104 = 0;

// Замена спец. символов на длинное тире
// U+2015; U+2500;
 var re105 = new RegExp("[―─]","g");
 var re105_ = "—";
 var count_105 = 0;

// Замена спец. символа на запятую
// U+201A;
 var re106 = new RegExp("[‚]([^А-яA-Za-zЁё0-9]|$)","g");
 var re106_ = ",";
 var count_106 = 0;


// Замена спец. символов на апостроф (U+2019)
// U+0027; U+0060; U+00B4; U+02BC; U+0384; U+2018; U+2032;
 if (Apostrof != 0) {
         var re107 = new RegExp("(^|[^0-9])′|['`´ʼ΄‘]","g");
         var re107_ = "$1’";
         }

// Замена спец. символов на апостроф (U+0027)
// U+0060; U+00B4; U+02BC; U+0384; U+2018; U+2019; U+2032;
 if (Apostrof == 0) {
         var re107 = new RegExp("(^|[^0-9])′|[`´ʼ΄‘’]","g");
         var re107_ = "$1'";
         }

 var count_107 = 0;


// Сдвоенный апостроф   ›››   прямые кавычки
 var re108 = new RegExp("(’’|'')","g");
 var re108_ = "\"";
 var count_108 = 0;

//  Спец. символы   ›››   Знак градуса
//   U+00BA; U+02DA; U+2070;
 var re109 = new RegExp("[º˚⁰]","g");
 var re109_ = "°";
 var count_109 = 0;

 //  Символы дробей   ›››   Обычная запись с тегами
 //  U+00BC; U+00BD; U+00BE; U+2153; U+2154; U+2155; U+2156; U+2157; U+2158; U+2159; U+215A; U+215B; U+215C; U+215D; U+215E;
 var re110s = new RegExp("[¼½¾⅓⅔⅕⅖⅗⅘⅙⅚⅛⅜⅝⅞]","g");

 var m110re = [];
 var m110re_ = [];
 var count_110 = 0;

 m110re[0] = new RegExp("¼", "g");
 m110re_[0] = "<SUP>1</SUP>/<SUB>4</SUB>";

 m110re[1] = new RegExp("½", "g");
 m110re_[1] = "<SUP>1</SUP>/<SUB>2</SUB>";

 m110re[2] = new RegExp("¾","g");
 m110re_[2] = "<SUP>3</SUP>/<SUB>4</SUB>";

 m110re[3] = new RegExp("⅓","g");
 m110re_[3] = "<SUP>1</SUP>/<SUB>3</SUB>";

 m110re[4] = new RegExp("⅔","g");
 m110re_[4] = "<SUP>2</SUP>/<SUB>3</SUB>";

 m110re[5] = new RegExp("⅕","g");
 m110re_[5] = "<SUP>1</SUP>/<SUB>5</SUB>";

 m110re[6] = new RegExp("⅖","g");
 m110re_[6] = "<SUP>2</SUP>/<SUB>5</SUB>";

 m110re[7] = new RegExp("⅗","g");
 m110re_[7] = "<SUP>3</SUP>/<SUB>5</SUB>";

 m110re[8] = new RegExp("⅘","g");
 m110re_[8] = "<SUP>4</SUP>/<SUB>5</SUB>";

 m110re[9] = new RegExp("⅙","g");
 m110re_[9] = "<SUP>1</SUP>/<SUB>6</SUB>";

 m110re[10] = new RegExp("⅚","g");
 m110re_[10] = "<SUP>5</SUP>/<SUB>6</SUB>";

 m110re[11] = new RegExp("⅛","g");
 m110re_[11] = "<SUP>1</SUP>/<SUB>8</SUB>";

 m110re[12] = new RegExp("⅜","g");
 m110re_[12] = "<SUP>3</SUP>/<SUB>8</SUB>";

 m110re[13] = new RegExp("⅝","g");
 m110re_[13] = "<SUP>5</SUP>/<SUB>8</SUB>";

 m110re[14] = new RegExp("⅞","g");
 m110re_[14] = "<SUP>7</SUP>/<SUB>8</SUB>";

//  Символы надстрочных цифр   ›››   Обычная запись с тегами
//  U+00B9; U+00B2; U+00B3; U+2074; U+2075; U+2076; U+2077; U+2078; U+2079; U+207F
 var re111s = new RegExp("[¹²³⁴⁵⁶⁷⁸⁹ⁿ]","g");

 var m111re = [];
 var m111re_ = [];
 var count_111 = 0;

 m111re[0] = new RegExp("²", "g");
 m111re_[0] = "<SUP>2</SUP>";

 m111re[1] = new RegExp("³","g");
 m111re_[1] = "<SUP>3</SUP>";

 m111re[2] = new RegExp("¹", "g");
 m111re_[2] = "<SUP>1</SUP>";

 m111re[3] = new RegExp("⁴","g");
 m111re_[3] = "<SUP>4</SUP>";

 m111re[4] = new RegExp("⁵","g");
 m111re_[4] = "<SUP>5</SUP>";

 m111re[5] = new RegExp("⁶","g");
 m111re_[5] = "<SUP>6</SUP>";

 m111re[6] = new RegExp("⁷","g");
 m111re_[6] = "<SUP>7</SUP>";

 m111re[7] = new RegExp("⁸","g");
 m111re_[7] = "<SUP>8</SUP>";

 m111re[8] = new RegExp("⁹","g");
 m111re_[8] = "<SUP>9</SUP>";

 m111re[9] = new RegExp("ⁿ","g");
 m111re_[9] = "<SUP>n</SUP>";

//  Символы подстрочных цифр   ›››   Обычная запись с тегами
//  U+2080; U+2081; U+2082; U+2083; U+2084; U+2085; U+2086; U+2087; U+2088; U+2089;
 var re112s = new RegExp("[₀₁₂₃₄₅₆₇₈₉]","g");

 var m112re = [];
 var m112re_ = [];
 var count_112 = 0;

 m112re[0] = new RegExp("₀", "g");
 m112re_[0] = "<SUB>0</SUB>";

 m112re[1] = new RegExp("₁", "g");
 m112re_[1] = "<SUB>1</SUB>";

 m112re[2] = new RegExp("₂","g");
 m112re_[2] = "<SUB>2</SUB>";

 m112re[3] = new RegExp("₃","g");
 m112re_[3] = "<SUB>3</SUB>";

 m112re[4] = new RegExp("₄","g");
 m112re_[4] = "<SUB>4</SUB>";

 m112re[5] = new RegExp("₅","g");
 m112re_[5] = "<SUB>5</SUB>";

 m112re[6] = new RegExp("₆","g");
 m112re_[6] = "<SUB>6</SUB>";

 m112re[7] = new RegExp("₇","g");
 m112re_[7] = "<SUB>7</SUB>";

 m112re[8] = new RegExp("₈","g");
 m112re_[8] = "<SUB>8</SUB>";

 m112re[9] = new RegExp("₉","g");
 m112re_[9] = "<SUB>9</SUB>";


//  Спец. символы (⁄ ∕ )   ›››   "/"
//   U+2044; U+2215; (последний символ очень узкий, поэтому рядом с ним заменяются и возможные пробелы)
 var re114 = new RegExp("(⁄| ?∕ ?)","g");
 var re114_ = "/";
 var count_114 = 0;


// Добавление пропущенного знака "&"
 var re116 = new RegExp("(^|[^A-Za-z;&])(amp;|nbsp;)","g");
 var re116_ = "$1&$2";
 var count_116 = 0;


// Замена кода н/р пробела на принятое обозначение в FBE
// Устраняет небольшой глюк, который получается после вставки в FBE нескольких строк, после некоторых скриптов или действий в FBE
 var re117 = new RegExp("&nbsp;","g");
 var re117_ = nbspChar;
 var count_117 = 0;


       // Чистка пустых ссылок
 var re118s = new RegExp("href=\\\"\\\"","g");
 var re118 = new RegExp("<A\\\s[^>]{0,}href=\\\"\\\"[^>]{0,}>(.{0,}?)</A>","g");
 var re118_ = "$1";
 var count_118 = 0;


       // Внутренние теги

//  Нормализация пробелов на Окраине тегов
 var re119 = new RegExp("(<[^/][^>]{0,}>)((\\\s|"+nbspChar+"){1,})|((\\\s|"+nbspChar+"){1,})(</[^>]{1,}>)","g");
 var re119_ = "$2$1$6$4";
 var count_119 = 0;


       //  Ряд пробелов

// Ряд пробелов   ›››   обычный пробел   (не в стихах)
 var re120 = new RegExp("(\\\s|"+nbspChar+"){2,}","g");
 var re120_ = " ";
 var count_120 = 0;

// удаление начальных пробелов строки   (не в стихах)
 var re121 = new RegExp("^(\\\s|"+nbspChar+"){1,}","g");
 var re121_ = "";
 var count_121 = 0;

// удаление конечных пробелов строки
 var re122 = new RegExp("(\\\s|"+nbspChar+"){1,}$","g");
 var re122_ = "";
 var count_122 = 0;


//  Исключение из обработки строк, целиком состоящих из 2-х и более символов:       .    \    /    *    _    -    –    —    ~    •    ·
//  И строк, целиком состоящих из 3-х и более символов:       "х"
//  НО допускается к обработке комбинация: тире/дефис (0-2 шт.)  + точки (2-4 шт.)
 var re129ex1 = new RegExp("^("+sIB+"){0,1}([\\\.|\\\\/\\\*_\\\-–—~•·](\\\s|"+nbspChar+"){0,}){2,}("+fIB+"){0,1}$","g");
 var re129ex2 = new RegExp("^("+sIB+"){0,1}([хx](\\\s|"+nbspChar+"){0,}){3,}("+fIB+"){0,1}$","g");
 var re129ex_ex = new RegExp("^("+sIB+"){0,1}[\\\-–—~]{0,2}((\\\s|"+nbspChar+"){0,}\\\.){2,4}("+fIB+"){0,1}$","g");
 var count_129ex = 0;


       //  Многоточие и т.п.

// троеточие и его производные (... ,.. .,. ..,)   ›››   многоточие
 var re130 = new RegExp("(\\\.\\\s{0,1}\\\.\\\s{0,1}\\\.|,\\\.\\\.|\\\.,\\\.|\\\.\\\.,)","g");
 var re130_ = "…";
 var count_130 = 0;

// многоточие + комбинации точки и запятой   ›››   многоточие
 var re131= new RegExp("(…)[\\\.,]{1,2}","g");
 var re131_ = "…";
 var count_131 = 0;

// "?…", "!…" и похожие наборы знаков   ›››   "?.." и "!.."
 var re132 = new RegExp("([!\\\?])(…|\\\.,|,\\\.)","g");
 var re132_ = "$1..";
 var count_132 = 0;

// "?!"  +  две точки или запятая   ›››     "?!."
 var re133= new RegExp("((^|[^\\\?!])[\\\?!]{2})(\\\.\\\.|,)","g");
 var re133_ = "$1.";
 var count_133 = 0;

// точка + точка    ›››   многоточие   - в начале слов и предложений
 var re140= new RegExp("(^|\\\s|"+nbspChar+"|[\\\(\\\[«„])\\\.\\\.(?=[^\\\?!]|$)","g");
 var re140_ = "$1…";
 var count_140 = 0;

// точка + точка    ›››   многоточие   - перед знаками и буквами
 var re141= new RegExp("([^\\\?!])\\\.\\\.(?=([А-яA-Za-zЁё…\\\)\\\]«„“»”\\\"]|(\\\s|"+nbspChar+")[…\\\(\\\[«„“»”\\\"]{0,1}[а-яa-zё]))","g");
 var re141_ = "$1…";
// используется счетчик №140
//  * Основной случай замены   двух точек   в конце предложения   на многоточие или точку   у меня не получился -- слишком много ошибочных исправлений.. даже с анализом текста на лишние точки..


//  Знак + точка, запятая или маркер   ›››   знак
 var re150= new RegExp("(^;|[^a-z];|[,:—])[\\\.,•]","g");
 var re150_ = "$1";
 var count_150 = 0;
   //   возможно повторное выполнение после № 420, 423


// Замена ряда дефисов/тире на одно длинное тире
 var re152 = new RegExp("[\\\-–—]((\\\s|"+nbspChar+"){0,1}[\\\-–—]){1,}","g");
 var re152_ = "—";
 var count_152 = 0;


       //  Выделение подчеркиванием в обычное выделение

// Стартовая формула для № 155-158
 var re155s = new RegExp("_[^<_>]{1,}_[^>]{0,}(<|$)","g");

// Константы для №№ 155-158 (для упрощения записи формул)
 var Z1="…\\\(\\\[«„“\\\"’'—–\\\-";  // начальные знаки
// var Z2="…\\\.,:;\\\?!\\\(\\\)\\\[\\\]«„“»”\\\"’'—–\\\-";  // средние знаки
 var Z3="…\\\.,:;\\\?!\\\)\\\]»“”\\\"’'—–\\\-";  // конечные знаки

         // _Подчеркивание в курсив_
// пробел  +  (знак)  +  _  +  знаки/буквы/пробелы  +  _  +  (знак)  +  пробел    ›››
//      ›››    пробел  +  (знак)  +  <EM>  +  знаки/буквы/пробелы  +  </EM>  +  (знак)  +  пробел
// * Если в тексте идут несколько таких блоков подряд, то они обрабатываются все вместе
// Исключения:   ряд блоков из одной буквы (_а_)
//            1. Поиск фрагментов
 var re155 = new RegExp("(^|\\\s|"+nbspChar+"|>)(["+Z1+"]{0,2})_(["+Z1+"]{0,2}[А-яA-Za-zЁё0-9]([^<>_]{0,}?[А-яA-Za-zЁё0-9]){0,1}["+Z3+"]{0,4})_((["+Z3+"]{0,4}(\\\s|"+nbspChar+")["+Z1+"]{0,2})_(["+Z1+"]{0,2}[А-яA-Za-zЁё0-9]([^<>_]{0,}?[А-яA-Za-zЁё0-9]){0,1}["+Z3+"]{0,4})_){0,}(?=["+Z3+"]{0,4}(<|\\\s|"+nbspChar+"|$))","g");
 var m155 = [];
//            2. Первое преобразование фрагментов (добавление формата курсива)
 var re155_2 = new RegExp("^(\\\s|"+nbspChar+"|>){0,1}(["+Z1+"]{0,2})(.{1,})$","g");
 var re155_2ex = new RegExp("^(\\\s|"+nbspChar+"|>){0,1}["+Z1+"]{0,2}_(["+Z1+"]{0,2}[А-яA-Za-zЁё0-9]["+Z3+"]{0,4})_((["+Z3+"]{0,4}(\\\s|"+nbspChar+")["+Z1+"]{0,2})_(["+Z1+"]{0,2}[А-яA-Za-zЁё0-9]["+Z3+"]{0,4})_){0,}$","g"); // искл.: _а_  ;  _а_ _а_
 switch (_format_) {
     case 1:  var re155_2_ = "$1$2<EM>$3</EM>";  break;
     case 2:  var re155_2_ = "$1$2<STRONG>$3</STRONG>";  break;
     case 3:  var re155_2_ = "$1$2<STRONG><EM>$3</EM></STRONG>";
     }
//            3. Ещё одно преобразование фрагментов (удаление знаков подчеркивания)
 var re155_3 = new RegExp("_","g");
//            4. Возвращение фрагментов в строку проходит без участия рег. выражений
//            Счетчик
 var count_155 = 0;
//            Выполненная операция в строке
 var if_155 = false;

         //  Функция допуска к операциям № 155, 157
 var Otvet_155 = true;    //  разрешение на проведение операции
 var Ask_155 = false;   //  вопрос о разрешении пока не задан
 var nomer_155 = "";   //  добавление номера

 function Dopusk_155() {
         if (_format_ == _bukva_  ||  _bukva_== 4)  { nomer_155 = ", 158"; }
         switch (_format_) {
             case 0:
                 Otvet_155 = false;
                 Ask_155 = true;
             case 1:
                 if (!Ask_155  &&  EmAll) {    //  если это первый вопрос, и в тексте есть определенный формат...
                         T_pause -= new Date().getTime();                  // определение продолжительности паузы в вычислениях
                         Otvet_155 = AskYesNo ("•  ОПЕРАЦИИ  № 155, 157"+nomer_155+"\n"+
                             "------------------------------------------\n"+
                             "						        \n"+
                             "Преобразование  «_текст_  ›››  курсив»\n"+
                             " добавит в текст форматирование  курсивным шрифтом.\n"+
                             "Но это форматирование не будет уникальным.\n"+
                             "В тексте книги уже есть "+count_Em+fragmenta[pad(count_Em)]+" в этом формате.\n\n"+
                             "------------------------------------------------------------\n"+
                             "◊  Разрешить преобразование\n"+
                             "    «_текст_  ›››  курсив» ?");
                         T_pause += new Date().getTime();                  // определение продолжительности паузы в вычислениях
                         Ask_155 = true;     //  вопрос задан (индикация)
                         }
                 break;
             case 2:
                 if (!Ask_155  &&  StAll) {    //  если это первый вопрос, и в тексте есть определенный формат...
                         T_pause -= new Date().getTime();                  // определение продолжительности паузы в вычислениях
                         Otvet_155 = AskYesNo ("•  ОПЕРАЦИИ  № 155, 157"+nomer_155+"\n"+
                             "------------------------------------------\n"+
                             "						        \n"+
                             "Преобразование  «_текст_  ›››  жирность»\n"+
                             " добавит в текст форматирование  полужирным шрифтом.\n"+
                             "Но это форматирование не будет уникальным.\n"+
                             "В тексте книги уже есть "+count_St+fragmenta[pad(count_St)]+" в этом формате.\n\n"+
                             "------------------------------------------------------------\n"+
                             "◊  Разрешить преобразование\n"+
                             "    «_текст_  ›››  жирность» ?");
                         T_pause += new Date().getTime();                  // определение продолжительности паузы в вычислениях
                         Ask_155 = true;     //  вопрос задан (индикация)
                         }
                 break;
             case 3:
                 if (!Ask_155  &&  EmStAll) {    //  если это первый вопрос, и в тексте есть определенный формат...
                         T_pause -= new Date().getTime();                  // определение продолжительности паузы в вычислениях
                         Otvet_155 = AskYesNo ("•  ОПЕРАЦИИ  № 155, 157"+nomer_155+"\n"+
                             "------------------------------------------\n"+
                             "						        \n"+
                             "Преобразование  «_текст_  ›››  жирный курсив»\n"+
                             " добавит в текст форматирование  полужирным курсивом.\n"+
                             "Но это форматирование не будет уникальным.\n"+
                             "В тексте книги уже есть "+count_EmSt+fragmenta[pad(count_EmSt)]+" в этом формате.\n\n"+
                             "------------------------------------------------------------\n"+
                             "◊  Разрешить преобразование\n"+
                             "    «_текст_  ›››  жирный курсив» ?");
                         T_pause += new Date().getTime();                  // определение продолжительности паузы в вычислениях
                         Ask_155 = true;     //  вопрос задан (индикация)
                         }
             }
         return  Otvet_155;
         }

         // _П_о_д_ч_е_р_к_и_в_а_н_и_е_ _в_ _п_о_л_у_ж_и_р_н_о_с_т_ь_
// пробел  +  (знак/буква)  +  _  +  (знак/буква/пробел  +  _  +  .................    +  _  +  знак/буква/пробел  +  _)  +  (знак/буква)  +  пробел    ›››
//      ›››    пробел  +  (знак/буква)  +  <STRONG>  +  фрагмент без подчеркиваний  +  </STRONG>  +  (знак/буква)  +  пробел
// * Если в тексте идут несколько таких блоков подряд, то они обрабатываются все вместе
// Исключения:   ряд блоков из одной буквы (_а_)
//            1. Поиск фрагментов
 var re156 = new RegExp("(^|\\\s|"+nbspChar+"|>)["+Z1+"]{0,2}(([А-яA-Za-zЁё0-9]["+Z3+"]{0,4}_(["+Z3+"]{0,4}[А-яA-Za-zЁё0-9"+Z3+"]["+Z3+"]{0,4}_){0,}(["+Z3+"]{0,4}[А-яA-Za-zЁё0-9"+Z3+"]){0,1})|(([А-яA-Za-zЁё0-9"+Z1+"]["+Z1+"]{0,2}){0,1}(_["+Z1+"]{0,2}[А-яA-Za-zЁё0-9"+Z1+"]["+Z1+"]{0,2}){0,}_[А-яA-Za-zЁё0-9](["+Z3+"]{0,4}_["+Z3+"]{0,4}[А-яA-Za-zЁё0-9"+Z3+"]){0,}(["+Z3+"]{0,4}_){0,1}))(((["+Z3+"]{0,4}(\\\-|\\\s|"+nbspChar+")["+Z1+"]{0,2})|(\\\-|\\\s|"+nbspChar+")[А-яA-Za-zЁё0-9—–\\\-](\\\-|\\\s|"+nbspChar+"))(([А-яA-Za-zЁё0-9]["+Z3+"]{0,4}_(["+Z3+"]{0,4}[А-яA-Za-zЁё0-9"+Z3+"]["+Z3+"]{0,4}_){0,}(["+Z3+"]{0,4}[А-яA-Za-zЁё0-9"+Z3+"]){0,1})|(([А-яA-Za-zЁё0-9"+Z1+"]["+Z1+"]{0,2}){0,1}(_["+Z1+"]{0,2}[А-яA-Za-zЁё0-9"+Z1+"]["+Z1+"]{0,2}){0,}_[А-яA-Za-zЁё0-9](["+Z3+"]{0,4}_["+Z3+"]{0,4}[А-яA-Za-zЁё0-9"+Z3+"]){0,}(["+Z3+"]{0,4}_){0,1}))){0,}(?=["+Z3+"]{0,4}(<|\\\s|"+nbspChar+"|$))","g");
//  * коротко:   А_(ш_)*ш? || ш?(_ш)*_А(_ш)*_?   , где А- буква/цифра, ш- буква/цифра/знак.   Плюс повторы этого же выражения через пробел, или через букву/тире с пробелами
 var m156 = [];
//            2. Первое преобразование фрагментов (добавление формата полужирности)
 var re156_2 = new RegExp("^(\\\s|"+nbspChar+"|>){0,1}(["+Z1+"]{0,2})(.{1,}?)$","g");
 var re156_2ex = new RegExp("^(\\\s|"+nbspChar+"|>){0,1}["+Z1+"]{0,2}_(["+Z1+"]{0,2}[А-яA-Za-zЁё0-9]["+Z3+"]{0,4})_((["+Z3+"]{0,4}(\\\s|"+nbspChar+")["+Z1+"]{0,2})_(["+Z1+"]{0,2}[А-яA-Za-zЁё0-9]["+Z3+"]{0,4})_){0,}$","g"); // искл.: _а_  ;  _а_ _а_
 switch (_f_o_r_m_a_t_) {
     case 1:  var re156_2_ = "$1$2<EM>$3</EM>";  break;
     case 2:  var re156_2_ = "$1$2<STRONG>$3</STRONG>";  break;
     case 3:  var re156_2_ = "$1$2<STRONG><EM>$3</EM></STRONG>";
     }
//            3. Ещё одно преобразование фрагментов (удаление знаков подчеркивания)
 var re156_3 = new RegExp("_","g");
//            4. Возвращение фрагментов в строку проходит без участия рег. выражений
//            Счетчик
 var count_156 = 0;
//            Выполненная операция в строке
 var if_156 = false;

         //  Функция допуска к операции №156
 var Otvet_156 = true;    //  разрешение на проведение операции
 var Ask_156 = false;   //  вопрос о разрешении пока не задан
 var nomer_156 = "Я  № 156";   //  добавление номера

 function Dopusk_156() {
         if (_f_o_r_m_a_t_ == _bukva_  ||  _bukva_== 4)  { nomer_156 = "И  № 156, 158"; }
         switch (_f_o_r_m_a_t_) {
             case 0:
                 Otvet_156 = false;
                 Ask_156 = true;
             case 1:
                 if (!Ask_156  &&  EmAll) {    //  если это первый вопрос, и в тексте есть определенный формат...
                         T_pause -= new Date().getTime();                  // определение продолжительности паузы в вычислениях
                         Otvet_156 = AskYesNo ("•  ОПЕРАЦИ"+nomer_156+"\n"+
                             "------------------------------------------\n"+
                             "						        \n"+
                             "Преобразование  «т_е_к_с_т  ›››  курсив»\n"+
                             " добавит в текст форматирование  курсивным шрифтом.\n"+
                             "Но это форматирование не будет уникальным.\n"+
                             "В тексте книги уже есть "+count_Em+fragmenta[pad(count_Em)]+" в этом формате.\n\n"+
                             "------------------------------------------------------------\n"+
                             "◊  Разрешить преобразование\n"+
                             "    «т_е_к_с_т  ›››  курсив» ?");
                         T_pause += new Date().getTime();                  // определение продолжительности паузы в вычислениях
                         Ask_156 = true;     //  вопрос задан (индикация)
                         }
                 break;
             case 2:
                 if (!Ask_156  &&  StAll) {    //  если это первый вопрос, и в тексте есть определенный формат...
                         T_pause -= new Date().getTime();                  // определение продолжительности паузы в вычислениях
                         Otvet_156 = AskYesNo ("•  ОПЕРАЦИ"+nomer_156+"\n"+
                             "------------------------------------------\n"+
                             "						        \n"+
                             "Преобразование  «т_е_к_с_т  ›››  жирность»\n"+
                             " добавит в текст форматирование  полужирным шрифтом.\n"+
                             "Но это форматирование не будет уникальным.\n"+
                             "В тексте книги уже есть "+count_St+fragmenta[pad(count_St)]+" в этом формате.\n\n"+
                             "------------------------------------------------------------\n"+
                             "◊  Разрешить преобразование\n"+
                             "    «т_е_к_с_т  ›››  жирность» ?");
                         T_pause += new Date().getTime();                  // определение продолжительности паузы в вычислениях
                         Ask_156 = true;     //  вопрос задан (индикация)
                         }
                 break;
             case 3:
                 if (!Ask_156  &&  EmStAll) {    //  если это первый вопрос, и в тексте есть определенный формат...
                         T_pause -= new Date().getTime();                  // определение продолжительности паузы в вычислениях
                         Otvet_156 = AskYesNo ("•  ОПЕРАЦИ"+nomer_156+"\n"+
                             "------------------------------------------\n"+
                             "						        \n"+
                             "Преобразование  «т_е_к_с_т  ›››  жирный курсив»\n"+
                             " добавит в текст форматирование  полужирным курсивом.\n"+
                             "Но это форматирование не будет уникальным.\n"+
                             "В тексте книги уже есть "+count_EmSt+fragmenta[pad(count_EmSt)]+" в этом формате.\n\n"+
                             "------------------------------------------------------------\n"+
                             "◊  Разрешить преобразование\n"+
                             "    «т_е_к_с_т  ›››  жирный курсив» ?");
                         T_pause += new Date().getTime();                  // определение продолжительности паузы в вычислениях
                         Ask_156 = true;     //  вопрос задан (индикация)
                         }
                 break;
             }
       return  Otvet_156;
       }

// _Подчеркивание_в_курсив_
// пробел  +  (знак)  +  _  +  знаки/буквы  +  (_  +  .................    +  _  +  знаки/буквы)  +  _  +  (знак)  +  пробел    ›››
//      ›››    пробел  +  (знак)  +  <EM>  +  фрагмент без подчеркиваний  +  </EM>  +  (знак)  +  пробел
// * Если в тексте идут несколько таких блоков подряд, то они обрабатываются все вместе
// Исключения:   ряд блоков из одной буквы (_а_)
//            1. Поиск фрагментов
 var re157 = new RegExp("(^|\\\s|"+nbspChar+"|>)["+Z1+"]{0,2}_(["+Z1+"]{0,2}[А-яA-Za-zЁё0-9]{1,}["+Z3+"]{0,4}_){1,}(["+Z3+"]{0,4}(\\\s|"+nbspChar+")["+Z1+"]{0,2}_(["+Z1+"]{0,2}[А-яA-Za-zЁё0-9]{1,}["+Z3+"]{0,4}_){1,}){0,}(?=["+Z3+"]{0,4}(<|\\\s|"+nbspChar+"|$))","g");
 var m157 = [];
//            2. Первое преобразование фрагментов (добавление формата курсив)
 var re157_2 = new RegExp("^([^_]{0,})_(.{1,}?)_$","g");
 var re157_2ex = re156; // искл.: _а_   ;  _а_ _а_  ;  _а_а_а_  ;  ...и т.п.
 switch (_format_) {
     case 1:  var re157_2_ = "$1<EM>$2</EM>";  break;
     case 2:  var re157_2_ = "$1<STRONG>$2</STRONG>";  break;
     case 3:  var re157_2_ = "$1<STRONG><EM>$2</EM></STRONG>";
     }
//            3. Второе преобразование фрагментов (удаление знаков подчеркивания)
 var re157_3 = new RegExp("_(["+Z3+"]{0,4}(\\\s|"+nbspChar+")["+Z1+"]{0,2})_","g");
 var re157_3_ = "$1";
//            * еще одно преобразование фрагментов (замена оставшихся знаков подчеркивания на пробелы) производится без заготовок рег. выражений
//            4. Возвращение фрагментов в строку проходит без участия рег. выражений
//            Счетчик
 var count_157 = 0;

// _одна оторванная буква_
// пробел  +  (знак)  +  _  +  (знак)  +  буква  +  (знак)  +  _  +  (знак)  +  пробел    ›››    в курсив или жирность
// * Если в тексте идут несколько таких блоков подряд, то они обрабатываются все вместе
// Исключение:   если рядом есть знак подчеркивания
//            1. Поиск фрагментов
 var re158 = new RegExp("(^|(^[^_]{0,1}|[^_]{2})(\\\s|"+nbspChar+")|>)(["+Z1+"]{0,2})_(["+Z1+"]{0,2}[А-яA-Za-zЁё0-9]["+Z3+"]{0,4})_((["+Z3+"]{0,4}(\\\s|"+nbspChar+")["+Z1+"]{0,2})_(["+Z1+"]{0,2}[А-яA-Za-zЁё0-9]["+Z3+"]{0,4})_){0,}(?=["+Z3+"]{0,4}(<|(\\\s|"+nbspChar+")([^_]{2}|[^_]{0,1}$)|$))","g");
 var m158 = [];
//            2. Первое преобразование фрагментов (добавление формата курсив/жирность)
 var re158_2 = new RegExp("^([^_]{0,})(.{1,}?)$","g");
 var re158_2_St = "$1<STRONG>$2</STRONG>";
 var re158_2_Em = "$1<EM>$2</EM>";
 var re158_2_EmSt = "$1<STRONG><EM>$2</EM></STRONG>";
//            3. Ещё одно преобразование фрагментов (удаление знаков подчеркивания)
 var re158_3 = new RegExp("_","g");
//            4. Возвращение фрагментов в строку проходит без участия рег. выражений
//            Счетчики
 var count_158em = 0;
 var count_158st = 0;
 var count_158emst = 0;
//            Индикаторы
 var BI_158 = "";   //  выбор для всего текста
 var EmSt_158 = "";   //  выбор для одного фрагмента

         //  Функция допуска к операции №156
 var Otvet_158 = true;    //  разрешение на проведение операции
 var Ask_158 = false;   //  вопрос о разрешении пока не задан

 function Dopusk_158() {
         if (_bukva_ == _format_  &&  _bukva_ == _f_o_r_m_a_t_)
                 if (Ask_156)  Otvet_158 = Dopusk_156()  ||  Dopusk_155();
                     else  Otvet_158 = Dopusk_155()  ||  Dopusk_156();
             else  if (_bukva_ == _format_)  Otvet_158 = Dopusk_155();
                 else  if (_bukva_ == _f_o_r_m_a_t_)  Otvet_158 = Dopusk_156();
                     else  if (_bukva_ != 4)
                             switch (_bukva_) {
                                 case 0:
                                     Otvet_158 = false;
                                     Ask_158 = true;
                                 case 1:
                                     if (!Ask_158  &&  EmAll) {    //  если это первый вопрос, и в тексте есть определенный формат...
                                             T_pause -= new Date().getTime();                  // определение продолжительности паузы в вычислениях
                                             Otvet_158 = AskYesNo ("•  ОПЕРАЦИЯ №158\n"+
                                                 "------------------------------------------\n"+
                                                 "						        \n"+
                                                 "Преобразование  «_буква_  ›››  курсив»\n"+
                                                 " добавит в текст форматирование  курсивным шрифтом.\n"+
                                                 "Но это форматирование не будет уникальным.\n"+
                                                 "В тексте книги уже есть "+count_Em+fragmenta[pad(count_Em)]+" в этом формате.\n\n"+
                                                 "------------------------------------------------------------\n"+
                                                 "◊  Разрешить преобразование\n"+
                                                 "    «_буква_  ›››  курсив» ?");
                                             T_pause += new Date().getTime();                  // определение продолжительности паузы в вычислениях
                                             Ask_158 = true;     //  вопрос задан (индикация)
                                             }
                                     break;
                                 case 2:
                                     if (!Ask_158  &&  StAll) {    //  если это первый вопрос, и в тексте есть определенный формат...
                                             T_pause -= new Date().getTime();                  // определение продолжительности паузы в вычислениях
                                             Otvet_158 = AskYesNo ("•  ОПЕРАЦИЯ №158\n"+
                                                 "------------------------------------------\n"+
                                                 "						        \n"+
                                                 "Преобразование  «_буква_  ›››  жирность»\n"+
                                                 " добавит в текст форматирование  полужирным шрифтом.\n"+
                                                 "Но это форматирование не будет уникальным.\n"+
                                                 "В тексте книги уже есть "+count_St+fragmenta[pad(count_St)]+" в этом формате.\n\n"+
                                                 "------------------------------------------------------------\n"+
                                                 "◊  Разрешить преобразование\n"+
                                                 "    «_буква_  ›››  жирность» ?");
                                             T_pause += new Date().getTime();                  // определение продолжительности паузы в вычислениях
                                             Ask_158 = true;     //  вопрос задан (индикация)
                                             }
                                     break;
                                 case 3:
                                     if (!Ask_158  &&  EmStAll) {    //  если это первый вопрос, и в тексте есть определенный формат...
                                             T_pause -= new Date().getTime();                  // определение продолжительности паузы в вычислениях
                                             Otvet_158 = AskYesNo ("•  ОПЕРАЦИЯ №158\n"+
                                                 "------------------------------------------\n"+
                                                 "						        \n"+
                                                 "Преобразование  «_буква_  ›››  жирный курсив»\n"+
                                                 " добавит в текст форматирование  полужирным курсивом.\n"+
                                                 "Но это форматирование не будет уникальным.\n"+
                                                 "В тексте книги уже есть "+count_EmSt+fragmenta[pad(count_EmSt)]+" в этом формате.\n\n"+
                                                 "------------------------------------------------------------\n"+
                                                 "◊  Разрешить преобразование\n"+
                                                 "    «_буква_  ›››  жирный курсив» ?");
                                             T_pause += new Date().getTime();                  // определение продолжительности паузы в вычислениях
                                             Ask_158 = true;     //  вопрос задан (индикация)
                                             }
                                 }
       return  Otvet_158;
       }


       // Лишние знаки в начале и конце строки

// Лишние знаки препинания в начале строки
// Исключения:   Смайлы из ";"
//  * Двоеточие полностью исключено — кроме использования в смайлах, это может быть и своеобразный маркер
 var re172 = new RegExp("^("+sIB+"){0,1}([\\\.;])(\\\s|"+nbspChar+"|$)","g");
 var re172_ = "$1";
 var count_172 = 0;
	// без тегов
	 var re172_0 = new RegExp("^([\\\.;])(\\\s|"+nbspChar+"|$)","g");
	 var re172_0_ = "";

//  Лишняя запятая в начале строки
 var re173 = new RegExp("^("+sIB+"){0,1}(,)(\\\s|"+nbspChar+"){0,1}","g");
 var re173_ = "$1";
	// без тегов
	 var re173_0 = new RegExp("^(,)(\\\s|"+nbspChar+"){0,1}","g");
	 var re173_0_ = "";
// используется счетчик №172

//  Лишняя точка в начале строки
// Исключения:   |  .ру  |  .рф  |  .РУ  |  .Ру  |
 var re174 = new RegExp("^("+sIB+"){0,1}(\\\.)(?![A-Za-z0-9\\\.]|(ру|рф|Ру|РУ)([^А-я]|$))","g");
 var re174_ = "$1";
	// без тегов
	 var re174_0 = new RegExp("^(\\\.)(?![A-Za-z0-9\\\.]|(ру|рф|Ру|РУ)([^А-я]|$))","g");
	 var re174_0_ = "";
// используется счетчик №172


       // Лишние знаки в середине строки

//  Пробел  +  лишняя точка
// Исключения:   |  .ру  |  .рф  |
 var re180 = new RegExp("(\\\s|"+nbspChar+")\\\.([а-пс-яё]|р(?![уф]([^А-я]|$)))","g");
 var re180_ = "$1$2";
 var count_180 = 0;

//  Знак + пробел  +  лишняя точка
// Исключения:   .РУ  |  .Ру  |
 var re181 = new RegExp("([…\\\.,:;\\\?!\\\)\\\]—–\\\-])(\\\s|"+nbspChar+")\\\.([А-ПС-ЯЁ]|Р(?![Уу]([^А-я]|$)))","g");
 var re181_ = "$1$2$3";
// используется счетчик №180

//  Знак + пробел  +  лишняя запятая
 var re182 = new RegExp("([…\\\.,:;\\\?!\\\)\\\]—–\\\-])(\\\s|"+nbspChar+"),([А-яA-Za-zЁё])","g");
 var re182_ = "$1$2$3";
 var count_182 = 0;

// ---------------------------------------------------------------
/// СТАНДАРТИЗАЦИЯ ТЕГОВ  :  операции  № 2хх
// ---------------------------------------------------------------

       // Объединение
       //  * исключения:   |   скобки   |  кавычки   |  !  |  ?  |

// Объединение курсива/жирности
 var re201 = new RegExp("</(EM|STRONG)>(([\\\s\\\-–—\\\.,;:…]|"+nbspChar+"){0,4})<\\1>","g");
 var re201_ = "$2";
 var count_201 = 0;

// Объединение верхнего/нижнего индекса
 var re202 = new RegExp("</(SUB|SUP)>(\\\s|"+nbspChar+"){0,1}<\\1>","g");
 var re202_ = "$2";
 var count_202 = 0;


// Удаление ссылок без текста
 var re203 = new RegExp("<A\\\s[^>]{1,}>([\\\.,;]{0,1})</A>","g");
 var re203_ = "$1";
 var count_203 = 0;

// Удаление пустых тегов
 var re204 = new RegExp("<([^/][^>\\\s]{0,})(\\\s[^>]{1,}){0,1}></\\1>","g");
 var re204_ = "";
 var count_204 = 0;

// Удаление курсива/жирности 1-2 символов знаков препинания
// Исключения:    |  (!)  |  «?»  |   и т.п.
 var re205 = new RegExp("<(EM|STRONG)>([\\\-–—_\\\.…,;:!\\\?/~\\\[\\\]\\\(\\\)„“«»\\\"’'%]{0,2})</\\1>","g");
 var re205_ = "$2";
 var count_205 = 0;


       //  Переплетения тегов курсива/жирности
       //  * распутаются не все
       //  ** стартовая формула не для ускорения вычислений, а для поиска сплетения

// Стыки   </EM></STRONG>...<EM>   и   </EM>...<STRONG><EM>
 var re215s = new RegExp("(</EM></STRONG>([\\\s\\\-–—\\\.,;:…]|"+nbspChar+"){0,4}<EM>)|(</EM>([\\\s\\\-–—\\\.,;:…]|"+nbspChar+"){0,4}<STRONG><EM>)","g");
 var re215 = new RegExp("<STRONG><EM>([^<>]{1,})</EM></STRONG>","g");
 var re215_ = "<EM><STRONG>$1</STRONG></EM>";
 var count_215 = 0;
         //  далее индивидуальный повтор № 201

// Стыки   </STRONG></EM>...<STRONG>   и   </STRONG>...<EM><STRONG>
 var re216s = new RegExp("(</STRONG></EM>([\\\s\\\-–—\\\.,;:…]|"+nbspChar+"){0,4}<STRONG>)|(</STRONG>([\\\s\\\-–—\\\.,;:…]|"+nbspChar+"){0,4}<EM><STRONG>)","g");
 var re216 = new RegExp("<EM><STRONG>([^<>]{1,})</STRONG></EM>","g");
 var re216_ = "<STRONG><EM>$1</EM></STRONG>";
// используется счетчик №215
         //  далее индивидуальный повтор № 201


       // Стандартное ударение (&#769;) для выделенной буквы
       //  Исключения:  |  Буквица  |  ё  |  заглавная буква без выделения тегами (в 50% случаях — это результат ошибочного пропуска пробела)  |

// Буква  +  выделенная строчная    ›››   Буква  +  строчная  +  знак ударения
 var re220s = new RegExp(">[аеиоуыэюя]<","g");  //  стартовая формула для № 220, 221
 var re220 = new RegExp("([А-яЁё])(<EM><STRONG>([аеиоуыэюя])</STRONG></EM>|<STRONG><EM>([аеиоуыэюя])</EM></STRONG>|<STRONG>([аеиоуыэюя])</STRONG>|<EM>([аеиоуыэюя])</EM>)","g");
 var re220_ = "$1$3$4$5$6"+Ud;
 var count_220 = 0;

// выделенная строчная  +  буква    ›››   строчная  +  знак ударения  +  буква
 var re221 = new RegExp("(<EM><STRONG>([аеиоуыэюя])</STRONG></EM>|<STRONG><EM>([аеиоуыэюя])</EM></STRONG>|<STRONG>([аеиоуыэюя])</STRONG>|<EM>([аеиоуыэюя])</EM>)([а-яё])","g");
 var re221_ = "$2$3$4$5"+Ud+"$6";

// строчная  +  выделенная Заглавная    ›››   строчная  +  Заглавная  +  спец. знак
// * FalseSim — временно выполняет обязанности ударения
 var re222s = new RegExp(">[АЕИОУЫЭЮЯ]<","g");
 var re222 = new RegExp("([а-яё])(<EM><STRONG>([АЕИОУЫЭЮЯ])</STRONG></EM>|<STRONG><EM>([АЕИОУЫЭЮЯ])</EM></STRONG>|<STRONG>([АЕИОУЫЭЮЯ])</STRONG>|<EM>([АЕИОУЫЭЮЯ])</EM>)","g");
 var re222_ = "$1$3$4$5$6"+FalseSim;

//  Заглавная  +  спец. знак    ›››   строчная  +  знак ударения      (продолжение №222)
 var re223 = new RegExp("[АЕИОУЫЭЮЯ](?="+FalseSim+")","g");    //  Для извлечение заглавных букв
 var m223 = [];                 //   Массив для этих букв, в котором будет производиться понижение регистра
 var re224 = new RegExp("[АЕИОУЫЭЮЯ]"+FalseSim,"");     //  Для добавление букв с пониженным регистром (модификатора "g" здесь нет, поэтому замена будет происходить по одной букве)

//   ----------------------- конец для "Стандартное ударение (&#769;) для выделенной буквы" ---------------------


//  Нормализация: пробел+знак на Окраине курсива/жирности
 var re241 = new RegExp("("+sIB+")([…\\\.,:;\\\?!\\\(\\\)\\\[\\\]«„“»”\\\"—–\\\-]{1,2})(\\\s|"+nbspChar+")|(\\\s|"+nbspChar+")([…\\\.,:;\\\?!\\\(\\\)\\\[\\\]«„“»”\\\"—–\\\-]{1,2})("+fIB+")","g");
 var re241_ = "$2$3$1$6$4$5";
 var count_241 = 0;


       // Выделение и снятие выделения со скобок и кавычек на окраине тега
       // (Формула не будет реагировать, когда в нужном выделении стоит посторонний тег)

// Снятие выделения с одиночной квадратной скобки на окраине
 var re250 = new RegExp("("+sIB+")([^А-яA-Za-zЁё0-9\\\[\\\]]{0,3})(\\\[)([^<\\\[\\\]]{0,})("+fIB+")|("+sIB+")([^<\\\[\\\]]{0,})(\\\])([^А-яA-Za-zЁё0-9\\\[\\\]]{0,3})("+fIB+")","g");
 var re250_ = "$2$3$1$4$5$6$7$10$8$9";
 var count_250 = 0;

// Выделение пары квадратных скобок
 var re251 = new RegExp("(\\\[)([^А-яA-Za-zЁё0-9\\\[\\\]]{0,3})("+sIB+")([^<\\\[\\\]]{0,})("+fIB+")([^А-яA-Za-zЁё0-9\\\[\\\]]{0,3})(\\\])","g");
 var re251_ = "$3$1$2$4$6$7$5";
 var count_251 = 0;


// Снятие выделения с одиночной круглой скобки на окраине
 var re252 = new RegExp("("+sIB+")([^А-яA-Za-zЁё0-9\\\(\\\)]{0,3})(\\\()([^<\\\(\\\)]{0,})("+fIB+")|("+sIB+")([^<\\\(\\\)]{0,})(\\\))([^А-яA-Za-zЁё0-9\\\(\\\)]{0,3})("+fIB+")","g");
 var re252_ = "$2$3$1$4$5$6$7$10$8$9";
// используется счетчик №250

// Выделение пары круглых скобок
 var re253 = new RegExp("(\\\()([^А-яA-Za-zЁё0-9\\\(\\\)]{0,3})("+sIB+")([^<\\\(\\\)]{0,})("+fIB+")([^А-яA-Za-zЁё0-9\\\(\\\)]{0,3})(\\\))","g");
 var re253_ = "$3$1$2$4$6$7$5";
// используется счетчик №251


// Выделение пары угловых кавычек
// * без снятия выделения с непарной кавычки (иначе ошибки в "«прямая_речь, — не_выделенные_слова_персонажа, — прямая_речь»", или в случае, когда выделенный окавыченный текст растягивается на несколько абзацев)
 var re255 = new RegExp("(«)([…\\\.„“\\\"\\\-–\\\(\\\[]{0,3})("+sIB+")([^<«»]{0,})(("+fIB+")([…\\\.,:;\\\?!“”\\\"\\\-–\\\)\\\]]{0,4})(»)|(»)([…\\\.,:;\\\?!\\\-–\\\)\\\]]{0,4})("+fIB+"))","g");
 var re255_ = "$3$1$2$4$7$8$6$9$10$11";
 var count_255 = 0;
	 var re256 = new RegExp("("+sIB+")([…\\\.\\\-–\\\(\\\[]{0,3})(«)([^<«»]{0,})("+fIB+")([…\\\.,:;\\\?!“”\\\"\\\-–\\\)\\\]]{0,4})(»)","g");
	 var re256_ = "$1$2$3$4$6$7$5";


// Выделение запятой и точки+запятая в конце выделения
 var re260 = new RegExp("("+fIB+")(,|\\\.,)","g");
 var re260_ = "$2$1";
 var count_260 = 0;


// Снятие выделения со сноски на окраине выделения
 var re270 = new RegExp("("+NC+")("+fIB+")|("+sIB+")("+NC+")","g");
 var re270_ = "$2$1$4$3";
 var count_270 = 0;

// ---------------------------------------------------------------
/// РЕЖИМЫ  :  операции  № 3хх
// ---------------------------------------------------------------

       //  Дефис ››› Тире (R_Def = false)

// Буква + дефис + пробел   ›››   Буква + тире + пробел
 var re301 = new RegExp("([А-яA-Za-zЁё“»”\\\"])("+fIB+"){0,1}\\\-("+fIB+"){0,1}(\\\s|"+nbspChar+")","g");
 var re301_ = "$1$2—$3 ";
 var count_301 = 0;
	// без тегов
	 var re301_0 = new RegExp("([А-яA-Za-zЁё“»”\\\"])\\\-(\\\s|"+nbspChar+")","g");
	 var re301_0_ = "$1— ";

//  Пробел + дефис + буква   ›››   Пробел + тире + буква
 var re302 = new RegExp("(\\\s|"+nbspChar+")("+sIB+"){0,1}\\\-("+sIB+"){0,1}([А-яA-Za-zЁё«„“\\\"])","g");
 var re302_ = " $2—$3$4";
	// без тегов
	 var re302_0 = new RegExp("(\\\s|"+nbspChar+")\\\-([А-яA-Za-zЁё«„“\\\"])","g");
	 var re302_0_ = " —$2";
// используется счетчик №301


       //  Тире ››› Дефис (R_Tire = false)

// Буква + тире + пробел   ›››   Буква + дефис + пробел
 var re310 = new RegExp("([А-яA-Za-zЁё“»”\\\"])("+fIB+"){0,1}—("+fIB+"){0,1}(\\\s|"+nbspChar+")","g");
 var re310_ = "$1$2-$3 ";
 var count_310 = 0;
	// без тегов
	 var re310_0 = new RegExp("([А-яA-Za-zЁё“»”\\\"])—(\\\s|"+nbspChar+")","g");
	 var re310_0_ = "$1- ";

//  Пробел + тире + буква   ›››   Пробел + дефис + буква
 var re311 = new RegExp("(\\\s|"+nbspChar+")("+sIB+"){0,1}—("+sIB+"){0,1}([А-яA-Za-zЁё«„“\\\"])","g");
 var re311_ = " $2-$3$4";
	// без тегов
	 var re311_0 = new RegExp("(\\\s|"+nbspChar+")—([А-яA-Za-zЁё«„“\\\"])","g");
	 var re311_0_ = " -$2";
// используется счетчик №310

//  Буква + тире + буква   ›››   Буква + дефис + буква
 var re312 = new RegExp("([А-яA-Za-zЁё“»”\\\"])("+aIB+"){0,1}—(?=("+aIB+"){0,1}[А-яA-Za-zЁё«„“\\\"])","g");
 var re312_ = "$1$2-";
 var count_312 = 0;
	// без тегов
	 var re312_0 = new RegExp("([А-яA-Za-zЁё“»”\\\"])—(?=[А-яA-Za-zЁё«„“\\\"])","g");
	 var re312_0_ = "$1-";


       //  К.тире ››› Дефис (R_KTi = true)

// Не_цифра + к/тире + не_цифра   ›››   Не_цифра + дефис + не_цифра
 var re320 = new RegExp("(^|[^0-9])("+aIB+"){0,1}–(?=("+aIB+"){0,1}([^0-9]|$))","g");
 var re320_ = "$1$2-";
 var count_320 = 0;
	// без тегов
	 var re320_0 = new RegExp("(^|[^0-9])–(?=([^0-9]|$))","g");
	 var re320_0_ = "$1-";


       //  К.тире ››› Тире (R_KTi = false)

// Не_цифра + к/тире + не_цифра   ›››   Не_цифра + тире + не_цифра
 var re321 = new RegExp("(^|[^0-9])("+aIB+"){0,1}–(?=("+aIB+"){0,1}([^0-9]|$))","g");
 var re321_ = "$1$2—";
 var count_321 = 0;
	// без тегов
	 var re321_0 = new RegExp("(^|[^0-9])–(?=([^0-9]|$))","g");
	 var re321_0_ = "$1—";


         //  Сохранение длинного тире между названиями

//      "Москва—Кассиопея"
 var reNm1s = new RegExp("[а-яa-zё]([—][\\\s"+nbspChar+"]{0,1}|[\\\s"+nbspChar+"][—])[А-ЯA-ZЁ]","g");
 var reNm1 = new RegExp("(^|[^А-яA-Za-zЁё])([А-ЯA-ZЁ][а-яa-zё]{1,})([—][\\\s"+nbspChar+"]{0,1}|[\\\s"+nbspChar+"][—])(?=[А-ЯA-ZЁ][а-яa-zё]{1,}([^А-яA-Za-zЁё]|$))","g");
 var reNm1_ = "$1$2"+FalseTire;
 var countNm = 0;

// ---------------------------------------------------------------
/// ПУНКТУАЦИЯ (без тире)  :  операции  № 4хх
// ---------------------------------------------------------------

// * Формулы записаны проще из-за того, что многие теги курсива и жирности перемещены или удалены, и в некоторых местах они уже быть не могут

       //  Начало строки

// Кавычки в начале строки
 var re401 = new RegExp("^([«„»“”\\\"]…{0,1})(\\\s|"+nbspChar+")","g");
 var re401_ = "$1";
 var count_401 = 0;

// Многоточие в начале строки
 var re402 = new RegExp("^…(\\\s|"+nbspChar+")(?=("+sIB+"){0,1}[«„\\\"А-яA-Za-zЁё0-9])","g");
 var re402_ = "…";
 var count_402 = 0;
	// без тегов
 var re402_0 = new RegExp("^…(\\\s|"+nbspChar+")(?=[«„\\\"А-яA-Za-zЁё0-9])","g");
	 var re402_0_ = "…";


       //  Конец строки

// Кавычки в конце строки
 var re410 = new RegExp("(\\\s|"+nbspChar+")(…{0,1}[«„»“”\\\"])$","g");
 var re410_ = "$2";
 var count_410 = 0;

// Многоточие в конце строки
 var re411 = new RegExp("([А-яA-Za-zЁё0-9»\\\"])("+fIB+"){0,1}(\\\s|"+nbspChar+")…$","g");
 var re411_ = "$1$2…";
 var count_411 = 0;
	// без тегов
	 var re411_0 = new RegExp("([А-яA-Za-zЁё0-9»\\\"])(\\\s|"+nbspChar+")…$","g");
	 var re411_0_ = "$1…";


       //   Лишний пробел + знак

//  Лишний пробел  +  "."
//  Исключения:  |  .ru и т.п.  |  .RU и т.п.  |  .ру  |  .рф  |  .Ру  |  .РУ  |
 var re420 = new RegExp("(\\\s|"+nbspChar+")\\\.("+sIB+"){0,1}($|(?![A-Za-z]|(ру|рф|Ру|РУ)([^А-я]|$)))","g");
 var re420_ = ".$2$3";
 var count_420 = 0;
	// без тегов
	 var re420_0 = new RegExp("(\\\s|"+nbspChar+")\\\.($|(?![A-Za-z]|(ру|рф|Ру|РУ)([^А-я]|$)))","g");
	 var re420_0_ = ".$2";
   //  после результативной операции — повтор №150

//  Лишний пробел  +  ";"
//  Исключения: Смайлы
 var re421 = new RegExp("(\\\s|"+nbspChar+")(;)(("+sIB+"){0,1}[А-яA-Za-zЁё0-9«„\\\"][А-яA-Za-zЁё0-9,]|\\\s|"+nbspChar+"|$)","g");
 var re421_ = "$2$3";
	// без тегов
	 var re421_0 = new RegExp("(\\\s|"+nbspChar+")(;)([А-яA-Za-zЁё0-9«„\\\"][А-яA-Za-zЁё0-9,]|\\\s|"+nbspChar+"|$)","g");
	 var re421_0_ = "$2$3";
// используется счетчик №420

//  Лишний пробел  +  ":"
//  Исключения: Смайлы, деление
 var re421a = new RegExp("([А-яA-Za-zЁё\\\)\\\]«„“»”\\\"])("+fIB+"){0,1}(\\\s|"+nbspChar+")(:)(("+sIB+"){0,1}[А-яA-Za-zЁё0-9«„\\\"][А-яA-Za-zЁё0-9,]|\\\s|"+nbspChar+"|$)","g");
 var re421a_ = "$1$2$4$5";
	// без тегов
	 var re421a_0 = new RegExp("([А-яA-Za-zЁё\\\)\\\]«„“»”\\\"])(\\\s|"+nbspChar+")(:)([А-яA-Za-zЁё0-9«„\\\"][А-яA-Za-zЁё0-9,]|\\\s|"+nbspChar+"|$)","g");
	 var re421a_0_ = "$1$3$4";
// используется счетчик №420

//  Лишний пробел  +   |   !   |  ?  |
//  Исключение: использование этих знаков, как самостоятельное обозначение восклицания и вопроса без текста
 var re422 = new RegExp("([А-яA-Za-zЁё0-9\\\?!\\\(\\\)\\\[\\\]«„“»”\\\"])("+fIB+"){0,1}(\\\s|"+nbspChar+")(?=[!\\\?]([^A-Za-z]|$))","g");
 var re422_ = "$1$2";
	 var re422_0 = new RegExp("([А-яA-Za-zЁё0-9\\\?!\\\(\\\)\\\[\\\]«„“»”\\\"])(\\\s|"+nbspChar+")(?=[!\\\?]([^A-Za-z]|$))","g");
	 var re422_0_ = "$1";
// используется счетчик №420

//  Лишний пробел  +     )   ]   ,   »
 var re423 = new RegExp("(\\\s|"+nbspChar+")([\\\)\\\],»])","g");
 var re423_ = "$2";
// используется счетчик №420
   //  после результативной операции — повтор №150

// Лишний пробел  +  [сноска]
 var re424 = new RegExp("(\\\s|"+nbspChar+")("+NC+")","g");
 var re424_ = "$2";
 var count_424 = 0;

// Лишний пробел  +  многоточие
 var re425 = new RegExp("(\\\s|"+nbspChar+")…([\\\)\\\]»])","g");
 var re425_ = "…$2";
 var count_425 = 0;

// Лишний пробел  +  многоточие + пробел
 var re426 = new RegExp("([А-яA-Za-zЁё»\\\"])("+fIB+"){0,1}(\\\s|"+nbspChar+")…(\\\s|"+nbspChar+")","g");
 var re426_ = "$1$2…$4";
	// без тегов
	 var re426_0 = new RegExp("([А-яA-Za-zЁё»\\\"])(\\\s|"+nbspChar+")…(\\\s|"+nbspChar+")","g");
	 var re426_0_ = "$1…$3";
// используется счетчик №425


       //  Кавычки   |  "  |  »  |
       // * кавычка  =“=  бывает и правой, и левой

//  кавычки "»  +  знак  +  пропущенный пробел
//  исключения:   |  …текст  |  .текст  |
 var re431 = new RegExp("([\\\"»])("+fIB+"){0,1}([:;,\\\?!\\\)\\\]]|[\\\?!]\\\.\\\.)("+fIB+"){0,1}("+sIB+"){0,1}([А-яA-Za-zЁё])","g");
 var re431_ = "$1$2$3$4 $5$6";
 var count_431 = 0;
	// без тегов
	 var re431_0 = new RegExp("([\\\"»])([:;,\\\?!\\\)\\\]]|[\\\?!]\\\.\\\.)([А-яA-Za-zЁё])","g");
	 var re431_0_ = "$1$2 $3";

//  Лишний пробел  +  кавычка  +  знак
 var re432 = new RegExp("([А-яA-Za-zЁё]…{0,1})("+fIB+"){0,1}(\\\s|"+nbspChar+")([\\\"“”])([:;,\\\.\\\?!\\\)\\\]]|[\\\?!]\\\.\\\.)("+fIB+"){0,1}(\\\s|"+nbspChar+"|$)","g");
 var re432_ = "$1$2$4$5$6$7";
 var count_432 = 0;
	// без тегов
	 var re432_0 = new RegExp("([А-яA-Za-zЁё]…{0,1})(\\\s|"+nbspChar+")([\\\"“”])([:;,\\\.\\\?!\\\)\\\]]|[\\\?!]\\\.\\\.)(\\\s|"+nbspChar+"|$)","g");
	 var re432_0_ = "$1$3$4$5";

//  (Лишний пробел)  +  ошибочная кавычка  +  знак  +  пробел   ›››   обычная кавычка  +  знак  +  пробел
 var re433 = new RegExp("([А-яA-Za-zЁё][…“»]{0,1})(\\\s|"+nbspChar+"){0,1}([«„])([:;,\\\.\\\?!\\\)\\\]]|[\\\?!]\\\.\\\.)("+fIB+"){0,1}(\\\s|"+nbspChar+"|$)","g");
 var re433_ = "$1\"$4$5$6";
	// без тегов
	 var re433_0 = new RegExp("([А-яA-Za-zЁё][…“»]{0,1})(\\\s|"+nbspChar+"){0,1}([«„])([:;,\\\.\\\?!\\\)\\\]]|[\\\?!]\\\.\\\.)(\\\s|"+nbspChar+"|$)","g");
	 var re433_0_ = "$1\"$4$5";
// используется счетчик №432


       //  Знак  +  лишний пробел

//  "(",  "[",  "«",  "„"  +  (многоточие)  +  лишний пробел
 var re440 = new RegExp("([\\\(\\\[«„][…]{0,1})(\\\s|"+nbspChar+")(?=[^:;])","g");
 var re440_ = "$1";
 var count_440 = 0;

//  Сноска  +  лишний пробел
 var re441 = new RegExp("("+NC+")(\\\s|"+nbspChar+")([\\\.:\\\?!]|…(\\\s|"+nbspChar+"|[\\\)\\\]»]))","g");
 var re441_ = "$1$3";
 var count_441 = 0;


       //  Знак  +  пропущенный пробел

//  Точка  +  пропущенный пробел
// Искл.:   |  С.Т.А.Л.К.Е.Р.   |   file.NAME   |   .РУ   |   .Рф   |  код   |
 var re450= new RegExp("([а-яa-zё»]{2})("+fIB+"){0,1}(\\\.)("+fIB+"){0,1}("+sIB+"){0,1}([А-ПС-ЯЁ]|Р(?![Ууф]([^А-я]|$)))","g");
 var re450_ = "$1$2$3$4 $5$6";
 var count_450 = 0;
	// без тегов
	 var re450_0= new RegExp("([а-яa-zё»]{2})(\\\.)([А-ПС-ЯЁ]|Р(?![Ууф]([^А-я]|$)))","g");
	 var re450_0_ = "$1$2 $3";

// Искл.:   |  31.ХII.2024   |  код   |
 var re450a= new RegExp("([0-9])("+fIB+"){0,1}(\\\.)("+fIB+"){0,1}("+sIB+"){0,1}([А-ЯЁ][а-я])","g");
 var re450a_ = "$1$2$3$4 $5$6";
	// без тегов
	 var re450a_0= new RegExp("([0-9])(\\\.)([А-ЯЁ][а-я])","g");
	 var re450a_0_ = "$1$2 $3";
// используется счетчик №450

//  "?"/"!"  +  пропущенный пробел
// Искл.:   |   неполный электронный адрес   |
 var re451= new RegExp("([а-яa-zё])("+fIB+"){0,1}([\\\?!])("+fIB+"){0,1}("+sIB+"){0,1}([А-ЯЁ])","g");
 var re451_ = "$1$2$3$4 $5$6";
	// без тегов
	 var re451_0= new RegExp("([а-яa-zё])([\\\?!])([А-ЯЁ])","g");
	 var re451_0_ = "$1$2 $3";
// используется счетчик №450

//  ";" или ":" +  пропущенный пробел
// Исключения:  |  координата (А;b) (0;0)  |  &lt; и т.п.  |  счет 1:0  |  ход е2:е4  |  mail:Vasia  |  Большинство смайликов  |
 var re453= new RegExp("([А-яЁё»])("+fIB+"){0,1}([:;])("+fIB+"){0,1}("+sIB+"){0,1}([А-яA-Za-zЁё«„\\\"][А-яA-Za-zЁё,])","g");
 var re453_ = "$1$2$3$4 $5$6";
	// без тегов
	 var re453_0= new RegExp("([А-яЁё»])([:;])([А-яA-Za-zЁё«„\\\"][А-яA-Za-zЁё,])","g");
	 var re453_0_ = "$1$2 $3";
// используется счетчик №450

//  "," +  пропущенный пробел
// Исключения:  |  f(А,b)  |  3,14159  |
 var re454= new RegExp("([А-яЁё])("+fIB+"){0,1}(,)("+fIB+"){0,1}("+sIB+"){0,1}([А-яA-Za-zЁё«„])","g");
 var re454_ = "$1$2,$4 $5$6";
	// без тегов
	 var re454_0= new RegExp("([А-яЁё])(,)([А-яA-Za-zЁё«„])","g");
	 var re454_0_ = "$1, $3";
// используется счетчик №450

 var re454a= new RegExp("([0-9])("+fIB+"){0,1}(,)("+fIB+"){0,1}("+sIB+"){0,1}([А-яЁё«„])","g");
 var re454a_ = "$1$2,$4 $5$6";
	// без тегов
	 var re454a_0= new RegExp("([0-9])(,)([А-яЁё«„])","g");
	 var re454a_0_ = "$1, $3";
// используется счетчик №450

//  "?!."  +  пропущенный пробел
 var re455= new RegExp("([А-яA-Za-zЁё0-9»])("+fIB+"){0,1}([\\\?!][\\\?!\\\.]{2,4})("+fIB+"){0,1}("+sIB+"){0,1}([«„А-яA-ZЁё0-9])","g");
 var re455_ = "$1$2$3$4 $5$6";
	// без тегов
	 var re455_0= new RegExp("([А-яA-Za-zЁё0-9»])([\\\?!][\\\?!\\\.]{2,4})([«„А-яA-ZЁё0-9])","g");
	 var re455_0_ = "$1$2 $3";
// используется счетчик №450


       //  Пропущенный пробел  +  знак

//  Пропущенный пробел  +  "«" или "„"
 var re460= new RegExp("([А-яA-Za-zЁё:,\\\.\\\?!»]|[А-я>];)("+fIB+"){0,1}("+sIB+"){0,1}(«|„)("+sIB+"){0,1}([А-яA-Za-zЁё])","g");
 var re460_ = "$1$2 $3$4$5$6";
 var count_460 = 0;
	// без тегов
	 var re460_0= new RegExp("([А-яA-Za-zЁё:,\\\.\\\?!»]|[А-я>];)(«|„)([А-яA-Za-zЁё])","g");
	 var re460_0_ = "$1 $2$3";


       //  Сноски

//   [сноска]  +  кавычки    ›››    кавычки  +  [сноска]
 var re470 = new RegExp("("+NC+")("+sIB+"){0,1}([«„“»”\\\"])([\\\s\\\.,:;\\\?!\\\)\\\]—]|"+nbspChar+"|$)","g");
 var re470_ = "$3$1$2$4";
 var count_470 = 0;
	// без тегов
	 var re470_0 = new RegExp("("+NC+")([«„“»”\\\"])([\\\s\\\.,:;\\\?!\\\)\\\]—]|"+nbspChar+"|$)","g");
	 var re470_0_ = "$2$1$3";

// [сноска]  +  пропущенный пробел
 var re471 = new RegExp("("+NC+")("+sIB+"){0,1}([А-яЁёA-Za-z0-9\\\-—\\\(\\\[„«])","g");
 var re471_ = "$1 $2$3";
 var count_471 = 0;
	// без тегов
	 var re471_0 = new RegExp("("+NC+")([А-яЁёA-Za-z0-9\\\-—\\\(\\\[„«])","g");
	 var re471_0_ = "$1 $2";

// [сноска]  +  знак  +  пропущенный пробел
 var re472 = new RegExp("("+NC+")("+sIB+"){0,1}([\\\]\\\)\\\.,:;\\\?!»]{1,4})("+fIB+"){0,1}("+sIB+"){0,1}([«„А-яЁёA-Za-z0-9])","g");
 var re472_ = "$1$2$3$4 $5$6";
 var count_472 = 0;
	// без тегов
	 var re472_0 = new RegExp("("+NC+")([\\\]\\\)\\\.,:;\\\?!»]{1,4})([«„А-яЁёA-Za-z0-9])","g");
	 var re472_0_ = "$1$2 $3";

// ---------------------------------------------------------------
/// ТИРЕ и ДЕФИСЫ  :  операции  № 5хх
// ---------------------------------------------------------------

       // Короткое тире


       //  промежутки, даты

         //  дополнительные переменные
         var mesiaz = "январ[ье]|феврал[ье]|марте?|апрел[ье]|ма[йе]|июн[ье]|июл[ье]|августе?|сентябр[ье]|октябр[ье]|ноябр[ье]|декабр[ье]|весна|весной|летом?|осенью?|зима|зимой"; //  ("+mesiaz+")
         var Mesiaz = "[Яя]нвар[ье]|[Фф]еврал[ье]|[Мм]арте?|[Аа]прел[ье]|[Мм]а[йе]|[Ии]юн[ье]|[Ии]юл[ье]|[Аа]вгусте?|[Сс]ентябр[ье]|[Оо]ктябр[ье]|[Нн]оябр[ье]|[Дд]екабр[ье]|[Вв]есна|[Вв]есной|[Лл]етом?|[Оо]сенью?|[Зз]има|[Зз]имой"; // ("+Mesiaz+")
         var mesiaZA = "января|февраля|марта|апреля|мая|июня|июля|августа|сентября|октября|ноября|декабря|весны|лета|осени|зимы"; //  ("+mesiaZA+")
         var Natchalo = "[Нн]ачал[аое]|[Нн]ачалом|[Сс]ередин[ыае]|[Сс]ерединой|[Кк]онец|[Кк]онцом|[Кк]онц[ае]"; //  ("+Natchalo+")
         var natchalo = "начал[аое]|началом|середин[ыае]|серединой|конец|концом|конц[ае]"; //  ("+natchalo+")


//  Короткое тире меж римских чисел:  "II–V век"
 var re501 = new RegExp("([IVXLC])([\\\-—](\\\s|"+nbspChar+"){0,1}|(\\\s|"+nbspChar+"){0,1}[\\\-—])([IVXLC]{1,})("+fIB+"){0,1}([^А-яA-Za-zЁё0-9]|$)","g");
 var re501_ = "$1–$5$6$7";
 var count_501 = 0;
	// без тегов
	 var re501_0 = new RegExp("([IVXLC])([\\\-—](\\\s|"+nbspChar+"){0,1}|(\\\s|"+nbspChar+"){0,1}[\\\-—])([IVXLC]{1,})([^А-яA-Za-zЁё0-9]|$)","g");
	 var re501_0_ = "$1–$5$6";

//  Короткое тире меж римских чисел:  "II – начало V века"
 var re502 = new RegExp("([IVXLC])(\\\s|"+nbspChar+"){0,1}[\\\-—](\\\s|"+nbspChar+"){0,1}(("+natchalo+")(\\\s|"+nbspChar+")){0,1}([IVXLC]{1,})("+fIB+"){0,1}([^А-яA-Za-zЁё0-9]|$)","g");
 var re502_ = "$1 – $4$7$8$9";
	// без тегов
	 var re502_0 = new RegExp("([IVXLC])(\\\s|"+nbspChar+"){0,1}[\\\-—](\\\s|"+nbspChar+"){0,1}(("+natchalo+")(\\\s|"+nbspChar+")){0,1}([IVXLC]{1,})([^А-яA-Za-zЁё0-9]|$)","g");
	 var re502_0_ = "$1 – $4$7$8";
// используется счетчик №501


//  Короткое тире между числительными:  "один – два"
//  * если пробелов нет, то дефис сохраняется:  "один-два"
 var re503 = new RegExp("(^|[^А-я])(один|одн[ау]|дв[ае]|три|четыре|пять|шесть|семь|восемь|девять|десять|[a-я]{3,5}надцать|двадцать|тридцать|сорок|пятьдесят|шестьдесят|семьдесят|восемьдесят|девяносто|сто|двести|триста|четыреста|пятьсот|шестьсот|семьсот|восемьсот|девятьсот|тысяч[аи]{0,1})(\\\s|"+nbspChar+")[—\\\-](\\\s|"+nbspChar+")(?=один|дв[ае]|три|четыр|пять|пятнадцат|шест|сем|восем|девят|десять|сорок|девяносто|сто|тысяч|миллион)","g");
 var re503_ = "$1$2 – ";
 var count_503 = 0;


//  короткое тире между месяцами:   "Июнь–август"
 var re504s = new RegExp("([—\\\-]|\\\s|"+nbspChar+")("+mesiaz+"|"+natchalo+")","g");
 var re504 = new RegExp("(^|[^А-я])("+Mesiaz+")([—\\\-](\\\s|"+nbspChar+"){0,1}|(\\\s|"+nbspChar+"){0,1}[—\\\-])(?="+mesiaz+")","g");
 var re504_ = "$1$2–";
 var count_504 = 0;

// продолжение №504
//  короткое тире между месяцами:   "Июнь – начало августа"
 var re505 = new RegExp("(^|[^А-я])("+Mesiaz+"|"+mesiaZA+")(\\\s|"+nbspChar+"){0,1}[—\\\-](\\\s|"+nbspChar+"){0,1}(?=("+mesiaz+")|("+natchalo+")(\\\s|"+nbspChar+")("+mesiaZA+"))","g");
 var re505_ = "$1$2 – ";
// используется счетчик №504


//  Число месяц через н/р пробел (здесь не актуально, можно перенести в семисотые номера)
 var re506 = new RegExp("(\\\d)\\\s{0,1}("+mesiaZA+")","g");
 var re506_ = "$1"+nbspChar+"$2";
 var count_506 = 0;


//  короткое тире между сложными датами
//    месяц год – месяц год      или     Число_месяц (год) – число_месяц (год)       или     комбинация
//  Например:  1 мая 1999 – февраль 2002;   Май 1999 – 1 февраля 2002;   в начале июля 2022 – конце января 2023
 var re507s = new RegExp("([—–\\\-]|\\\s|"+nbspChar+")("+natchalo+"|"+mesiaz+"|"+mesiaZA+")","g");
 var re507 = new RegExp("(^|[^А-я])((("+Mesiaz+"|"+Natchalo+")(\\\s|"+nbspChar+")(\\\d{3,4}))|(((\\\d)|("+Natchalo+"))(\\\s|"+nbspChar+")("+mesiaZA+")((\\\s|"+nbspChar+")\\\d{3,4}){0,1}))(\\\s|"+nbspChar+"){0,1}[—–\\\-](\\\s|"+nbspChar+"){0,1}(?=(((\\\d){1,2}|("+natchalo+"))(\\\s|"+nbspChar+")("+mesiaZA+"))|((("+mesiaz+")|("+natchalo+"))(\\\s|"+nbspChar+")(\\\d){3,4}))","g");
 var re507_ = "$1$2 – ";
 var count_507 = 0;
 var count_507_ = 0;

//  короткое тире между датами и упрощенными порядковыми числительными
//      "50-е – конец 60-х"; "начало 70-х – 80-е годы";
 var re508 = new RegExp("(\\\d\\\-([ехм]|го))(\\\s|"+nbspChar+"){0,1}[—–\\\-](\\\s|"+nbspChar+"){0,1}(?=(("+natchalo+")(\\\s|"+nbspChar+")){0,1}(\\\d{1,4}\\\-([ехм]|го)))","g");
 var re508_ = "$1 – ";
// используется счетчик №507


        //  Коррекция

// Замена дефисов/тире на короткие тире рядом с цифрами
// * в re510 не считается 1-я скобка, а 2-я считается — поэтому она будет 1-й, но отмечать ее не надо, потому что содержимое в скобках "(?=" не учитывается
// ** "(?=" нужно для случая   "-1-" ,  чтобы обработать оба дефиса (тире)
 var re510 = new RegExp("[\\\-—](?=("+sIB+"){0,1}[0-9])|([0-9])("+fIB+"){0,1}[\\\-—](?=[^а-яё]|$)","g");
 var re510_ = "$2$3–";
 var count_510 = 0;
	// без тегов
	 var re510_0 = new RegExp("[\\\-—](?=[0-9])|([0-9])[\\\-—](?=[^а-яё]|$)","g");
	 var re510_0_ = "$1–";

 //  Для режима "Сохранение дефиса рядом с цифрой"
 var re510a = new RegExp("[—](?=("+sIB+"){0,1}[0-9])|([0-9])("+fIB+"){0,1}[—](?=[^а-яё]|$)","g");
 var re510a_ = "$2$3–";
	// без тегов
	 var re510a_0 = new RegExp("[—](?=[0-9])|([0-9])[—](?=[^а-яё]|$)","g");
	 var re510a_0_ = "$1–";
 var reDN1 = new RegExp("\\\-(?=("+sIB+"){0,1}[0-9])|([0-9])("+fIB+"){0,1}\\\-(?=[^а-яё]|$)","g");
 var reDN1_ = "$2$3"+FalseDefis;
	// без тегов
	 var reDN1_0 = new RegExp("\\\-(?=[0-9])|([0-9])\\\-(?=[^а-яё]|$)","g");
	 var reDN1_0_ = "$1"+FalseDefis;

// Замена короткого тире между цифрой и строчной буквой   на   дефис
//  Например:   1-ый
 var re511 = new RegExp("([0-9])("+fIB+"){0,1}[—–]([а-яё])","g");
 var re511_ = "$1$2-$3";
 var count_511 = 0;
	// без тегов
	 var re511_0 = new RegExp("([0-9])[—–]([а-яё])","g");
	 var re511_0_ = "$1-$2";

// Лишний пробел между числами через короткое тире
 var re512s = new RegExp("[0-9](–(\\\s|"+nbspChar+")|(\\\s|"+nbspChar+")–)[0-9]","g");
 var re512 = new RegExp("((^|[–,…\\\(\\\[«„“\\\"]|\\\s|"+nbspChar+")[0-9]{1,10})(–(\\\s|"+nbspChar+")|(\\\s|"+nbspChar+")–)(?=[0-9]{1,10}([–…\\\.,:;\\\?!\\\)\\\]»“”\\\"]|\\\s|"+nbspChar+"|$))","g");
 var re512_ = "$1–";
 var count_512 = 0;

// Замена дефисов/тире на короткие тире между цифрами
 var re514 = new RegExp("([0-9])("+fIB+"){0,1}(\\\s|"+nbspChar+")[\\\-—](\\\s|"+nbspChar+")(?=("+sIB+"){0,1}[0-9])","g");
 var re514_ = "$1$2 – ";
 var count_514 = 0;
	// без тегов
	 var re514_0 = new RegExp("([0-9])(\\\s|"+nbspChar+")[\\\-—](\\\s|"+nbspChar+")(?=[0-9])","g");
	 var re514_0_ = "$1 – ";



       // Дефис на тире

// ДЕФИС  в конце строки   на ТИРЕ
 var re520 = new RegExp("(([…\\\.,:\\\?!\\\)\\\]«„“»”\\\"]("+fIB+"){0,1})|(\\\s|"+nbspChar+"))\\\-("+fIB+"){0,1}$","g");
 var re520_ = "$2"+nbspChar+"—$5";
 var count_520 = 0;
	// без тегов
	 var re520_0 = new RegExp("(([…\\\.,:\\\?!\\\)\\\]«„“»”\\\"])|(\\\s|"+nbspChar+"))\\\-$","g");
	 var re520_0_ = "$2"+nbspChar+"—";


// ДЕФИС   между пробелами   на ТИРЕ
 var re521 = new RegExp("(\\\s|"+nbspChar+")\\\-(?=(\\\s|"+nbspChar+"))","g");
 var re521_ = "$1—";
 var count_521 = 0;


// Точка + ДЕФИС + пробел ››› точка + н/р пробел + ТИРЕ + пробел
//  Исключения: Сокращения с дефисом  |  Ж.-П.Сартр  |  ж.-д. транспорт  |  и т.п.
 var re530 = new RegExp("\\\.("+fIB+"){0,1}\\\-("+fIB+"){0,1}(\\\s|"+nbspChar+")","g");
 var re530_ = ".$1$2"+nbspChar+"— ";
 var count_530 = 0;
	// без тегов
	 var re530_0 = new RegExp("\\\.\\\-(\\\s|"+nbspChar+")","g");
	 var re530_0_ = "."+nbspChar+"— ";

// Точка + пробел + ДЕФИС ››› точка + н/р пробел + ТИРЕ +
 var re531 = new RegExp("([а-яa-zё])("+fIB+"){0,1}\\\.("+fIB+"){0,1}(\\\s|"+nbspChar+")("+sIB+"){0,1}\\\-("+sIB+"){0,1}([А-ЯA-ZЁ])","g");
 var re531_ = "$1$2.$3"+nbspChar+"— $5$6$7";
	// без тегов
	 var re531_0 = new RegExp("([а-яa-zё])\\\.(\\\s|"+nbspChar+")\\\-([А-ЯA-ZЁ])","g");
	 var re531_0_ = "$1."+nbspChar+"— $3";
// со сносками
 var re531nc = new RegExp("([а-яa-zё])("+fIB+"){0,1}("+NC+"){0,1}\\\.("+fIB+"){0,1}("+NC+"){0,1}(\\\s|"+nbspChar+")("+sIB+"){0,1}\\\-("+sIB+"){0,1}([А-ЯA-ZЁ])","g");
 var re531nc_ = "$1$2$3.$4$5"+nbspChar+"— $7$8$9";
	// без тегов
	 var re531nc_0 = new RegExp("([а-яa-zё])("+NC+"){0,1}\\\.("+NC+"){0,1}(\\\s|"+nbspChar+")\\\-([А-ЯA-ZЁ])","g");
	 var re531nc_0_ = "$1$2.$3"+nbspChar+"— $5";
// используется счетчик №530


// Знак препинания 1 + ДЕФИС  ›››  Знак препинания 1 + н/р пробел + ТИРЕ
 var re532 = new RegExp("([…,\\\?!\\\)\\\]])("+fIB+"){0,1}(\\\s|"+nbspChar+"){0,1}("+sIB+"){0,1}\\\-("+fIB+"){0,1}(\\\s|"+nbspChar+"){0,1}","g");
 var re532_ = "$1$2$5"+nbspChar+"— $4";
	// без тегов
	 var re532_0 = new RegExp("([…,\\\?!\\\)\\\]])(\\\s|"+nbspChar+"){0,1}\\\-(\\\s|"+nbspChar+"){0,1}","g");
	 var re532_0_ = "$1"+nbspChar+"— ";
// со сносками
 var re532nc = new RegExp("([…,\\\?!\\\)\\\]])("+fIB+"){0,1}("+NC+"){0,1}(\\\s|"+nbspChar+"){0,1}("+sIB+"){0,1}\\\-(\\\s|"+nbspChar+"){0,1}","g");
 var re532nc_ = "$1$2$3"+nbspChar+"— $5";
	// без тегов
	 var re532nc_0 = new RegExp("([…,\\\?!\\\)\\\]])("+NC+"){0,1}(\\\s|"+nbspChar+"){0,1}\\\-(\\\s|"+nbspChar+"){0,1}","g");
	 var re532nc_0_ = "$1$2"+nbspChar+"— ";
// используется счетчик №530

// Знак препинания 2 + ДЕФИС (с пробелом) ››› Знак препинания 2 + н/р пробел + ТИРЕ + пробел
// Исключения:   Смайлы;   код символа;
 var re533 = new RegExp("(:|[А-я>];)("+fIB+"){0,1}((\\\s|"+nbspChar+")("+sIB+"){0,1}\\\-|\\\-("+fIB+"){0,1}(\\\s|"+nbspChar+"))","g");
 var re533_ = "$1$2$6"+nbspChar+"— $5";
	// без тегов
	 var re533_0 = new RegExp("(:|[А-я>];)((\\\s|"+nbspChar+")\\\-|\\\-(\\\s|"+nbspChar+"))","g");
	 var re533_0_ = "$1"+nbspChar+"— ";
// используется счетчик №530

// ДЕФИС  +  многоточие  ›››  ТИРЕ  + пробел  +  многоточие
// + нормализация тире и пробела
 var re534 = new RegExp("\\\-("+fIB+"){0,1}(\\\s|"+nbspChar+"){0,1}("+sIB+"){0,1}…([А-яA-Za-zЁё])","g");
 var re534_ = "—$1 $3…$4";
 var count_534 = 0;
	// без тегов
	 var re534_0 = new RegExp("\\\-(\\\s|"+nbspChar+"){0,1}…([А-яA-Za-zЁё])","g");
	 var re534_0_ = "— …$2";



       // Тире

// Тире + обычный пробел
//  * Исключение:  тире с неразрывным пробелом в начале строки
 var re550 = new RegExp("(.)—("+fIB+"){0,1}("+nbspChar+"){0,1}(?=("+sIB+"){0,1}[А-яA-Za-zЁё0-9…\\\(\\\[«„])","g");
 var re550_ = "$1—$2 ";
 var count_550 = 0;
	// без тегов
	 var re550_0 = new RegExp("(.)—("+nbspChar+"){0,1}(?=[А-яA-Za-zЁё0-9…\\\(\\\[«„])","g");
	 var re550_0_ = "$1— ";


//  Тире/дефис  (+ пробел)   в начале строки
 var re551 = new RegExp("^("+sIB+"){0,1}([«\\\"]){0,1}(—\\\s|[\\\-~](\\\s|"+nbspChar+")|("+sIB+"){0,1}[—\\\-~]("+sIB+"){0,1}([А-яA-Za-zЁё0-9—…\\\(\\\[«„\\\"\\\.\\\?!_]))","g");
 var re551_ = "$1$2—"+nbspChar+"$5$6$7";
 var count_551 = 0;
	// без тегов
	 var re551_0 = new RegExp("^([«\\\"]){0,1}(—\\\s|[\\\-~](\\\s|"+nbspChar+")|[—\\\-~]([А-яA-Za-zЁё0-9—…\\\(\\\[«„\\\"\\\.\\\?!_]))","g");
	 var re551_0_ = "$1—"+nbspChar+"$4";


// Пропущенный пробел перед тире
//    + неразрывный пробел на обычный
//    * Исключение:  тире в конце строки
 var re561 = new RegExp("([А-яA-Za-zЁё0-9]("+aIB+"){0,1}[«„“»”\\\"]{0,1}|[\\\)\\\]])("+fIB+"){0,1}("+nbspChar+"){0,1}("+sIB+"){0,1}—(?=.)","g");
 var re561_ = "$1$3 $5—";
 var count_561 = 0;
	// без тегов
	 var re561_0 = new RegExp("([А-яA-Za-zЁё0-9][«„“»”\\\"]{0,1}|[\\\)\\\]])("+nbspChar+"){0,1}—(?=.)","g");
	 var re561_0_ = "$1 —";

// Пропущенный неразрывный пробел перед тире
//    + обычный пробел на неразрывный
 var re562 = new RegExp("([…\\\.,:\\\?!]|[А-я>];)("+aIB+"){0,1}([«„“»”\\\"]){0,1}("+fIB+"){0,1}\\\s{0,1}("+sIB+"){0,1}—","g");
 var re562_ = "$1$2$3$4"+nbspChar+"$5—";
 var count_562 = 0;
	// без тегов
	 var re562_0 = new RegExp("([…\\\.,:\\\?!]|[А-я>];)([«„“»”\\\"]){0,1}\\\s{0,1}—","g");
	 var re562_0_ = "$1$2"+nbspChar+"—";
//  со сносками
 var re562nc = new RegExp("([…\\\.,:\\\?!]|[А-я>];)("+fIB+"){0,1}([«„“»”\\\"]){0,1}("+fIB+"){0,1}("+NC+"){0,1}\\\s{0,1}("+sIB+"){0,1}—","g");
 var re562nc_ = "$1$2$3$4$5"+nbspChar+"$6—";
	// без тегов
	 var re562nc_0 = new RegExp("([…\\\.,:\\\?!]|[А-я>];)([«„“»”\\\"]){0,1}("+NC+"){0,1}\\\s{0,1}—","g");
	 var re562nc_0_ = "$1$2$3"+nbspChar+"—";


// пробел + ТИРЕ   ›››  неразрывный пробел + ТИРЕ  (в конце строки)
 var re570 = new RegExp("([^\\\s"+nbspChar+"])\\\s{0,1}—("+fIB+"){0,1}$","g");
 var re570_ = "$1"+nbspChar+"—$2";
 var count_570 = 0;
	// без тегов
	 var re570_0 = new RegExp("([^\\\s"+nbspChar+"])\\\s{0,1}—$","g");
	 var re570_0_ = "$1"+nbspChar+"—";


// Неучтенные дефисы  ›››  короткое тире
//  В основном здесь обрабатывается пара   буква+дефис
 var re580 = new RegExp("(^|\\\s|"+nbspChar+"|[…,:\\\?!\\\(\\\)\\\[\\\]«„“”\\\";])((<[^>]{1,}>){0,4})\\\-|\\\-(?=((<[^>]{1,}>){0,4})([…,:;\\\?!\\\(\\\)\\\[\\\]„“»”\\\"]|\\\s|"+nbspChar+"))","g");
 var re580_ = "$1$2–";
 var count_580 = 0;
	//  без тегов (любых)
	 var re580_0 = new RegExp("(^|\\\s|"+nbspChar+"|[…,:\\\?!\\\(\\\)\\\[\\\]«„“”\\\";])\\\-|\\\-(?=([…,:;\\\?!\\\(\\\)\\\[\\\]„“»”\\\"]|\\\s|"+nbspChar+"))","g");
	 var re580_0_ = "$1–";


//  Обычный пробел ››› н/р пробел  ;  короткое тире ››› дефис  ;  (в ISBN, ББК, УДК, ГОСТ)
 var re581s = new RegExp("(ISBN|ББК|УДК|ГОСТ)","g");
 var re581 = new RegExp("(ISBN|ББК|УДК|ГОСТ)\\\s{0,1}([0-9])","g");
 var re581_ = "$1"+nbspChar+"$2";
 var count_581 = 0;

 var re582 = new RegExp("(ISBN|ББК|УДК|ГОСТ)"+nbspChar+"([0-9][^\\\s"+nbspChar+"]{0,})–","g"); // в цикле
 var re582_ = "$1"+nbspChar+"$2-";

// ---------------------------------------------------------------
/// НЕРАЗРЫВНЫЕ ПРОБЕЛЫ С ЗАКРЕПЛЕНИЕМ  :  операции  № 6хх
// ---------------------------------------------------------------

//  * Формулы с пометкой "s" используются для стартовой проверки у сложной формулы
//  * Формулы с пометкой "sv" используются для сохранения неразрывного пробела
//  ** Замена происходит в три этапа:
//  1. Маскировка уже измененных н/р пробелов.  (sv) -- не добавляется в статистику
//  2. Замена обычных  пробелов на замаскированный н/р пробел. -- добавляется в статистику
//  3. Снятие маскировки после прохождения формулы № 690.


// св. Мария, гр. Корейко, пл. Гагарина, ул. Ленина, оз. Балхаш, (предварительное дополнение к №611)
//  исключение:  им. (это может быть местоимением в конце предложения)
 var re601 = new RegExp("(^|[\\\s\\\"«„“])([Гг]р|оз|[Пп]л|[Сс]в|[Уу]л)\\\.\\\s{0,1}([А-ЯЁ])","g");
 var re601_ = "$1$2."+nbspChar+"$3";
 var count_601 = 0;


       //  Висящие слова

// Добавление в конце абзаца неразрывного пробела перед словом (или числом) настраиваемой длины (зависит от Abz5)
 var re610sv = new RegExp(nbspChar+"([А-яA-Za-zЁё0-9]{1,"+Abz5+"}[^А-яA-Za-zЁё0-9]{0,3}("+fIB+"){0,1})$","g");
 var re610 = new RegExp("\\\s([А-яA-Za-zЁё0-9]{1,"+Abz5+"}[^А-яA-Za-zЁё0-9]{0,3}("+fIB+"){0,1})$","g");
 var re610_ = FalseSim+"$1";
 var count_610 = 0;
	// без тегов
	 var re610sv_0 = new RegExp(nbspChar+"([А-яA-Za-zЁё0-9]{1,"+Abz5+"}[^А-яA-Za-zЁё0-9]{0,3})$","g");
	 var re610_0 = new RegExp("\\\s([А-яA-Za-zЁё0-9]{1,"+Abz5+"}[^А-яA-Za-zЁё0-9]{0,3})$","g");
	 var re610_0_ = FalseSim+"$1";

// Добавление неразрывного пробела перед 1- или 2-символьным словом в конце предложения.
// Формулы зависят от переменных Abz6 и Abz7 (для 1-символьного они равны "0" и "1", для 1-2-символьного — наоборот: "1" и "0")
// Исключения:   И. Фамилия  ;   фр. язык   ;   г. Караганда   ;    оз. Балхаш (добавлены в №601)   ;   Хо! Хо! Хо!   ;
 var re611s = new RegExp("[^\\\.—]"+nbspChar+"[А-яЁё]","g");
 var re611sv = new RegExp("([^\\\?!\\\.\\\-—…])"+nbspChar+"(?=([А-яЁё]{2}|[абия]){"+Abz6+"}[абия]{"+Abz7+"}("+fIB+"){0,1}([»\\\"]{0,1})([\\\.\\\?!…]|[\\\?!]\\\.\\\.)("+fIB+"){0,1}\\\s("+sIB+"){0,1}[А-ЯA-ZЁ])","g");
 var re611 = new RegExp("([^\\\?!\\\.\\\-—…])\\\s(?=([А-яЁё]{2}|[абия]){"+Abz6+"}[абия]{"+Abz7+"}("+fIB+"){0,1}([»\\\"]{0,1})([\\\.\\\?!…]|[\\\?!]\\\.\\\.)("+fIB+"){0,1}\\\s("+sIB+"){0,1}[А-ЯA-ZЁ])","g");
 var re611_ = "$1"+FalseSim;
 var count_611 = 0;
	// без тегов
	 var re611sv_0 = new RegExp("([^\\\?!\\\.\\\-—…])"+nbspChar+"(?=([А-яЁё]{2}|[абия]){"+Abz6+"}[абия]{"+Abz7+"}([»\\\"]{0,1})([\\\.\\\?!…]|[\\\?!]\\\.\\\.)\\\s[А-ЯA-ZЁ])","g");
	 var re611_0 = new RegExp("([^\\\?!\\\.\\\-—…])\\\s(?=([А-яЁё]{2}|[абия]){"+Abz6+"}[абия]{"+Abz7+"}([»\\\"]{0,1})([\\\.\\\?!…]|[\\\?!]\\\.\\\.)\\\s[А-ЯA-ZЁ])","g");
	 var re611_0_ = "$1"+FalseSim;

// Слово длиной в одну букву   +   предлоги "к", "у", "с", "о", "в",   +   слово от 3-х букв и длиннее
 var re615s = new RegExp("[вкусо]"+nbspChar+"[А-яЁё<]","g");
 var re615sv = new RegExp("((\\\s|"+nbspChar+")[а-яё][\\\.,]{0,1}\\\s[вкусо])"+nbspChar+"(("+sIB+"){0,1}[А-яЁё]{3})","g");
 var re615 = new RegExp("((\\\s|"+nbspChar+")[а-яё][\\\.,]{0,1}\\\s[вкусо])\\\s(("+sIB+"){0,1}[А-яЁё]{3})","g");
 var re615_ = "$1"+FalseSim+"$3";
 var count_615 = 0;
	// без тегов
	 var re615sv_0 = new RegExp("((\\\s|"+nbspChar+")[а-яё][\\\.,]{0,1}\\\s[вкусо])"+nbspChar+"([А-яЁё]{3})","g");
	 var re615_0 = new RegExp("((\\\s|"+nbspChar+")[а-яё][\\\.,]{0,1}\\\s[вкусо])\\\s([А-яЁё]{3})","g");
	 var re615_0_ = "$1"+FalseSim+"$3";

// Добавление неразрывного пробела после первого слова длиной в 1 букву в начале предложения
// Исключения: Это слово не может быть всем предложением;   и не может быть первым в абзаце
 var re616s = new RegExp("[А-ЯA-ZЁ]:{0,1}"+nbspChar,"g");
 var re616sv = new RegExp("([\\\.\\\?!…]("+fIB+"){0,1}\\\s("+sIB+"){0,1}[А-ЯA-ZЁ]:{0,1})"+nbspChar,"g");
 var re616 = new RegExp("([\\\.\\\?!…]("+fIB+"){0,1}\\\s("+sIB+"){0,1}[А-ЯA-ZЁ]:{0,1})\\\s","g");
 var re616_ = "$1"+FalseSim;
 var count_616 = 0;
	// без тегов
	 var re616sv_0 = new RegExp("([\\\.\\\?!…]\\\s[А-ЯA-ZЁ]:{0,1})"+nbspChar,"g");
	 var re616_0 = new RegExp("([\\\.\\\?!…]\\\s[А-ЯA-ZЁ]:{0,1})\\\s","g");
	 var re616_0_ = "$1"+FalseSim;


       //  Сохранение н/р пробела
// * счетчик не используется

//  Сохранение н/р пробела  в   р а з р я д к е   (от 4-х букв)
 var re620s = new RegExp("(^|[^А-яA-Za-zЁё])([А-яA-Za-zЁё](\\\s|"+nbspChar+")){3,}[А-яA-Za-zЁё]([^А-яA-Za-zЁё]|$)","g");
 var re620sv = new RegExp("((^|[^А-яA-Za-zЁё])[А-яA-Za-zЁё])"+nbspChar+"(?=([А-яA-Za-zЁё](\\\s|"+nbspChar+"|"+FalseSim+")){2}[А-яA-Za-zЁё]([^А-яA-Za-zЁё]|$))","g");
 var re620_ = "$1"+FalseSim;
	 var re621sv = new RegExp("((^|[^А-яA-Za-zЁё])[А-яA-Za-zЁё](\\\s|"+nbspChar+"|"+FalseSim+")[А-яA-Za-zЁё])"+nbspChar+"(?=[А-яA-Za-zЁё](\\\s|"+nbspChar+"|"+FalseSim+")[А-яA-Za-zЁё]([^А-яA-Za-zЁё]|$))","g");
	 var re621_ = "$1"+FalseSim;
 var re622sv = new RegExp("((^|[^А-яA-Za-zЁё])[А-яA-Za-zЁё]((\\\s|"+nbspChar+"|"+FalseSim+")[А-яA-Za-zЁё]){2})"+nbspChar+"(?=[А-яA-Za-zЁё]([^А-яA-Za-zЁё]|$))","g");
 var re622_ = "$1"+FalseSim;


//  Сохранение н/р пробела  в  двухбуквенном инициале
//  Пример: Серов_Вл.
 var re623s = new RegExp(nbspChar+"[А-ЯA-ZЁ]","g");
 var re623sv = new RegExp("([А-ЯA-ZЁ][а-яa-zё]{1,})"+nbspChar+"([А-ЯA-ZЁ][а-яa-zё]\\\.)","g");
 var re623_ = "$1"+FalseSim+"$2";

//  Сохранение н/р пробела  в  приставках к имени
//  Пример:  да_Винчи,  де_Бальзак, де ля_Фер,  фон_Штирлиц
 var re624sv = new RegExp("(^|[^А-яA-Za-zЁё])([Дд][ае]|[Лл][ея]|[Фф]он|[Dd][ae]|[Ll][ea]|[Ff]on)"+nbspChar+"([А-ЯA-ZЁ])","g");
 var re624_ = "$1$2"+FalseSim+"$3";


       // н/р пробел в аббревиатуре

//  ЦК ВКП(б),  ЦК ВЛКСМ,  ЦК КПСС
 var re630s = new RegExp("ЦК","g");
 var re630sv = new RegExp("(ЦК)"+nbspChar+"(КПСС|ВЛКСМ|ВКП)","g");
 var re630sv_ = "$1"+FalseSim+"$2";
 var re630 = new RegExp("(ЦК)\\\s(КПСС|ВЛКСМ)|(ЦК)\\\s(ВКП)(\\\s|"+nbspChar+"){0,1}(\\\(б\\\))","g");
 var re630_ = "$1$3"+FalseSim+"$2$4$6";
 var count_630 = 0;

//  АО,  ООО,  ОАО,  НПО,  ИА,  РИА,  ВИА,  ДК
 var re631s = new RegExp("АО|ДК|ИА|ООО|НПО","g");
 var re631sv = new RegExp("(АО|ДК|ИА|ООО|НПО)"+nbspChar+"([«„\\\"])","g");
 var re631 = new RegExp("(АО|ДК|ИА|ООО|НПО)\\\s([«„\\\"])","g");
 var re631_ = "$1"+FalseSim+"$2";
 var count_631 = 0;


       //

// Замена неразрывных пробелов на обычные
// Исключения:  |  о. Сахалин   |  ср. школа   |  Лукьяненко С. В.   |   100 Вт   |   XXI век   |   Людвиг XIV   |   операция Z   |
 var re690s = new RegExp("[^\\\.—]"+nbspChar+"[^—]","g");
 var re690 = new RegExp("([А-яABE-HJKN-UWYZa-zЁё]("+fIB+"){0,1}[\\\)\\\]“»”\\\"\\\?!,…:]{0,2})"+nbspChar+"(?=[\\\(\\\[«„“\\\"…]{0,2}("+sIB+"){0,1}([А-яABE-HJKN-UWYZa-zЁё][А-яA-Za-zЁё]|[а-яa-zё]))","g");
 var re690_ = "$1 ";
 var count_690 = 0;
	// без тегов
	 var re690_0 = new RegExp("([А-яABE-HJKN-UWYZa-zЁё][\\\)\\\]“»”\\\"\\\?!,…:]{0,2})"+nbspChar+"(?=[\\\(\\\[«„“\\\"…]{0,2}([А-яABE-HJKN-UWYZa-zЁё][А-яA-Za-zЁё]|[а-яa-zё]))","g");
	 var re690_0_ = "$1 ";


       //

// Снятие маскировки с неразрывного пробела
 var re691 = new RegExp(FalseSim,"g");
 var re691_ = nbspChar;
 var count_691 = 0;

// ---------------------------------------------------------------
/// СОКРАЩЕНИЯ, ПЕРЕЧИСЛЕНИЯ, ОБОЗНАЧЕНИЯ И Т.П.  :  операции  № 7хх
//       (неразрывные пробелы в тексте)
// ---------------------------------------------------------------

       //   Сокращения: н.э., с.ш., в.д., и т.д., и т.п.

// (и) "так далее" — т. д., "то есть" — т. е., "так как"— т. к., "так называемый"— т. н., "таким образом"— т. о., (и) "тому подобное" — т. п., (в) "том числе"— т. ч.
 var re730 = new RegExp("(^|"+nbspChar+"|[\\\(\\\[\\\s>])([Тт])\\\.\\\s{0,1}([копченд])\\\.","g");
 var re730_ = "$1$2."+nbspChar+"$3.";
 var count_730 = 0;

// "новой эры" — н. э., "сего года" — с. г., "исполняющий обязанности" — и. о.
 var re731 = new RegExp("(^|"+nbspChar+"|[\\\(\\\[\\\s>])((н)\\\.\\\s{0,1}(э)\\\.|(с)\\\.\\\s{0,1}(г)\\\.|([Ии])\\\.\\\s{0,1}(о)\\\.)","g");
 var re731_ = "$1$3$5$7."+nbspChar+"$4$6$8.";
 var count_731 = 0;

// Северной широты, восточной долготы
 var re732 = new RegExp("(^|"+nbspChar+"|[\\\(\\\[\\\s>])(([сю])\\\.\\\s{0,1}(ш)\\\.|([вз])\\\.\\\s{0,1}(д)\\\.)","g");
 var re732_ = "$1$3$5."+nbspChar+"$4$6.";
 var count_732 = 0;


             //  * для 735-737 числа через н/р пробел добавляются в №755
// "год рождения" — г. р.
 var re735 = new RegExp("(["+nbspChar+"0-9\\\(\\\[\\\s>])(г)\\\.\\\s{0,1}(р)\\\.","g");
 var re735_ = "$1$2."+nbspChar+"$3.";
 var count_735 = 0;

// "условные единицы" — у. е.
 var re736 = new RegExp("(["+nbspChar+"0-9\\\(\\\[\\\s>])(у)\\\.\\\s{0,1}(е)\\\.","g");
 var re736_ = "$1$2."+nbspChar+"$3.";
// используется счетчик №735

// "лошадиные силы" — л. с.
 var re737 = new RegExp("(["+nbspChar+"0-9\\\(\\\[\\\s>])(л)\\\.\\\s{0,1}(с)\\\.","g");
 var re737_ = "$1$2."+nbspChar+"$3.";
// используется счетчик №735


       //   Обозначения

//  знак №
 var re740s = new RegExp("N","g");
 var re740 = new RegExp("(^|"+nbspChar+"|[\\\(\\\[\\\s>])N(<SUP>[Оо0oO]</SUP>|[oо°])(\\\s|"+nbspChar+"){0,1}(\\\d)","g");
 var re740_ = "$1№"+nbspChar+"$4";
 var count_740 = 0;


 // Формула запуска для № 741, 742
 var re741s = new RegExp("\\\d(\\\s|"+nbspChar+"){0,1}[°oо<]","g");

// Градус Цельсия и др.
// Правильный минус учитывается, но не изменяется
 var re741 = new RegExp("(^|"+nbspChar+"|[\\\s\\\+−\\\.,–\\\(>])(\\\d{1,4})(\\\s|"+nbspChar+"){0,1}(<SUP>[Оо0oO]</SUP>|[oо°])(\\\s|"+nbspChar+"){0,1}([CСKКFR])(?=[<,\\\.;:\\\)\\\s]|"+nbspChar+"|$)","g");
 var re741_ = "$1$2"+nbspChar+"°$6";
 var count_741 = 0;
 var count_741_ = 0;
	// Градус Цельсия
	 var re741C = new RegExp("°С","g");
	 var re741C_ = "°C";
	// Градус Кельвина
	 var re741K = new RegExp("°К","g");
	 var re741K_ = "°K";


// Знак градуса по контексту
// * в сокращении "в.д." (и др.)  уже расставлены неразрывные пробелы в №732
 var re742 = new RegExp("(\\\d)(<SUP>[Оо0oO]</SUP>|[oо])((\\\d)|([^А-яA-Za-zЁё].{0,20})(°|Цельси|Фаренгейт|Кельвин|Реомюр|северной|южной|западной|восточной|[сю]\\\.("+nbspChar+")ш\\\.|[вз]\\\.("+nbspChar+")д\\\.))","g");
 var re742_ = "$1°$3";
 var count_742 = 0;


// Градусы с минутами  23°8′
 var re743a = new RegExp("([0-9])°(\\\s|"+nbspChar+"){0,1}([0-9]{1,2})[’'′]","g");
 var re743a_ = "$1°$3′";
 var count_743 = 0;
 var count_743_ = 0;

 // Градусы с минутами и секундами  23°8′48″
 var re743b = new RegExp("([0-9]°[0-9]{1,2}′)(\\\s|"+nbspChar+"){0,1}([0-9]{1,2})[\\\"″]","g");
 var re743b_ = "$1$3″";


 // Формула запуска для № 744, 745
 var re744s = new RegExp("(№|§)","g");

 // Знак параграфа, номера
 var re744 = new RegExp("(№|§)(\\\s){0,1}(\\\d)","g");
 var re744_ = "$1"+nbspChar+"$3";
 var count_744 = 0;

// Пробелы в перечне номеров, параграфов
//      дополнение к №744
 var re745 = new RegExp("(№|§)("+nbspChar+")(([,\\\s\\\d\\\–"+nbspChar+"]){0,50})(\\\d,)(\\\d)","g");
 var re745_ = "$1$2$3$5 $6";
 var count_745 = 0;


 // Формула запуска для № 746, 747
 var re746s = new RegExp("(^|"+nbspChar+"|[\\\[\\\(\\\s>])(с|сс|стр|p|pp|рис|ст)\\\.","gi");

// Страницы, статьи и т.п.
 var re746 = new RegExp("(^|"+nbspChar+"|[\\\[\\\(\\\s>])(с|сс|стр|p|pp|рис|ст)\\\.(\\\s){0,1}(\\\d)","gi");
 var re746_ = "$1$2."+nbspChar+"$4";
// используется счетчик №744

// Пробелы в перечне номеров страниц, статей и т.п.
//      дополнение к №746
 var re747 = new RegExp("(^|"+nbspChar+"|[\\\[\\\(\\\s>])(с|сс|стр|p|pp|рис|ст)(\\\."+nbspChar+")(([,\\\s\\\d\\\–"+nbspChar+"]){0,50})(\\\d,)(\\\d)","gi");
 var re747_ = "$1$2$3$4$6 $7";
// используется счетчик №745

// Процент без пробела
 var re748 = new RegExp("([\\\d])(\\\s|"+nbspChar+")%","g");
 var re748_ = "$1%";
 var count_748 = 0;


       // Число + сложное сокращение

// Число + Квадраты и кубы
//  Число через н/р пробел добавляется не в №755, а в №751 — для исключения адреса ("д. 10 кв. 20")
 var re750 = new RegExp("("+nbspChar+"|[0-9\\\[\\\(\\\s>])(кв\\\.|куб\\\.)\\\s{0,1}(м|мм|см|дм|км)(?=[<,\\\.;:\\\)\\\]\\\s]|"+nbspChar+"|$)","g");
 var re750_ = "$1$2"+nbspChar+"$3";
 var count_750 = 0;

// Продолжение №750 - добавление числа
 var re751s = new RegExp("\\\."+nbspChar+"[мсдк]","g");
 var re751 = new RegExp("([\\\d])\\\s{0,1}(("+sIB+"){0,1}(кв\\\.|куб\\\.)"+nbspChar+"(м|мм|см|дм|км))(?=[<,\\\.;:\\\)\\\]\\\s]|"+nbspChar+"|$)","g");
 var re751_ = "$1"+nbspChar+"$2";
	// без тегов
	 var re751_0 = new RegExp("([\\\d])\\\s{0,1}((кв\\\.|куб\\\.)"+nbspChar+"(м|мм|см|дм|км))(?=[<,\\\.;:\\\)\\\]\\\s]|"+nbspChar+"|$)","g");
	 var re751_0_ = "$1"+nbspChar+"$2";


       //

// Единицы измерения
 var re755 = new RegExp("(^|"+nbspChar+"|[–\\\+\\\.,\\\[\\\(\\\s>])([\\\d]{1,4})(\\\s{0,1})("+sIB+"){0,1}((ч|м|г|т|л|р|g)|(кг|мм|мл|см|дм|км|гг|вв|в\\\.|к\\\.|у\\\.|мг|мл|вт|Вт|га|шт|ст|гл|кн)|(тыс|млн|мес|час|мин|сек|чел|мкг|квт|кВт|руб|коп|стр|экз|янв|фев|мар|апр|май|июн|июл|авг|сен|окт|ноя|дек)|(ккал|град|млрд))(?=[<,\\\.;\\\)\\\]\\\s]|"+nbspChar+"|$)","g");
 var re755_ = "$1$2"+nbspChar+"$4$5";
 var count_755 = 0;
	// без тегов
	 var re755_0 = new RegExp("(^|"+nbspChar+"|[–\\\+\\\.,\\\[\\\(\\\s>])([\\\d]{1,4})(\\\s{0,1})((ч|м|г|т|л|р|g)|(кг|мм|мл|см|дм|км|гг|вв|в\\\.|к\\\.|у\\\.|мг|мл|вт|Вт|га|шт|ст|гл|кн)|(тыс|млн|мес|час|мин|сек|чел|мкг|квт|кВт|руб|коп|стр|экз|янв|фев|мар|апр|май|июн|июл|авг|сен|окт|ноя|дек)|(ккал|град|млрд))(?=[<,\\\.;\\\)\\\]\\\s]|"+nbspChar+"|$)","g");
	 var re755_0_ = "$1$2"+nbspChar+"$4";


       //   Начало строки

// Пронумерованный/литерный список:  |  1.  |  1)  |  а.  |  а)  |
 var re760s = new RegExp("(^|>)[«„\\\"]{0,1}(\\\d|[а-яa-zё][\\\.\\\)])","g");
 var re760 = new RegExp("^(("+sIB+"){0,1}[«„\\\"]{0,1}(\\\d{1,3}|[а-яa-zё])[\\\.\\\)]("+fIB+"){0,1})(\\\s{0,1}("+sIB+"){0,1}([А-яA-Za-zЁё—…\\\"«„])|\\\s("+sIB+"){0,1}([0-9]))","g");
 var re760_ = "$1"+nbspChar+"$6$7$8$9";
 var count_760 = 0;
	// без тегов
	 var re760_0 = new RegExp("^([«„\\\"]{0,1}(\\\d{1,3}|[а-яa-zё])[\\\.\\\)])(\\\s{0,1}([А-яA-Za-zЁё—…\\\"«„])|\\\s([0-9]))","g");
	 var re760_0_ = "$1"+nbspChar+"$4$5";

// Пронумерованный список: Ст. 15
//  Должен стоять после №746 (добавляет второй н/р пробел)
 var re761 = new RegExp("^(("+sIB+"){0,1}[«„\\\"]{0,1}(Ст)\\\.)(\\\s|"+nbspChar+"){0,1}(\\\d{1,4})\\\.("+fIB+"){0,1}\\\s","g");
 var re761_ = "$1"+nbspChar+"$5.$6"+nbspChar;
	// без тегов
	 var re761_0 = new RegExp("^([«„\\\"]{0,1}(Ст)\\\.)(\\\s|"+nbspChar+"){0,1}(\\\d{1,4})\\\.\\\s","g");
	 var re761_0_ = "$1"+nbspChar+"$4."+nbspChar;
// используется счетчик №760

// Пронумерованный список: 1980 —
 var re762 = new RegExp("^(("+sIB+"){0,1}[«„\\\"]{0,1}\\\d{1,4}("+fIB+"){0,1})(\\\s|"+nbspChar+"){0,1}[\\\-–—](\\\s|"+nbspChar+")(?=("+sIB+"){0,1}[А-яA-Za-zЁё…\\\"«„])","g");
 var re762_ = "$1"+nbspChar+"— ";
	// без тегов
	 var re762_0 = new RegExp("^([«„\\\"]{0,1}\\\d{1,4})(\\\s|"+nbspChar+"){0,1}[\\\-–—](\\\s|"+nbspChar+")(?=[А-яA-Za-zЁё…\\\"«„])","g");
	 var re762_0_ = "$1"+nbspChar+"— ";
// используется счетчик №760

// Маркерный список:    •  ;  *
 var re763s = new RegExp("(^|>)[•\\\*]","g");
 var re763 = new RegExp("^("+sIB+"){0,1}([•\\\*])\\\s{0,1}([<А-яA-Za-zЁё0-9«„“\\\"])","g");
 var re763_ = "$1$2"+nbspChar+"$3";
	// без тегов
	 var re763_0 = new RegExp("^([•\\\*])\\\s{0,1}([<А-яA-Za-zЁё0-9«„“\\\"])","g");
	 var re763_0_ = "$1"+nbspChar+"$2";
// используется счетчик №760


//  P. S.,   P. P. S.   и   P. S. S.
 var re765s = new RegExp("(^|>)P\\\.","g");
 var re765 = new RegExp("^("+sIB+"){0,1}(P\\\.)(\\\s|"+nbspChar+"){0,1}(S\\\.)("+fIB+"){0,1}((\\\s|"+nbspChar+"){0,1}(?=[<А-ЯA-ZЁ0-9«„“\\\"][^\\\.])|$)","g");
 var re765_ = "$1$2"+nbspChar+"$4$5 ";
	// без тегов
	 var re765_0 = new RegExp("^(P\\\.)(\\\s|"+nbspChar+"){0,1}(S\\\.)((\\\s|"+nbspChar+"){0,1}(?=[<А-ЯA-ZЁ0-9«„“\\\"][^\\\.])|$)","g");
	 var re765_0_ = "$1"+nbspChar+"$3 ";
 var re766 = new RegExp("^("+sIB+"){0,1}(P\\\.)(\\\s|"+nbspChar+"){0,1}([PS]\\\.)(\\\s|"+nbspChar+"){0,1}(S\\\.)("+fIB+"){0,1}((\\\s|"+nbspChar+"){0,1}(?=[<А-ЯA-ZЁ0-9«„“\\\"][^\\\.])|$)","g");
 var re766_ = "$1$2"+nbspChar+"$4"+nbspChar+"$6$7 ";
	// без тегов
	 var re766_0 = new RegExp("^(P\\\.)(\\\s|"+nbspChar+"){0,1}([PS]\\\.)(\\\s|"+nbspChar+"){0,1}(S\\\.)((\\\s|"+nbspChar+"){0,1}(?=[<А-ЯA-ZЁ0-9«„“\\\"][^\\\.])|$)","g");
	 var re766_0_ = "$1"+nbspChar+"$3"+nbspChar+"$5 ";
 var count_765 = 0;
// + повтор №122 для небольшой поправки


       //   Число + слово

// XXI век и XX съезд
 var re770 = new RegExp("([IVX])\\\s{0,1}(в\\\.|вв\\\.|век|съезд)","g");
 var re770_ = "$1"+nbspChar+"$2";
 var count_770 = 0;

// 5 лет
 var re771 = new RegExp("(\\\d)\\\s{0,1}(раз|секунд|минут|час|день|дня|дней|недел|месяц|лет|век|год)(?=[а-я]{0,3}([<,\\\.;…:\\\?!“»”\\\"\\\)\\\]\\\s]|"+nbspChar+"|$))","g");
 var re771_ = "$1"+nbspChar+"$2";
 var count_771 = 0;

// 16 кило
 var re772 = new RegExp("(\\\d)\\\s{0,1}(микро|мили|санти|кило|мега|гига|метр|грамм|градус|гектар|Ватт|Герц|карат|литр|миля|миль|тонн|Вольт|дюйм|фут|верст|фунт|пуд)","g");
 var re772_ = "$1"+nbspChar+"$2";
 var count_772 = 0;


       //

// Удаление лишних конечных точек в заголовках
// Исключения:     |  !..  |  т. к.  |  Булгаков М.А.  |  популярные сокращения  |
 var re790 = new RegExp("\\\.("+fIB+"){0,1}$","g");
 var re790ex = new RegExp("(([\\\?!\\\.])|((\\\s|"+nbspChar+"|[\\\.\\\-–])([A-ZА-ЯЁ]|Вл|Дж|вв|вел|гг|гл|др|инк|кн|мес|мин|мл|млн|млрд|обл|окр|пр|руб|сек|соч|ст|стр|тыс|чел|шт|экз|янв|фев|мар|апр|июн|июл|авг|сен|окт|дек|янв|etc|Inc)))\\\.("+fIB+"){0,1}$","gi");
 var re790_ = "$1";
 var count_790 = 0;
	// без тегов
	 var re790_0 = new RegExp("\\\.$","g");
	 var re790ex_0 = new RegExp("(([\\\?!\\\.])|((\\\s|"+nbspChar+"|[\\\.\\\-–])([A-ZА-ЯЁ]|Вл|Дж|вв|вел|гг|гл|др|инк|кн|мес|мин|мл|млн|млрд|обл|окр|пр|руб|сек|соч|ст|стр|тыс|чел|шт|экз|янв|фев|мар|апр|июн|июл|авг|сен|окт|дек|янв|etc|Inc)))\\\.$","gi");
	 var re790_0_ = "";

// ---------------------------------------------------------------
/// СТАНДАРТИЗАЦИЯ ТЕГОВ курсива и жирности  (окончание)  :  операции  № 8хх
// ---------------------------------------------------------------

// Выделение забытых знаков препинания в выделенном абзаце
 var re801ex = new RegExp("^("+sIB+")([^<]{0,})("+fIB+")$","g");
 var re801 = new RegExp("^([^А-яA-Za-zЁё0-9]{0,5})("+sIB+")([^<]{0,})("+fIB+")([^А-яA-Za-zЁё0-9]{0,5})$","g");
 var re801_ = "$2$1$3$5$4";
 var count_801 = 0;

// Выделение забытых знаков препинания в выделенном начале абзаца
 var re802 = new RegExp("^([«\\\"]){0,1}(—"+nbspChar+"){0,1}([\\\(\\\[«\\\"]){0,1}(…){0,1}("+sIB+")([^<]{0,})("+fIB+")([\\\.,…;:!\\\?]{1,3})","g");
 var re802_ = "$1$2$3$5$4$6$8$7";
 var count_802 = 0;

// Выделение забытых знаков препинания в предложении (или в выделенном начале предложения)
 var re803 = new RegExp("([…\\\.,:;\\\?!]"+nbspChar+"—\\\s|[…\\\.\\\?!]\\\s)([\\\(\\\[«\\\"]){0,1}(…){0,1}("+sIB+")([А-ЯA-ZЁ0-9][^<]{0,})("+fIB+")([\\\.,…;:!\\\?]{1,3})","g");
 var re803_ = "$1$2$4$3$5$7$6";
 var count_803 = 0;

// -------------

//  Восстановление длинного тире между названиями
//      "Москва—Кассиопея";
 var reNm2 = new RegExp(FalseTire,"g");
 var reNm2_ = "—";

//  Восстановление дефиса рядом с цифрами
 var reDN2 = new RegExp(FalseDefis,"g");
 var reDN2_ = "-";

// ---------------------------------------------------------------
/// ПОСТОБРАБОТКА (поиск)  :  операции  № 9хх
// ---------------------------------------------------------------

 var firstHandleP = true;      //  индикатор первой обработки

// Исправление ошибочного добавления градуса Цельсия (°C)
 var re901s = new RegExp("[\\\d](\\\s|"+nbspChar+")°[CС][А-яA-Za-zЁё]","g");  //  стартовая
 var m901 = [];                 //  найденные строки с ошибками
 var m901_N = [];            //  номера этих строк
 var count_m901 = 0;      //  счетчик элементов массива

// Заглавная буква посреди слова ››› ударение
 var re911s = new RegExp("[а-яё][АЕИОУЫЭЮЯ]","g");  //  стартовая
 var re911s2 = new RegExp("(^|[^А-яA-Za-zЁё0-9])[А-Я]{0,1}[а-яё]{1,30}[АЕИОУЫЭЮЯ][а-яё]{0,30}([^А-яA-Za-zЁё0-9]|$)","g");  //  стартовая 2
 var m911 = [];                 //  найденные строки с ошибками
 var m911_N = [];            //  номера этих строк
 var count_m911 = 0;      //  счетчик элементов массива

// Р а з р я д к а   ›››   курсив
 var re921s = new RegExp("(^|\\\s|"+nbspChar+"|[…\\\(\\\[«„“\\\"–>])([А-яA-Za-zЁё]–{0,1}|[А-ЯA-ZЁ]\\\.)(\\\s|"+nbspChar+")(–{0,1}[А-яA-Za-zЁё—]–{0,1}|–{0,1}[А-ЯA-ZЁ]\\\.)(\\\s|"+nbspChar+"|\\\-)–{0,1}[А-яA-Za-zЁё](\\\s|"+nbspChar+"|[<…\\\.,:;\\\?!\\\)\\\]»”\\\"–]|$)","g");  //  стартовая
 var m921 = [];                 //  найденные строки с ошибками
 var m921_N = [];            //  номера этих строк
 var count_m921 = 0;      //  счетчик элементов массива


// * Восстановление адресов и формата код проходит без использования рег. выражений


// ------------------------

// Возвращение кода   "&nbsp;"
 var reNBSPon = new RegExp(nbspChar,"g");
 var reNBSPon_ = nbspEntity;

// ------------------------


//  Счетчик измененных абзацев
 var count_GU = 0;  // счетчик
 var m_GU = [];  // массив с индикаторами изменения каждой строки

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОБРАБОТКА ТЕКСТА
                 //      (сборка функции "HandleP")

 var s_="";  //   Копия абзаца (для проверки изменений в строке, для операций)
 var s0="";  //   Копия абзаца (для проверки изменений в строке, для "Cycle")
 var sct="";  // Копия абзаца без тегов (для поиска)

//  для общего цикла
 var count_Cycle=1;  //  счетчик рекордного числа циклов
 var count_Cycle_=0;  //  счетчик циклов для текущей строки
 var count_Cycle_max=100;   //  ограничитель числа циклов

 var count_P= 0;  //  счетчик строк


 //////// функция, обрабатывающая абзац P
 function HandleP(ptr) {

   s=ptr.innerHTML;

   if (nbspEntity=="&nbsp;"  &&  s.search(reNBSPoff)!=-1)  s=s.replace(reNBSPoff, reNBSPoff_);  //  замена кода н/р пробела на обычный символ (времено)

   count_P++;


/// СКРЫТИЕ АДРЕСОВ И ФОРМАТА КОД

//  Удаление   кода   из абзаца и его сохранение в массиве
   if (!R_Code  &&  s.search(/</g)!=-1  &&  s.search(reCode1)!=-1) {
           mCode=s.match(reCode1);  //  Сохранение
           count_Code+=mCode.length;
           Code_=true;
           s=s.replace(reCode1, reCode1_) }  //  Удаление
       else  Code_=false;

   if (s.search(re011)!=-1)  { count_011+=s.match(re011).length; s=s.replace(re011, re011_) }
   while (s.search(re012)!=-1)  { count_012+=s.match(re012).length; s=s.replace(re012, re012_) }

//  Удаление   эл.адреса (активного) и его сохранение в массиве
   if (s.search(reUrl1_s)!=-1  &&  s.search(reUrl1)!=-1) {
           mUrl1=s.match(reUrl1);  //  Сохранение
           count_Url1+=mUrl1.length;
           Url1_=true;
           s=s.replace(reUrl1, reUrl1_) }  //  Удаление
       else  Url1_=false;

//  Удаление   эл.адреса (в тексте) и его сохранение в массиве
   if (s.search(reUrl3)!=-1) {
           while (s.search(re021)!=-1) { count_021+=s.match(re021).length; s=s.replace(re021, re021_) }  //  удаление пробела перед "%"
           if (s.search(reUrl3)!=-1) {
                   mUrl3=s.match(reUrl3)  //  Сохранение
                   count_Url3+=mUrl3.length;
                   Url3_=true;
                   s=s.replace(reUrl3, reUrl3_);  //  Удаление
                   }
           else  Url3_=false;
           }
       else  Url3_=false;

s0="";
count_Cycle_=0;
while (s0 !=s  &&  count_Cycle_ <count_Cycle_max)  {      //   Повторение блока операций, пока после обработки в параграфе не будет никаких изменений
   s0=s;
   count_Cycle_++;


/// ПОИСК

   if (s.search(/</g)!=-1)  {
           Tag_=true;
           sct=s.replace(reCT, reCT_);  //  Создание копии абзаца без тегов  //  Актуальна до первого изменения оригинального абзаца
           Em_=(s.search(reEm)!=-1);      // курсив
           St_=(s.search(reSt)!=-1);      // жирность
           EmSt_=(Em_ || St_);         // курсив и жирность
           SubSup_=(s.search(reSubSup)!=-1);      // индексы
           NoCom_=(s.search(reNoCom)!=-1)         // все сноски
           }
           else  { Tag_=Em_=St_=EmSt_=NoCom_=SubSup_=false;  sct=s }

   poem_=(ptr.parentNode.className=="stanza");         //   стихи
   QQ_= (sct.search(reQQ)!=-1);         //   «   »
   QuQu_= (sct.search(reQuQu)!=-1);         // поиск всех кавычек
   TiDe_= (sct.search(reTiDe)!=-1);         // поиск всех тире и дефисов  //  поиск отдельных символов производится после замены ряда дефисов/тире (№152)
   TTT_= (sct.search(reTTT)!=-1);         //   …
   P41_= (sct.search(reP41)!=-1);         //   неразрывные пробелы
   P43_= (sct.search(reP43)!=-1);         //   !  ?
   P48_= (sct.search(reP48)!=-1);         //   :;
   NN_= (sct.search(reNN)!=-1)         // числа
   XXI_=(sct.search(reXXI)!=-1)       // римские числа
   Sokr_= (sct.search(reSokr)!=-1);         //   сокращение + пробел


/// ВАЛИДАЦИЯ ЗНАКОВ ПРЕПИНАНИЯ И Т.П.  :  операции  № 1хх

   if (s.search(re101)!=-1)  { count_101+=s.match(re101).length; s=s.replace(re101, re101_) }
   if (s.search(re102)!=-1)  {
           count_102+=s.match(re102).length;
           s=s.replace(re102, re102_);
           if (poem_  &&  s.search(re102a)!=-1)  { s=s.replace(re102a, re102a_); P41_=true }    }
   if (s.search(re103)!=-1)  { count_103+=s.match(re103).length; s=s.replace(re103, re103_); P41_=true }
   if (s.search(re104)!=-1)  { count_104+=s.match(re104).length; s=s.replace(re104, re104_); TiDe_=true }
   if (s.search(re105)!=-1)  { count_105+=s.match(re105).length; s=s.replace(re105, re105_); TiDe_=true }
   if (s.search(re106)!=-1)  { count_106+=s.match(re106).length; s=s.replace(re106, re106_) }
   if (s.search(re107)!=-1)  { count_107+=s.match(re107).length; s=s.replace(re107, re107_) }
   if (s.search(re108)!=-1)  { count_108+=s.match(re108).length; s=s.replace(re108, re108_); QuQu_=true }
   if (s.search(re109)!=-1)  { count_109+=s.match(re109).length; s=s.replace(re109, re109_) }
   if (s.search(re110s)!=-1)  {                         //  Если найден любой символ дроби...
           if (Drobi)  k=0;  else  k=3;                           //  в зависимости от настроек, пропускаем первые 3 символа
           for (; k<15; k++)                                            //  и запускаем цикл,
                   if (s.search(m110re[k])!=-1) {                     //  в котором ищем каждый символ по отдельности, и если он найден...
                           count_110+=s.match(m110re[k]).length;   //  то увеличиваем счетчик
                           s=s.replace(m110re[k], m110re_[k]);          //  и заменяем найденный символ на обычную запись.
                           }
           }
   if (s.search(re111s)!=-1)  {                         //  Если найден любой символ надстрочной цифры...
           if (Nadstrochnye)  k=0;  else  k=2;         //  в зависимости от настроек, пропускаем первые 2 символа
           for (; k<10; k++)                                          //  и запускаем цикл,
                   if (s.search(m111re[k])!=-1) {                    //  в котором ищем каждый символ по отдельности, и если он найден...
                           count_111+=s.match(m111re[k]).length;   //  то увеличиваем счетчик
                           s=s.replace(m111re[k], m111re_[k]);          //  и заменяем найденный символ на обычную запись.
                           }
           }
   if (s.search(re112s)!=-1)  {                              //  Если найден любой символ подстрочной цифры...
           count_112+=s.match(re112s).length;             //  увеличиваем счетчик
           for (k=0; k<10; k++)                                                   //  и запускаем цикл,
                   if (s.search(m112re[k])!=-1)                           //  в котором ищем каждый символ по отдельности
                           s=s.replace(m112re[k], m112re_[k]);   //  и заменяем его на обычную запись.
           }
   if (s.search(re114)!=-1)  {                             //  Если найден спец. символ, похожий на "/"...
           count_114+=s.match(re114).length;   //  увеличиваем счетчик
           s=s.replace(re114, re114_);                    //  и заменяем его на обычный символ "/".
           }
   if (s.search(re116)!=-1)  {
           count_116+=s.match(re116).length;
           s=s.replace(re116, re116_);
           if (s.search(/&nbsp;/)!=-1) {
                   P41_=true;
                   if (nbspEntity=="&nbsp;")
                           s=s.replace(reNBSPoff, reNBSPoff_); }    }
   if (nbspEntity!="&nbsp;"  &&  s.search(re117)!=-1)  { count_117+=s.match(re117).length; s=s.replace(re117, re117_); P41_=true }
   if (s.search(re118s)!=-1  &&  s.search(re118)!=-1)  { count_118+=s.match(re118).length; s=s.replace(re118, re118_) }
   while (Tag_  &&  s.search(re119)!=-1)  { count_119+=s.match(re119).length; s=s.replace(re119, re119_) }
   if (!poem_) {
           if (s.search(re120)!=-1)  { count_120+=s.match(re120).length; s=s.replace(re120, re120_) }
           if (s.search(re121)!=-1)  { count_121++; s=s.replace(re121, re121_) }    }
   if (s.search(re122)!=-1)  { count_122++; s=s.replace(re122, re122_) }

   if (s.search(re129ex1)==-1  &&  s.search(re129ex2)==-1    ||    s.search(re129ex_ex)!=-1)
{   // Начало ряда формул, которые будут пропущены для тех строк, которые целиком состоят из некоторых символов


   if (s.search(re130)!=-1)  { count_130+=s.match(re130).length; s=s.replace(re130, re130_); TTT_=true }
   if (TTT_  &&  s.search(re131)!=-1)  { count_131+=s.match(re131).length; s=s.replace(re131, re131_) }
   if (P43_)  {
           if (s.search(re132)!=-1)  { count_132+=s.match(re132).length; s=s.replace(re132, re132_) }
           if (s.search(re133)!=-1)  { count_133+=s.match(re133).length; s=s.replace(re133, re133_) }    }
   if (s.search(re140)!=-1)  { count_140+=s.match(re140).length; s=s.replace(re140, re140_); TTT_=true }
   if (s.search(re141)!=-1)  { count_140+=s.match(re141).length; s=s.replace(re141, re141_); TTT_=true }
   if (s.search(re150)!=-1)  { count_150+=s.match(re150).length; s=s.replace(re150, re150_) }
   if (TiDe_  &&  s.search(re152)!=-1)  { count_152+=s.match(re152).length; s=s.replace(re152, re152_) }


//  повторный поиск в измененном оригинальном абзаце
   Def_= (s.search(reDef)!=-1);      //   -
   Tire_= (s.search(reTire)!=-1);      //   —
   KTi_= (s.search(reKTi)!=-1);      //   –
//---------------

   if (sct.search(re155s)!=-1)  {
           if_156=if_155=false;
           if (_format_ !=0  &&  Otvet_155  &&  s.search(re155)!=-1)  {
                   m155=s.match(re155);
                   s=s.replace(re155, FalseSim);
                   for (n=0; n<m155.length; n++)  {
                           if (m155[n].search(re155_2ex) ==-1  &&  Dopusk_155())  {
                                   m155[n]= m155[n].replace(re155_2, re155_2_);
                                   m155[n]= m155[n].replace(re155_3, "");
                                   Em_=EmSt_=if_155=true;
                                   count_155++;    }
                           s= s.replace(FalseSim, m155[n]);
                           }
                   }
           if (_f_o_r_m_a_t_ !=0  &&  Otvet_156  &&  s.search(re156)!=-1)  {
                   m156=s.match(re156);
                   s=s.replace(re156, FalseSim);
                   for (n=0; n<m156.length; n++)  {
                           if (m156[n].search(re156_2ex) ==-1  &&  m156[n].match(/_/g).length >1  &&  Dopusk_156())  {
                                   m156[n]= m156[n].replace(re156_2, re156_2_);
                                   m156[n]= m156[n].replace(re156_3, "");
                                   St_=EmSt_=if_156=true;
                                   count_156++;    }
                           s= s.replace(FalseSim, m156[n]);
                           }
                   }
           if (_format_ !=0  &&  Otvet_155  &&  s.search(re157)!=-1)  {
                   m157=s.match(re157);
                   s=s.replace(re157, FalseSim);
                   for (n=0; n<m157.length; n++)  {
                           if (m157[n].search(re157_2ex) ==-1  &&  Dopusk_155())  {
                                   m157[n]= m157[n].replace(re157_2, re157_2_);
                                   m157[n]= m157[n].replace(re157_3, re157_3_);
                                   m157[n]= m157[n].replace(/_/g, " ");
                                   Em_=EmSt_=if_155=true;
                                   count_157++;    }
                           s= s.replace(FalseSim, m157[n]);
                           }
                   }
           if (_bukva_ !=0  &&  Otvet_158  &&  s.search(re158)!=-1)  {
                   m158=s.match(re158);
                   s=s.replace(re158, FalseSim);
                   for (n=0; n<m158.length; n++)  {
                           switch (_bukva_) {
                               case 1:  EmSt_158 = "кур";  break;
                               case 2:  EmSt_158 = "жир";  break;
                               case 3:  EmSt_158 = "ж-к";  break;
                               case 4:
                                   if (if_156)  switch (_f_o_r_m_a_t_) { case 1:  EmSt_158 = "кур";  break;  case 2:  EmSt_158 = "жир";  break;  case 3:  EmSt_158 = "ж-к"; }
                                       else if (if_155)  switch (_format_) { case 1:  EmSt_158 = "кур";  break;  case 2:  EmSt_158 = "жир";  break;  case 3:  EmSt_158 = "ж-к"; }
                                           else if (BI_158 == "Ж")  EmSt_158 = "жир";
                                               else if (BI_158 == "ЖК")  EmSt_158 = "ж-к";
                                                   else if (BI_158 == "К")  EmSt_158 = "кур";
                                                       else if (count_156!=0)  switch (_f_o_r_m_a_t_) { case 1:  EmSt_158 = "кур";  break;  case 2:  EmSt_158 = "жир";  break;  case 3:  EmSt_158 = "ж-к"; }
                                                           else if (count_155!=0  ||  count_157!=0)  switch (_format_) { case 1:  EmSt_158 = "кур";  break;  case 2:  EmSt_158 = "жир";  break;  case 3:  EmSt_158 = "ж-к"; }
                                                               else if (!StAll  &&  (_format_==2  ||  _f_o_r_m_a_t_==2))  EmSt_158 = "жир";
                                                                   else if (!EmStAll  &&  (_format_==3  ||  _f_o_r_m_a_t_==3))  EmSt_158 = "ж-к";
                                                                       else if (!EmAll  &&  (_format_==1  ||  _f_o_r_m_a_t_==1))  EmSt_158 = "кур";
                                                                           else if (Dopusk_156())  switch (_f_o_r_m_a_t_) { case 1:  EmSt_158 = "кур";  break;  case 2:  EmSt_158 = "жир";  break;  case 3:  EmSt_158 = "ж-к"; }
                                                                               else if (Dopusk_155())  switch (_format_) { case 1:  EmSt_158 = "кур";  break;  case 2:  EmSt_158 = "жир";  break;  case 3:  EmSt_158 = "ж-к"; }
                                                                                   else  { s= s.replace(FalseSim, m158[n]);  continue }  //  возвращение в текст неизмененного фрагмента, и переход на следующий фрагмент
                               }

                           if (!Dopusk_158())  { s= s.replace(FalseSim, m158[n]);  continue }
                           switch (EmSt_158) {
                               case "жир":  m158[n]= m158[n].replace(re158_2, re158_2_St);  St_=true;  if (BI_158 == "")  BI_158 = "Ж"; count_158st++;  break;
                               case "кур":  m158[n]= m158[n].replace(re158_2, re158_2_Em);  Em_=true;  if (BI_158 == "")  BI_158 = "К"; count_158em++;  break;
                               case "ж-к":  m158[n]= m158[n].replace(re158_2, re158_2_EmSt);  Em_=true;  St_=true;  if (BI_158 == "")  BI_158 = "ЖК"; count_158emst++;
                               }
                           m158[n]= m158[n].replace(re158_3, "");
                           s= s.replace(FalseSim, m158[n]);  //  возвращение исправленного фрагмента
                           EmSt_=true;
                           }
                   }
           }  //  конец для № 155-158

   if (EmSt_)  { if (s.search(re172)!=-1)  { count_172++; s=s.replace(re172, re172_) }    }
        else  { if (s.search(re172_0)!=-1)  { count_172++; s=s.replace(re172_0, re172_0_) }    }
   if (EmSt_)  { if (s.search(re173)!=-1)  { count_172++; s=s.replace(re173, re173_) }    }
        else  { if (s.search(re173_0)!=-1)  { count_172++; s=s.replace(re173_0, re173_0_) }    }
   if (EmSt_)  { if (s.search(re174)!=-1)  { count_172++; s=s.replace(re174, re174_) }    }
        else  { if (s.search(re174_0)!=-1)  { count_172++; s=s.replace(re174_0, re174_0_) }    }
   if (s.search(re180)!=-1)  { count_180+=s.match(re180).length; s=s.replace(re180, re180_) }
   if (s.search(re181)!=-1)  { count_180+=s.match(re181).length; s=s.replace(re181, re181_) }
   if (s.search(re182)!=-1)  { count_182+=s.match(re182).length; s=s.replace(re182, re182_) }


/// СТАНДАРТИЗАЦИЯ ТЕГОВ  :  операции  № 2хх

   if (EmSt_)  {
           while (s.search(re201)!=-1)  { count_201+=s.match(re201).length; s=s.replace(re201, re201_) }     }
   if (SubSup_)  {
           while (s.search(re202)!=-1)  { count_202+=s.match(re202).length; s=s.replace(re202, re202_) }     }
   if (Tag_)  {
           if (s.search(re203)!=-1) {
                   if (Url3_)
                           for (n=0; s.search(UrlFalse3)!=-1; n++)
                                   s=s.replace(UrlFalse3, mUrl3[n]);
                   if (Url1_)
                           for (n=0; s.search("href=\""+UrlFalse1)!=-1; n++)
                                   s=s.replace("href=\""+UrlFalse1, mUrl1[n]);
                   while (s.search(re203)!=-1)  { count_203+=s.match(re203).length; s=s.replace(re203, re203_) }
                   if (Url1_  &&  s.search(reUrl1_s)!=-1  &&  s.search(reUrl1)!=-1) {
                           mUrl1=s.match(reUrl1);
                           Url1_=true;
                           s=s.replace(reUrl1, reUrl1_) }
                       else  Url1_=false;
                   if (Url3_  &&  s.search(reUrl3)!=-1) {
                           mUrl3=s.match(reUrl3)
                           Url3_=true;
                           s=s.replace(reUrl3, reUrl3_) }
                       else  Url3_=false;
                   }
           while (s.search(re204)!=-1)  { count_204+=s.match(re204).length; s=s.replace(re204, re204_) }
           }
   if (EmSt_)  {
           while (s.search(re205)!=-1)  { count_205+=s.match(re205).length; s=s.replace(re205, re205_) }
           if (Em_  &&  St_)   {
                   if (s.search(re215s)!=-1)  {
                           if (s.search(re215)!=-1)  { s=s.replace(re215, re215_) }
                           while (s.search(re201)!=-1)  { count_215+=s.match(re201).length; s=s.replace(re201, re201_) }     }  //  повтор №201
                   if (s.search(re216s)!=-1)  {
                           if (s.search(re216)!=-1)  { s=s.replace(re216, re216_) }
                           while (s.search(re201)!=-1)  { count_215+=s.match(re201).length; s=s.replace(re201, re201_) }     }     }  //  повтор №201
           if (Ud_on_off != 0)  {
                   if (s.search(re220s)!=-1)  {
                           if (s.search(re220)!=-1)  { count_220+=s.match(re220).length; s=s.replace(re220, re220_) }
                           if (s.search(re221)!=-1)  { count_220+=s.match(re221).length; s=s.replace(re221, re221_) }     }
                   if (s.search(re222s)!=-1  &&  s.search(re222)!=-1)  {
                           s=s.replace(re222, re222_);
                           m223=s.match(re223);
                           count_220+=m223.length;
                           for (n=0; n<m223.length; n++)
                                   s=s.replace(re224, m223[n].toLowerCase()+Ud) }    }
           while (s.search(re241)!=-1)  { count_241+=s.match(re241).length; s=s.replace(re241, re241_) }
           if (sct.search(/\[/g)!=-1)   {
                   if (s.search(re250)!=-1)  { count_250+=s.match(re250).length; s=s.replace(re250, re250_) }
                   if (s.search(re251)!=-1)  { count_251+=s.match(re251).length; s=s.replace(re251, re251_) }    }
           if (sct.search(/\(/g)!=-1)   {
                   if (s.search(re252)!=-1)  { count_250+=s.match(re252).length; s=s.replace(re252, re252_) }
                   if (s.search(re253)!=-1)  { count_251+=s.match(re253).length; s=s.replace(re253, re253_) }    }
           if (QQ_)   {
                   if (s.search(re255)!=-1) { count_255+=s.match(re255).length; s=s.replace(re255, re255_) }
                   if (s.search(re256)!=-1) { count_255+=s.match(re256).length; s=s.replace(re256, re256_) }    }
           if (s.search(re260)!=-1)  { count_260+=s.match(re260).length; s=s.replace(re260, re260_) }
           if (NoCom_  &&  s.search(re270)!=-1)  { count_270+=s.match(re270).length; s=s.replace(re270, re270_) }
           }


/// РЕЖИМЫ  :  операции  № 3хх

   if (count_Cycle_ ==1)  {         //  только для первой обработки
           if (!R_Def  &&  Def_)  {
                   if (EmSt_)  {  if (s.search(re301)!=-1)  { count_301+=s.match(re301).length; s=s.replace(re301, re301_) }    }
                        else  {  if (s.search(re301_0)!=-1)  { count_301+=s.match(re301).length; s=s.replace(re301_0, re301_0_) }    }
                   if (EmSt_)  {  if (s.search(re302)!=-1)  { count_301+=s.match(re302).length; s=s.replace(re302, re302_) }    }
                        else  {  if (s.search(re302_0)!=-1)  { count_301+=s.match(re302).length; s=s.replace(re302_0, re302_0_) }    }    }
           if (!R_Tire  &&  Tire_)  {
                   if (EmSt_)  {  if (s.search(re310)!=-1)  { count_310+=s.match(re310).length; s=s.replace(re310, re310_) }    }
                        else  {  if (s.search(re310_0)!=-1)  { count_310+=s.match(re310).length; s=s.replace(re310_0, re310_0_) }    }
                   if (EmSt_)  {  if (s.search(re311)!=-1)  { count_310+=s.match(re311).length; s=s.replace(re311, re311_) }    }
                        else  {  if (s.search(re311_0)!=-1)  { count_310+=s.match(re311).length; s=s.replace(re311_0, re311_0_) }    }
                   if (EmSt_)  {  if (s.search(re312)!=-1)  { count_312+=s.match(re312).length; s=s.replace(re312, re312_) }    }
                        else  {  if (s.search(re312_0)!=-1)  { count_312+=s.match(re312).length; s=s.replace(re312_0, re312_0_) }    }    }
           if (R_KTi  &&  KTi_)  {
                   if (EmSt_)  { if (s.search(re320)!=-1)  { count_320+=s.match(re320).length; s=s.replace(re320, re320_) }    }
                        else  { if (s.search(re320_0)!=-1)  { count_320+=s.match(re320_0).length; s=s.replace(re320_0, re320_0_) }    }    }
               else  {
                       if (EmSt_)  { if (s.search(re321)!=-1)  { count_321+=s.match(re321).length; s=s.replace(re321, re321_) }    }
                            else  { if (s.search(re321_0)!=-1)  { count_321+=s.match(re321_0).length; s=s.replace(re321_0, re321_0_) }    }    }
           while (s.search(reNm1s) != -1  &&  s.search(reNm1) != -1)  {  countNm+=s.match(reNm1).length;  s=s.replace(reNm1, reNm1_); }
           }


//  повторный поиск в измененном оригинальном абзаце
   Def_= (s.search(reDef)!=-1);      //   -
   Tire_= (s.search(reTire)!=-1);      //   —
   KTi_= (s.search(reKTi)!=-1);      //   –
//---------------


/// ПУНКТУАЦИЯ (без тире)  :  операции  № 4хх

   if (QuQu_  &&  s.search(re401)!=-1)  { count_401++; s=s.replace(re401, re401_); QQ_=true }
   if (TTT_)  {
           if (EmSt_)  { if (s.search(re402)!=-1)  { count_402++; s=s.replace(re402, re402_) }    }
                 else  { if (s.search(re402_0)!=-1)  { count_402++; s=s.replace(re402_0, re402_0_) }    }    }
   if (QuQu_  &&  s.search(re410)!=-1)  { count_410++; s=s.replace(re410, re410_); QQ_=true }
   if (TTT_)  {
           if (EmSt_)  { if (s.search(re411)!=-1)  { count_411++; s=s.replace(re411, re411_) }    }
                 else  { if (s.search(re411_0)!=-1)  { count_411++; s=s.replace(re411_0, re411_0_) }    }    }
   if (EmSt_)  { if (s.search(re420)!=-1)  {
                   count_420+=s.match(re420).length; s=s.replace(re420, re420_);
                   if (s.search(re150)!=-1)  { count_150+=s.match(re150).length; s=s.replace(re150, re150_) }    }    }   // повтор №150
       else  { if (s.search(re420_0)!=-1)  {
                   count_420+=s.match(re420_0).length; s=s.replace(re420_0, re420_0_);
                   if (s.search(re150)!=-1)  { count_150+=s.match(re150).length; s=s.replace(re150, re150_) }    }    }   // повтор №150
   if (P48_)  {
           if (EmSt_)  { if (s.search(re421)!=-1)  { count_420+=s.match(re421).length; s=s.replace(re421, re421_) }    }
               else  { if (s.search(re421_0)!=-1)  { count_420+=s.match(re421_0).length; s=s.replace(re421_0, re421_0_) }    }
           if (EmSt_)  { if (s.search(re421a)!=-1)  { count_420+=s.match(re421a).length; s=s.replace(re421a, re421a_) }    }
               else  { if (s.search(re421a_0)!=-1)  { count_420+=s.match(re421a_0).length; s=s.replace(re421a_0, re421a_0_) }    }    }
   if (P43_)  {
           if (EmSt_)  { if (s.search(re422)!=-1)  { count_420+=s.match(re422).length; s=s.replace(re422, re422_) }    }
               else  { if (s.search(re422_0)!=-1)  { count_420+=s.match(re422_0).length; s=s.replace(re422_0, re422_0_) }    }    }
   if (s.search(re423)!=-1)  {
           count_420+=s.match(re423).length; s=s.replace(re423, re423_);
           if (s.search(re150)!=-1)  { count_150+=s.match(re150).length; s=s.replace(re150, re150_) }    }   // повтор №150
   if (NoCom_  &&  s.search(re424)!=-1)  { count_424+=s.match(re424).length; s=s.replace(re424, re424_) }
   if (TTT_)  {
           if (s.search(re425)!=-1)  { count_425+=s.match(re425).length; s=s.replace(re425, re425_) }
           if (EmSt_)  { if (s.search(re426)!=-1)  { count_425+=s.match(re426).length; s=s.replace(re426, re426_) }    }
                 else  { if (s.search(re426_0)!=-1)  { count_425+=s.match(re426_0).length; s=s.replace(re426_0, re426_0_) }    }    }
   if (QuQu_)  {
           if (EmSt_)  { if (s.search(re431)!=-1)  { count_431+=s.match(re431).length; s=s.replace(re431, re431_); QQ_=true }    }
                 else  { if (s.search(re431_0)!=-1)  { count_431+=s.match(re431_0).length; s=s.replace(re431_0, re431_0_); QQ_=true }    }
           if (EmSt_)  { if (s.search(re432)!=-1)  { count_432+=s.match(re432).length; s=s.replace(re432, re432_); QQ_=true }    }
                 else  { if (s.search(re432_0)!=-1)  { count_432+=s.match(re432_0).length; s=s.replace(re432_0, re432_0_); QQ_=true }    }
           if (EmSt_)  { if (s.search(re433)!=-1)  { count_432+=s.match(re433).length; s=s.replace(re433, re433_); QQ_=true }    }
                 else  { if (s.search(re433_0)!=-1)  { count_432+=s.match(re433_0).length; s=s.replace(re433_0, re433_0_); QQ_=true }    }    }
   if (s.search(re440)!=-1)  { count_440+=s.match(re440).length; s=s.replace(re440, re440_) }
   if (NoCom_  &&  s.search(re441)!=-1)  { count_441+=s.match(re441).length; s=s.replace(re441, re441_) }
   if (EmSt_)  { if (s.search(re450)!=-1)  { count_450+=s.match(re450).length; s=s.replace(re450, re450_) }    }
        else  { if (s.search(re450_0)!=-1)  { count_450+=s.match(re450_0).length; s=s.replace(re450_0, re450_0_) }    }
   if (NN_)  {
           if (EmSt_)  { if (s.search(re450a)!=-1)  { count_450+=s.match(re450a).length; s=s.replace(re450a, re450a_) }    }
                else  { if (s.search(re450a_0)!=-1)  { count_450+=s.match(re450a_0).length; s=s.replace(re450a_0, re450a_0_) }    }    }
   if (P43_)  {
           if (EmSt_)  { if (s.search(re451)!=-1)  { count_450+=s.match(re451).length; s=s.replace(re451, re451_) }    }
                else  { if (s.search(re451_0)!=-1)  { count_450+=s.match(re451_0).length; s=s.replace(re451_0, re451_0_) }    }    }
   if (P48_)  {
           if (EmSt_)  { if (s.search(re453)!=-1)  { count_450+=s.match(re453).length; s=s.replace(re453, re453_) }    }
                else  { if (s.search(re453_0)!=-1)  { count_450+=s.match(re453_0).length; s=s.replace(re453_0, re453_0_) }    }    }
   if (EmSt_)  { if (s.search(re454)!=-1)  { count_450+=s.match(re454).length; s=s.replace(re454, re454_) }    }
        else  { if (s.search(re454_0)!=-1)  { count_450+=s.match(re454_0).length; s=s.replace(re454_0, re454_0_) }    }
   if (NN_)  {
           if (EmSt_)  { if (s.search(re454a)!=-1)  { count_450+=s.match(re454a).length; s=s.replace(re454a, re454a_) }    }
                else  { if (s.search(re454a_0)!=-1)  { count_450+=s.match(re454a_0).length; s=s.replace(re454a_0, re454a_0_) }    }    }
   if (EmSt_)  { if (s.search(re455)!=-1)  { count_450+=s.match(re455).length; s=s.replace(re455, re455_) }    }
        else  { if (s.search(re455_0)!=-1)  { count_450+=s.match(re455_0).length; s=s.replace(re455_0, re455_0_) }    }
   if (QuQu_)  {
           if (EmSt_)  { if (s.search(re460)!=-1)  { count_460+=s.match(re460).length; s=s.replace(re460, re460_) }    }
                 else  { if (s.search(re460_0)!=-1)  { count_460+=s.match(re460_0).length; s=s.replace(re460_0, re460_0_) }    }    }
   if (NoCom_)  {
           if (QuQu_)  {
                   if (EmSt_)  { if (s.search(re470)!=-1)  { count_470+=s.match(re470).length; s=s.replace(re470, re470_) }    }
                         else  { if (s.search(re470_0)!=-1)  { count_470+=s.match(re470_0).length; s=s.replace(re470_0, re470_0_) }    }    }
           if (EmSt_)  { if (s.search(re471)!=-1)  { count_471+=s.match(re471).length; s=s.replace(re471, re471_) }    }
                 else  { if (s.search(re471_0)!=-1)  { count_471+=s.match(re471_0).length; s=s.replace(re471_0, re471_0_) }    }
           if (EmSt_)  { if (s.search(re472)!=-1)  { count_472+=s.match(re472).length; s=s.replace(re472, re472_) }    }
                 else  { if (s.search(re472_0)!=-1)  { count_472+=s.match(re472_0).length; s=s.replace(re472_0, re472_0_) }    }    }


/// ТИРЕ и ДЕФИСЫ  :  операции  № 5хх

   if (TiDe_) {
           if (XXI_) {
                   if (EmSt_)  {
                           if (s.search(re501)!=-1)  { count_501+=s.match(re501).length; s=s.replace(re501, re501_); KTi_=true }
                           if (s.search(re502)!=-1)  { count_501+=s.match(re502).length; s=s.replace(re502, re502_); KTi_=true }    }
                       else  {
                               if (s.search(re501_0)!=-1)  { count_501+=s.match(re501_0).length; s=s.replace(re501_0, re501_0_); KTi_=true }
                               if (s.search(re502_0)!=-1)  { count_501+=s.match(re502_0).length; s=s.replace(re502_0, re502_0_); KTi_=true }    }    }
           while (s.search(re503)!=-1)  { count_503+=s.match(re503).length; s=s.replace(re503, re503_); KTi_=true }
           if (s.search(re504s)!=-1) {
                   while (s.search(re504)!=-1)  { count_504+=s.match(re504).length; s=s.replace(re504, re504_); KTi_=true }
                   while (s.search(re505)!=-1)  { count_504+=s.match(re505).length; s=s.replace(re505, re505_); KTi_=true }    }    }
   if (NN_  &&  s.search(re506)!=-1)  { count_506+=s.match(re506).length; s=s.replace(re506, re506_) }
   if (TiDe_  &&  NN_)  {
           if (s.search(re507s)!=-1  &&  s.search(re507)!=-1) {
                   s_=s;
                   count_507_=s_.match(re507).length;  s_=s_.replace(re507, re507_);
                   if (s!=s_)  { s=s_;  count_507+=count_507_;  KTi_=true }    }
           if (s.search(re508)!=-1)  {
                   s_=s;
                   count_507_=s_.match(re508).length;  s_=s_.replace(re508, re508_);
                   if (s!=s_)  { s=s_;  count_507+=count_507_;  KTi_=true }    }
           if (!saveDef)  {
                   if (EmSt_)  { if (s.search(re510)!=-1)  { count_510+=s.match(re510).length; s=s.replace(re510, re510_); KTi_=true }    }
                        else  { if (s.search(re510_0)!=-1)  { count_510+=s.match(re510_0).length; s=s.replace(re510_0, re510_0_); KTi_=true }    }    }
               else {
                       if (EmSt_)  { if (s.search(re510a)!=-1)  { count_510+=s.match(re510a).length; s=s.replace(re510a, re510a_); KTi_=true }    }
                            else  { if (s.search(re510a_0)!=-1)  { count_510+=s.match(re510a_0).length; s=s.replace(re510a_0, re510a_0_); KTi_=true }    }
                       if (EmSt_)  { if (s.search(reDN1)!=-1)  s=s.replace(reDN1, reDN1_) }
                            else  { if (s.search(reDN1_0)!=-1)  s=s.replace(reDN1_0, reDN1_0_) }
                       }
           if (EmSt_)  { if (s.search(re511)!=-1)  { count_511+=s.match(re511).length; s=s.replace(re511, re511_); Def_=true }    }
                else  { if (s.search(re511_0)!=-1)  { count_511+=s.match(re511_0).length; s=s.replace(re511_0, re511_0_); Def_=true }    }
           if (s.search(re512s)!=-1  &&  s.search(re512)!=-1)  { count_512+=s.match(re512).length; s=s.replace(re512, re512_) }
           if (EmSt_)  { if (s.search(re514)!=-1)  { count_514+=s.match(re514).length; s=s.replace(re514, re514_); KTi_=true }    }
                else  { if (s.search(re514_0)!=-1)  { count_514+=s.match(re514_0).length; s=s.replace(re514_0, re514_0_); KTi_=true }    }    }
   if (Def_)  {
           if (EmSt_)  { if (s.search(re520)!=-1)  { count_520++; s=s.replace(re520, re520_) }    }
                else  { if (s.search(re520_0)!=-1)  { count_520++; s=s.replace(re520_0, re520_0_) }    }
           if (s.search(re521)!=-1)  { count_521+=s.match(re521).length; s=s.replace(re521, re521_) }
           if (EmSt_)  { if (s.search(re530)!=-1)  { count_530+=s.match(re530).length; s=s.replace(re530, re530_) }    }
                else  { if (s.search(re530_0)!=-1)  { count_530+=s.match(re530_0).length; s=s.replace(re530_0, re530_0_) }    }
           if (!NoCom_)  {
                   if (EmSt_)  { if (s.search(re531)!=-1)  { count_530+=s.match(re531).length; s=s.replace(re531, re531_) }    }
                        else  { if (s.search(re531_0)!=-1)  { count_530+=s.match(re531_0).length; s=s.replace(re531_0, re531_0_) }    }    }
               else  {
                       if (EmSt_)  { if (s.search(re531nc)!=-1)  { count_530+=s.match(re531nc).length; s=s.replace(re531nc, re531nc_) }    }
                            else  { if (s.search(re531nc_0)!=-1)  { count_530+=s.match(re531nc_0).length; s=s.replace(re531nc_0, re531nc_0_) }    }    }
           if (!NoCom_)  {
                   if (EmSt_)  { if (s.search(re532)!=-1)  { count_530+=s.match(re532).length; s=s.replace(re532, re532_) }    }
                        else  { if (s.search(re532_0)!=-1)  { count_530+=s.match(re532_0).length; s=s.replace(re532_0, re532_0_) }    }    }
               else  {
                       if (EmSt_)  { if (s.search(re532nc)!=-1)  { count_530+=s.match(re532nc).length; s=s.replace(re532nc, re532nc_) }    }
                            else  { if (s.search(re532nc_0)!=-1)  { count_530+=s.match(re532nc_0).length; s=s.replace(re532nc_0, re532nc_0_) }    }    }
           if (P48_)  {
                   if (EmSt_)  { if (s.search(re533)!=-1)  { count_530+=s.match(re533).length; s=s.replace(re533, re533_) }    }
                        else  { if (s.search(re533_0)!=-1)  { count_530+=s.match(re533_0).length; s=s.replace(re533_0, re533_0_) }    }    }
           if (TTT_)  {
                   if (EmSt_)  { if (s.search(re534)!=-1)  { count_534+=s.match(re534).length; s=s.replace(re534, re534_) }    }
                        else  { if (s.search(re534_0)!=-1)  { count_534+=s.match(re534_0).length; s=s.replace(re534_0, re534_0_) }    }    }
           }

//---------------
  Tire_=(s.search(reTire)!=-1);    //  повторный поиск тире
//---------------

   if (Tire_)  {
           if (EmSt_)  { if (s.search(re550)!=-1)  { count_550+=s.match(re550).length; s=s.replace(re550, re550_) }    }
                else  { if (s.search(re550_0)!=-1)  { count_550+=s.match(re550_0).length; s=s.replace(re550_0, re550_0_) }    }    }
   if (TiDe_ || s.search(/~/g)!=-1)  {
           if (EmSt_)  { if (s.search(re551)!=-1)  { count_551++; s=s.replace(re551, re551_); Tire_=true }    }
                else  { if (s.search(re551_0)!=-1)  { count_551++; s=s.replace(re551_0, re551_0_); Tire_=true }    }    }
   if (Tire_)  {
           if (EmSt_)  { if (s.search(re561)!=-1)  { count_561+=s.match(re561).length; s=s.replace(re561, re561_) }    }
                else  { if (s.search(re561_0)!=-1)  { count_561+=s.match(re561_0).length; s=s.replace(re561_0, re561_0_) }    }

           if (!NoCom_)  {
                   if (EmSt_)  { if (s.search(re562)!=-1)  { count_562+=s.match(re562).length; s=s.replace(re562, re562_) }    }
                        else  { if (s.search(re562_0)!=-1)  { count_562+=s.match(re562_0).length; s=s.replace(re562_0, re562_0_) }    }    }
               else  {
                       if (EmSt_)  { if (s.search(re562nc)!=-1)  { count_562+=s.match(re562nc).length; s=s.replace(re562nc, re562nc_) }    }
                            else  { if (s.search(re562nc_0)!=-1)  { count_562+=s.match(re562nc_0).length; s=s.replace(re562nc_0, re562nc_0_) }    }    }

           if (EmSt_)  { if (s.search(re570)!=-1)  { count_570++; s=s.replace(re570, re570_) }    }
                 else  { if (s.search(re570_0)!=-1)  { count_570++; s=s.replace(re570_0, re570_0_) }    }
           }

//---------------
  Def_=(s.search(reDef)!=-1);    //  повторный поиск дефисов
//---------------

   if (Def_) {
           if (Tag_) { if (s.search(re580)!=-1)  { count_580+=s.match(re580).length; s=s.replace(re580, re580_) }    }
                   else { if (s.search(re580_0)!=-1)  { count_580+=s.match(re580_0).length; s=s.replace(re580_0, re580_0_) }    }    }
   if (s.search(re581s)!=-1)  {
           if (s.search(re581)!=-1)  { count_581+=s.match(re581).length;  s=s.replace(re581, re581_) }
           while (s.search(re582)!=-1)  { count_581+=s.match(re582).length;  s=s.replace(re582, re582_);  Def_=true }    }

// ------------------------


/// НЕРАЗРЫВНЫЕ ПРОБЕЛЫ С ЗАКРЕПЛЕНИЕМ  :  операции  № 6хх

   if (s.search(re601)!=-1)  { count_601+=s.match(re601).length; s=s.replace(re601, re601_) }
   if (sct.length>=20)  {
           if (Abz1!=0)  {
                   if (P41_) {
                           if (EmSt_) { if (s.search(re610sv)!=-1) { s=s.replace(re610sv, re610_) }    }
                               else { if (s.search(re610sv_0)!=-1) { s=s.replace(re610sv_0, re610_0_) }    }    }
                   if (EmSt_) { if (s.search(re610)!=-1) { count_610++; s=s.replace(re610, re610_) }    }
                       else { if (s.search(re610_0)!=-1) { count_610++; s=s.replace(re610_0, re610_0_) }    }
                  }
           if (Abz2!=0) {
                   if (P41_  &&  s.search(re611s)!=-1) {
                           if (EmSt_) { if (s.search(re611sv)!=-1) { s=s.replace(re611sv, re611_) }    }
                               else { if (s.search(re611sv_0)!=-1) { s=s.replace(re611sv_0, re611_0_) }    }    }
                   if (EmSt_) { if (s.search(re611)!=-1) { count_611+=s.match(re611).length; s=s.replace(re611, re611_) }    }
                       else { if (s.search(re611_0)!=-1) { count_611+=s.match(re611_0).length; s=s.replace(re611_0, re611_0_) }    }
                   }
           if (Abz3!=0) {
                   if (P41_  &&  s.search(re615s)!=-1) {
                           if (EmSt_) { if (s.search(re615sv)!=-1) { s=s.replace(re615sv, re615_) }    }
                               else { if (s.search(re615sv_0)!=-1) { s=s.replace(re615sv_0, re615_0_) }    }    }
                   if (EmSt_) { if (s.search(re615)!=-1) { count_615+=s.match(re615).length; s=s.replace(re615, re615_) }    }
                       else { if (s.search(re615_0)!=-1) { count_615+=s.match(re615_0).length; s=s.replace(re615_0, re615_0_) }    }
                   }
           if (Abz4!=0) {
                   if (P41_  &&  s.search(re616s)!=-1) {
                           if (EmSt_) { if (s.search(re616sv)!=-1) { s=s.replace(re616sv, re616_) }    }
                               else { if (s.search(re616sv_0)!=-1) { s=s.replace(re616sv_0, re616_0_) }    }    }
                   if (EmSt_) { if (s.search(re616)!=-1) { count_616+=s.match(re616).length; s=s.replace(re616, re616_) }    }
                       else { if (s.search(re616_0)!=-1) { count_616+=s.match(re616_0).length; s=s.replace(re616_0, re616_0_) }    }
                   }
           }
   if (s.search(re620s)!=-1)  {
           while (s.search(re620sv)!=-1)  { s=s.replace(re620sv, re620_) }
           if (s.search(re621sv)!=-1)  { s=s.replace(re621sv, re621_) }
           if (s.search(re622sv)!=-1)  { s=s.replace(re622sv, re622_) }    }

   if (s.search(re623s)!=-1)  {
           if (s.search(re623sv)!=-1)  { s=s.replace(re623sv, re623_) }
           if (s.search(re624sv)!=-1)  { s=s.replace(re624sv, re624_) }    }

   if (s.search(re630s)!=-1)  {
           if (s.search(re630sv)!=-1)  { s=s.replace(re630sv, re630sv_) }
           if (s.search(re630)!=-1)  { count_630+=s.match(re630).length; s=s.replace(re630, re630_) }    }
   if (s.search(re631s)!=-1)  {
           if (s.search(re631sv)!=-1)  { s=s.replace(re631sv, re631_) }
           if (s.search(re631)!=-1)  { count_631+=s.match(re631).length; s=s.replace(re631, re631_) }    }

    if (P41_  &&  s.search(re690s)!=-1)  {
           if (EmSt_)  { if (s.search(re690)!=-1)  { count_690+=s.match(re690).length; s=s.replace(re690, re690_) }    }
               else  { if (s.search(re690_0)!=-1)  { count_690+=s.match(re690_0).length; s=s.replace(re690_0, re690_0_) }    }    }
   if (s.search(re691)!=-1)  { count_691+=s.match(re691).length; s=s.replace(re691, re691_) }


/// СОКРАЩЕНИЯ, ПЕРЕЧИСЛЕНИЯ, ОБОЗНАЧЕНИЯ И Т.П.  :  операции  № 7хх

   if (Sokr_)  {
           if (s.search(re730)!=-1)  { count_730+=s.match(re730).length; s=s.replace(re730, re730_) }
           if (s.search(re731)!=-1)  { count_731+=s.match(re731).length; s=s.replace(re731, re731_) }
           if (s.search(re732)!=-1)  { count_732+=s.match(re732).length; s=s.replace(re732, re732_) }
           if (s.search(re735)!=-1)  { count_735+=s.match(re735).length; s=s.replace(re735, re735_) }
           if (s.search(re736)!=-1)  { count_735+=s.match(re736).length; s=s.replace(re736, re736_) }
           if (s.search(re737)!=-1)  { count_735+=s.match(re737).length; s=s.replace(re737, re737_) }
           }
   if (NN_)  {
           if (s.search(re740s)!=-1  &&  s.search(re740)!=-1)  { count_740+=s.match(re740).length; s=s.replace(re740, re740_) }
           if (s.search(re741s)!=-1)  {
                   if (s.search(re741)!=-1) {
                           s_=s;
                           count_741_=s_.match(re741).length; s_=s_.replace(re741, re741_);
                           if (s_.search(re741C)!=-1)  { s_=s_.replace(re741C, re741C_) }
                           if (s_.search(re741K)!=-1)  { s_=s_.replace(re741K, re741K_) }
                           if (s!=s_)  { s=s_; count_741+=count_741_ }    }   //  сохранение абзаца и увеличение счетчика только в случае, если операции №741 изменили абзац
                   if (s.search(re742)!=-1)  { count_742+=s.match(re742).length; s=s.replace(re742, re742_) }    }
           if (s.search(/°/g)!=-1)  {
                   s_=s;
                   if (s_.search(re743a)!=-1)  { count_743_=s_.match(re743a).length; s_=s_.replace(re743a, re743a_) }
                   if (s!=s_)  { s=s_; count_743+=count_743_ }  //  сохранение абзаца и увеличение счетчика только в случае, если операция №743a изменили абзац
                   if (s_.search(re743b)!=-1)  { count_743_=s_.match(re743b).length; s_=s_.replace(re743b, re743b_) }
                   if (s!=s_)  { s=s_; count_743+=count_743_ }    }   //  сохранение абзаца и увеличение счетчика только в случае, если операция №743b изменили абзац
           if (s.search(re744s)!=-1)  {
                   if (s.search(re744)!=-1)  { count_744+=s.match(re744).length; s=s.replace(re744, re744_) }
                   while  (s.search(re745)!=-1)  { s=s.replace(re745, re745_); count_745++ }    }
           if (s.search(re746s)!=-1)  {
                   if (s.search(re746)!=-1)  { count_744+=s.match(re746).length; s=s.replace(re746, re746_) }
                   while  (s.search(re747)!=-1)  { s=s.replace(re747, re747_); count_745++ }    }
           if (s.search(re748)!=-1)  { count_748+=s.match(re748).length; s=s.replace(re748, re748_) }
           if (Sokr_  &&  s.search(re750)!=-1)  { count_750+=s.match(re750).length; s=s.replace(re750, re750_) }
           if (s.search(re751s)!=-1)  {
                   if (EmSt_)  { if (s.search(re751)!=-1)  { count_750+=s.match(re751).length; s=s.replace(re751, re751_) }    }
                       else  { if (s.search(re751_0)!=-1)  { count_750+=s.match(re751_0).length; s=s.replace(re751_0, re751_0_) }    }    }
           if (EmSt_)  { if (s.search(re755)!=-1)  { count_755+=s.match(re755).length; s=s.replace(re755, re755_) }    }
               else  { if (s.search(re755_0)!=-1)  { count_755+=s.match(re755_0).length; s=s.replace(re755_0, re755_0_) }    }
           }
   if (s.search(re760s)!=-1)  {
           if (EmSt_)  { if (s.search(re760)!=-1)  { count_760++; s=s.replace(re760, re760_) }    }
               else  { if (s.search(re760_0)!=-1)  { count_760++; s=s.replace(re760_0, re760_0_) }    }    }
   if (NN_)  {
           if (EmSt_)  { if (s.search(re761)!=-1)  { count_760++; s=s.replace(re761, re761_) }    }
               else  { if (s.search(re761_0)!=-1)  { count_760++; s=s.replace(re761_0, re761_0_) }    }
           if (EmSt_)  { if (s.search(re762)!=-1)  { count_760++; s=s.replace(re762, re762_) }    }
               else  { if (s.search(re762_0)!=-1)  { count_760++; s=s.replace(re762_0, re762_0_) }    }    }
   if (s.search(re763s)!=-1)  {
           if (EmSt_)  { if (s.search(re763)!=-1)  { count_760++; s=s.replace(re763, re763_) }    }
               else  { if (s.search(re763_0)!=-1)  { count_760++; s=s.replace(re763_0, re763_0_) }    }    }
   if (s.search(re765s)!=-1)  {
           s_=s;
           if (EmSt_)  {
                   if (s_.search(re765)!=-1)  s_=s_.replace(re765, re765_);
                   if (s_.search(re766)!=-1)  s_=s_.replace(re766, re766_);    }
               else  {
                       if (s_.search(re765_0)!=-1)  s_=s_.replace(re765_0, re765_0_);
                       if (s_.search(re766_0)!=-1)  s_=s_.replace(re766_0, re766_0_);    }
           if (s_.search(re122)!=-1)  s_=s_.replace(re122, re122_);
           if (s_!=s)  { count_765++; s=s_ }    }
   if (XXI_  &&  s.search(re770)!=-1)  { count_770+=s.match(re770).length; s=s.replace(re770, re770_) }
   if (NN_)  {
           if (s.search(re771)!=-1)  { count_771+=s.match(re771).length; s=s.replace(re771, re771_) }
           if (s.search(re772)!=-1)  { count_772+=s.match(re772).length; s=s.replace(re772, re772_) }    }

   if (ptr.parentNode.className=="title")  {
           if (EmSt_)  { if (s.search(re790)!=-1  &&  s.search(re790ex)==-1)  { count_790++; s=s.replace(re790, re790_) }    }
               else  { if (s.search(re790_0)!=-1  &&  s.search(re790ex_0)==-1)  { count_790++; s=s.replace(re790_0, re790_0_) }    }    }


/// СТАНДАРТИЗАЦИЯ ТЕГОВ курсива и жирности  (окончание)  :  операции  № 8хх

   if (EmSt_)  {
           if (s.search(re801ex)==-1)  { if (s.search(re801)!=-1) { count_801++; s=s.replace(re801, re801_) }    }
           if (s.search(re802)!=-1)  { count_802++; s=s.replace(re802, re802_) }
           if (s.search(re803)!=-1)  { count_803+=s.match(re803).length; s=s.replace(re803, re803_) }    }


   }   // Конец ряда формул, которые были пропущены для тех строк, которые целиком состоят из некоторых символов
   else count_129ex++;  // счетчик таких строк


   }   // Конец цикла (Cycle) повторных обработок для измененных строк
   if (count_Cycle<count_Cycle_) count_Cycle=count_Cycle_;


//  Восстановление длинного тире между названиями
   if (s.search(reNm2) != -1)  s=s.replace(reNm2, reNm2_);

//  Восстановление дефиса рядом с цифрами
   if (s.search(reDN2) != -1)  s=s.replace(reDN2, reDN2_);


/// ПОСТОБРАБОТКА (поиск)  :  операции  № 9хх

   if (firstHandleP)  {    //  если это первая обработка

           if (s.search(re901s)!=-1)  {
                   m901[count_m901]=ptr;
                   m901_N[count_m901]=count_P;
                   count_m901++;    }

           if (Ud_on_off != 0  &&  s.search(re911s) != -1  &&  s.search(re911s2) != -1)  {
                   m911[count_m911]=ptr;
                   m911_N[count_m911]=count_P;
                   count_m911++;    }

           if (s.search(re921s) != -1)  {
                   m921[count_m921]=ptr;
                   m921_N[count_m921]=count_P;
                   count_m921++;    }
           }


/// ВОССТАНОВЛЕНИЕ АДРЕСОВ И ФОРМАТА КОД
//   *  Восстановление идет строго в обратном порядке: сначала "адреса", потом "код"

// восстановление текстовых электронных адресов*
   if (Url3_)
           for (n=0; s.search(UrlFalse3)!=-1; n++)
                   s=s.replace(UrlFalse3, mUrl3[n]);

// восстановление активных электронных адресов*
   if (Url1_)
           for (n=0; s.search("href=\""+UrlFalse1)!=-1; n++)
                   s=s.replace("href=\""+UrlFalse1, mUrl1[n]);

// восстановление кода*
   if (Code_)
           for (n=0; s.search(FalseCode)!=-1; n++)
                   s=s.replace(FalseCode, mCode[n]);

// * поиск/замена поштучная, без использования рег. выражений

//---------------

   if (nbspEntity=="&nbsp;"  &&  s.search(reNBSPon)!=-1)  s=s.replace(reNBSPon, reNBSPon_);  //  возвращение кода н/р пробела

//---------------

   //  сохранение абзаца в оригинале только в том случае, если он действительно изменен
   if (ptr.innerHTML != s) {
           count_GU++;          // счетчик изменений
           m_GU[count_P]=true;   // индикация для строки
           ptr.innerHTML=s }

  }   //  конец создания функции "HandleP(ptr)"

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОБРАБОТКА ТЕКСТА
                 //      (применение функции "HandleP")

 window.external.BeginUndoUnit(document, ScriptName + " v."+NumerusVersion);    // Начало записи в систему отмен.

 ptr=fbwBody;
 var ptrLvl=[];
 j=0;

aaa:
 while (ptr) {
         if (ptr.nodeName!="P"  &&  ptr.firstChild!=null  &&  (ptr.className!="history" || ObrabotkaHistory)) {
                 ptrLvl[j]=ptr;
                 j++;
                 ptr=ptr.firstChild;
                 }
             else {
                     while (ptr.nextSibling==null)  {
                             j--;
                             ptr=ptrLvl[j];
                             if (j==0) break aaa;
                             }
                     ptr=ptr.nextSibling;
                     }
         if (ptr.nodeName=="P")
                 HandleP(ptr);
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ПОСТОБРАБОТКА  :  Полуавтоматические исправления

 var mElem=[];   var elem1="";   var elem2="";   //  для элементов <LABEL>
 var otvet;   var otvet_txt;   var msgTitle="";   var msg="";   var count_msg;   //  для диалога
 var otmena = false;    //  индикатор кнопки "Отмена"
 firstHandleP = false;   //  повторная обработка функцией "HandleP" будет без поиска фрагментов для постобработки

 var Dict1 = [];   //  словарь заменяемых слов
 var Dict2 = [];   //  словарь правильных слов
 var count_Dict1=0;
 var Dict3 = [];   //  словарь пропущенных слов
 var count_Dict3=0;

 var reSpace = new RegExp(nbspEntity,"g");      //  замена н/р пробелов на обычные (для словарей)
 var reSpace_ = " ";

         // Функция добавления стиля для выделения
 function LABELstyle(el) {
         el.style.color="#EEF47C";
         el.style.backgroundColor="#821A1A";
         el.style.fontSize="115%";
         el.style.padding="0.1em";
         }

         // Функция очистки стиля для выделения
 function LABELstyleOf(el) {
         el.style.removeAttribute("color");
         el.style.removeAttribute("backgroundColor");
         el.style.removeAttribute("fontSize");
         }

         // Функция обработки ответа
 function HandleOtvet() {
         if (otvet == 6)  {                                                   // "Да":  исправление ошибки и запоминание слов
                 if (otvet_txt.search(/^ *$/g)==-1  &&  otvet_txt != elem1)  { mElem[n].innerHTML = otvet_txt; Dict2[count_Dict1] = otvet_txt }
                     else  { mElem[n].innerHTML = elem2;  Dict2[count_Dict1] = elem2 }
                 Dict1[count_Dict1] = elem1;
                 count_Dict1++;
                 return 1;    }
         if (otvet == 7)  {                                                   // "Нет":  запоминание пропущенного слова
                 Dict3[count_Dict3] = elem1;
                 count_Dict3++;
                 return 0;    }
         }

         // Исправление ошибочного добавления градуса Цельсия (°C)

 var re901 = new RegExp("(([\\\d]{1,10})(\\\s|"+nbspEntity+")°[CС]([А-яA-Za-zЁё]{1,30}))(?=[^>]{0,}(<|$))","g");  // основная
 var re901_LABEL = "<LABEL>$1</LABEL>";     //  обрамление тегами   фрагмента с ошибкой
 var re901_1 = "$2"+"0 С$4";  //   исправленный вариант с русской "С"
 var re901_2 = "$2"+"0 C$4";  //   исправленный вариант с латинской "C"
 var count_901 = 0;
 var re902 = new RegExp("^[\\\d]{1,10}(\\\s|"+nbspEntity+")°[CС][А-яA-Za-zЁё]{1,30}$","g");  //  доп. проверка
 var re903 = new RegExp("°[CС][А-яЁё]","g");              //  для выбора варианта исправления
 count_msg=0;
 otmena = false;

 for (j=0;  j<count_m901;  j++) {
         if (otmena)  break;         //  выход из цикла при нажатии кнопки "Отмена"
         ptr=m901[j];                    // получение строки с ошибкой
         s=ptr.innerHTML;
         ptr.innerHTML=s.replace(re901, re901_LABEL);  //  обрамление фрагмента с ошибкой тегами <LABEL>
         mElem=ptr.getElementsByTagName("LABEL");           //  получение всех узлов <LABEL> в строке
L901:
         for (n=0; n<mElem.length; n++) {
                 elem1 = mElem[n].innerHTML.replace(reSpace, reSpace_);         //  содержимое узла <LABEL>
                 if (elem1.search(re902)==-1)  continue;     //  пропуск постороннего узла
                 for (k=0; k<count_Dict1; k++) {
                         if (elem1 == Dict1[k])  { count_901++;  mElem[n].innerHTML = Dict2[k]; continue L901 }  //  повторение замены пользователя
                         if (elem1 == Dict2[k])  continue L901;    }          //  пропуск правильных слов
                 for (k=0; k<count_Dict3; k++)
                         if (elem1 == Dict3[k])  continue L901;          //  повторение пропуска для ранее пропущенных слов
                 if (elem1.search(re903)!=-1)  elem2 = elem1.replace(re901, re901_1);    //  сохранение исправленной ошибки в переменной (с русской "С")
                     else  elem2 = elem1.replace(re901, re901_2);               //  сохранение исправленной ошибки в переменной (с латинской "С")
                 if (s.length<50000)                                              // защита от длинных строк
                         GoTo_0(mElem[n]);                                         // переход на узел <LABEL>
                 count_msg++;
                 msgTitle = "№ 901  •  ошибочный °C  ›››  исходный текст  —  "+count_msg;  // Заголовок окна
                 msg = " ◊  Найден текст:	" + elem1 + "\n ◊  Заменить на:	" + elem2;  //  Текст в окне
                 LABELstyle(mElem[n]);   // добавление стиля
                 T_pause -= new Date().getTime();                  // определение продолжительности паузы в вычислениях
                 otvet_txt = window.external.InputBox(msg, msgTitle, elem1);       //  диалоговое окно, запись введенного текста
                 T_pause += new Date().getTime();                  // определение продолжительности паузы в вычислениях
                 LABELstyleOf(mElem[n]);  // удаление стиля
                 otvet = window.external.GetModalResult();            //   возвращение кнопки ответа
                 if (otvet == 2)  { otmena = true;  break }    // "Отмена":  выход из цикла
                 count_901 += HandleOtvet();
                 }
         for (n=mElem.length-1; n>=0; n--)  mElem[n].removeNode(false);      //  удаление формата <LABEL> в строке
         if (s != ptr.innerHTML  &&  ! m_GU[m901_N[j]]) {    //  если строка изменена и до этого не изменялась
                 count_GU++;   //  увеличение счетчика изменений строк
                 m_GU[m901_N[j]]=true;    }   //  отметка строки, как измененная
         }


         // Заглавная посреди слова ››› ударе́ние

 var re911 = new RegExp("(^|[^А-яA-Za-zЁё0-9])([А-Я]{0,1}[а-яё]{1,30})([АЕИОУЫЭЮЯ])([а-яё]{0,30})(?=([^А-яA-Za-zЁё0-9>][^>]{0,}){0,1}(<|$))","g");  // основная
 var re911_LABEL = "$1<LABEL>$2$3$4</LABEL>";     //  обрамление тегами   фрагмента с ошибкой
 var re912 = new RegExp("^([А-Я]{0,1}[а-яё]{1,})([АЕИОУЫЭЮЯ])([а-яё]{0,})$","g");
 var re912_ = "$2";
 var txt912 = "";               //   Буква, для которой будет производиться понижение регистра
 var re913 = new RegExp("[АЕИОУЫЭЮЯ](?=[а-яё]{0,}$)","g");
 var count_911 = 0;
 count_msg=0;
 otmena = false;

 count_Dict1=0;
 count_Dict3=0;

 for (j=0;  j<count_m911;  j++) {
         if (otmena)  break;         //  выход из цикла при нажатии кнопки "Отмена"
         ptr=m911[j];                    // получение строки с ошибкой
         s=ptr.innerHTML;
         s_=s.replace(re911, re911_LABEL);  //  пробное обрамление фрагментов с ошибками тегами <LABEL>
         if (s_.search(/<LABEL>.+?<\/LABEL>/g)==-1)  continue;     //  если ничего не обрамилось, то возвращаемся для получения следующей строки
         mElem = s_.match(/<LABEL>.+?<\/LABEL>/g);          //  имитация получения всех узлов <LABEL>, и их проверка
         for (n=0; n<mElem.length; n++) {
                 elem1 = mElem[n];                                                    //  текст <LABEL>
                 elem1 = elem1.replace(/<\/?LABEL>/g, "");         //  текст внутри <LABEL>
                 if (elem1.search(re912)==-1  ||  elem1.search(/ГенУборк/)!=-1)  continue;     //  пропуск постороннего узла или исключения
                 break;                  //  если есть кандидат на обработку - выход из цикла
                 }
         if (n==mElem.length)  continue;   //  если цикл не прерывался при обнаружении кандидата на обработку, то возвращаемся для получения следующей строки
         ptr.innerHTML=s_;       //  реальное обрамление фрагмента с ошибкой тегами <LABEL> (это действие считается изменением документа и записывается в систему отката)
         mElem=ptr.getElementsByTagName("LABEL");           //  получение всех узлов <LABEL> в строке
L911:
         for ( ; n<mElem.length; n++) {    // * начальная с первого кандидата на обработку
                 elem1 = mElem[n].innerHTML;         //  содержимое узла <LABEL>
                 if (elem1.search(re912)==-1  ||  elem1.search(/ГенУборк/)!=-1)  continue;     //  пропуск постороннего узла или исключения
                 for (k=0; k<count_Dict1; k++) {
                         if (elem1 == Dict1[k])  { count_911++;  mElem[n].innerHTML = Dict2[k]; continue L911 }  //  повторение замены пользователя
                         if (elem1 == Dict2[k])  continue L911;    }          //  пропуск правильных слов
                 for (k=0; k<count_Dict3; k++)
                         if (elem1 == Dict3[k])  continue L911;          //  повторение пропуска для ранее пропущенных слов
                 txt912=elem1.replace(re912, re912_);     //  Извлечение буквы
                 txt912=txt912.toLowerCase()+Ud;           //  Понижение регистра
                 elem2=elem1.replace(re913, txt912)    //  сохранение исправленной ошибки в переменной "elem2"
                 if (s.length<50000)                                              // защита от длинных строк
                         GoTo_0(mElem[n]);                                         // переход на узел <LABEL>
                 count_msg++;
                 msgTitle = "№ 911  •  выделЕние кАпсом  ›››  ударе́ние  —  "+count_msg;  // Заголовок окна
                 msg = " ◊  Найден текст:	" + elem1 + "\n ◊  Заменить на:	" + elem2;  //  Текст в окне
                 LABELstyle(mElem[n]);   // добавление стиля
                 T_pause -= new Date().getTime();                  // определение продолжительности паузы в вычислениях
                 otvet_txt = window.external.InputBox(msg, msgTitle, elem1);       //  диалоговое окно, запись введенного текста
                 T_pause += new Date().getTime();                  // определение продолжительности паузы в вычислениях
                 LABELstyleOf(mElem[n]);  // удаление стиля
                 otvet = window.external.GetModalResult();            //   возвращение кнопки ответа
                 if (otvet == 2)  { otmena = true;  break }    // "Отмена":  выход из цикла
                 count_911 += HandleOtvet();
                 }
         for (n=mElem.length-1; n>=0; n--)  mElem[n].removeNode(false);      //  удаление формата <LABEL> в строке
         if (s != ptr.innerHTML  &&  ! m_GU[m911_N[j]]) {       //  если строка изменена и до этого не изменялась
                 count_GU++;                                                        //  увеличение счетчика изменений строк
                 m_GU[m911_N[j]]=true;    }      //  отметка строки, как измененная
         }


         // Р а з р я д к а   ›››   курсив

 var re921 = new RegExp("(^|\\\s|"+nbspEntity+"|[…\\\(\\\[«„“\\\"–>])(([А-яA-Za-zЁё]–{0,1}|–{0,1}[А-ЯA-ZЁ]\\\.)(\\\s|"+nbspEntity+")((–{0,1}[А-яA-Za-zЁё—]–{0,1}|–{0,1}[А-ЯA-ZЁ]\\\.)(\\\s|"+nbspEntity+"|\\\-)){1,}–{0,1}[А-яA-Za-zЁё])(?=\\\s|"+nbspEntity+"|[<…\\\.,:;\\\?!\\\(\\\)\\\[\\\]»”\\\"–]|$)","g");  // основная
 var re921_LABEL = "$1<LABEL>$2</LABEL>";     //  обрамление тегами   фрагмента с ошибкой
 var re922 = new RegExp("([А-яA-Za-zЁё]–{0,1}|–{0,1}[А-ЯA-ZЁ]\\\.)\\\s((–{0,1}[А-яA-Za-zЁё—]–{0,1}|–{0,1}[А-ЯA-ZЁ]\\\.)(\\\s|\\\-)){1,}–{0,1}[А-яA-Za-zЁё]","g");  // проверка на посторонний узел
 var re922ex1 = new RegExp("^(х{3,}|[ВКУСОвкусо]{0,1}[A-Za-z]и[A-Za-z]|[ВКУСОвкусо]{0,1}[А-ЯA-ZЁ]и[А-ЯA-ZЁ]|[АИаи]{0,1}[ВКУСОвкусо]{0,1}[IVX][ви]|[АИаи]{0,1}[ВКУСОвкусо][IVX][ви]{0,1}|.([А-ЯA-ZЁ]\\\.){1,}.)$","g");  // исключения 1
 var re922ex2 = new RegExp("^(аи[вкусо]|аия|аияв|аияс|аяб|аябв|аяби|аябив|аябк|аябс|аяв|аяж|аяжв|аяжи|аяжс|аяи|аяи[вкусо]|ая[вкусо]|би[явку]|бя[вусои]|бяив|жи[кусоя]|жя[вкусобиж]|ияб|иябв|иябк|иябс|ияв|ияж|ияжо|ия[вкусо]|яб[вкусои]|ябив|яж[вкусои]|яи[вкусо]|ая—[вкусоия]|ия—[вкусоаия]|ия—ив|я—ая|я—и[вкусоя]|я—я[вкусои])$","gi");  // исключения 2 (для любого регистра)
  var re923 = new RegExp("\\\s","g");      //  удаление всех пробелов в фрагменте
 var re923_ = "";
  var re924 = new RegExp("([А-яA-Za-zЁё–])\\\s(?=[а-яa-zё–])|([А-ЯA-ZЁ–])\\\s(?=[А-ЯA-ZЁ–])|(\\\.)\\\s(?=–)","g");      //  удаление разрядки
 var re924_ = "$1$2$3";

  var re925 = new RegExp("(^.+$)","g");      //  добавление форматирования
 var re925_em_ = "<EM>$1</EM>";
 var re925_st_ = "<STRONG>$1</STRONG>";
 var re925_emst_ = "<STRONG><EM>$1</EM></STRONG>";

  var re926_em = new RegExp("(<EM>)([а-яё—]\\\s)|(\\\s[а-яё—])(</EM>)","g");
  var re926_st = new RegExp("(<STRONG>)([а-яё—]\\\s)|(\\\s[а-яё—])(</STRONG>)","g");
  var re926_emst = new RegExp("(<STRONG><EM>)([а-яё—]\\\s)|(\\\s[а-яё—])(</EM></STRONG>)","g");
 var re926__ = "$2$1$4$3";      //  коррекция форматирования - часть 1

  var re927_em = new RegExp("<EM>(.)</EM>","g");
  var re927_st = new RegExp("<STRONG>(.)</STRONG>","g");
  var re927_emst = new RegExp("<STRONG><EM>(.)</EM></STRONG>","g");
 var re927__ = "$1";      //  коррекция форматирования - часть 2

 var count_921 = 0;
 count_msg=0;
 otmena = false;
 var Otvet_921 = false;    //  разрешение на проведение операции
 var Ask_921 = false;   //  вопрос о разрешении пока не задан


 count_Dict1=0;
 count_Dict3=0;

 for (j=0;  j<count_m921;  j++) {
         if (otmena)  break;         //  выход из цикла при нажатии кнопки "Отмена"
         ptr=m921[j];                    // получение строки с ошибкой
         s=ptr.innerHTML;
         s_=s.replace(re921, re921_LABEL);  //  пробное обрамление фрагментов с ошибками тегами <LABEL>
         if (s_.search(/<LABEL>.+?<\/LABEL>/g)==-1)  continue;     //  если ничего не обрамилось, то возвращаемся для получения следующей строки
         mElem = s_.match(/<LABEL>.+?<\/LABEL>/g);          //  имитация получения всех узлов <LABEL>, и их проверка
         for (n=0; n<mElem.length; n++) {
                 elem1 = mElem[n].replace(reSpace, reSpace_);      //  текст <LABEL> с заменой н/р пробелов
                 elem1 = elem1.replace(/<\/?LABEL>/g, "");         //  текст внутри <LABEL>
                 if (elem1.search(re922)==-1)  continue;     //  пропуск постороннего узла
                 elem2=elem1.replace(re923, re923_);    //  сохранение фрагмента без пробелов в переменной "elem2"
                 if (elem2.search(re922ex1)!=-1  ||  elem2.search(re922ex2)!=-1)  continue;     //  пропуск исключений
                 if (elem1.search(re924)==-1)  continue;     //  пропуск случая, когда нельзя удалить пробелы формулой удаления разрядки
                 break;                  //  если есть кандидат на обработку - выход из цикла
                 }
         if (n==mElem.length)  continue;   //  если цикл не прерывался при обнаружении кандидата на обработку, то возвращаемся для получения следующей строки
         ptr.innerHTML=s_;       //  реальное обрамление фрагмента с ошибкой тегами <LABEL> (это действие считается изменением документа и записывается в систему отката)
         mElem=ptr.getElementsByTagName("LABEL");           //  получение всех узлов <LABEL> в строке
L921:
         for (  ; n<mElem.length; n++) {    //  * начальная с первого кандидата на обработку
                 elem1 = mElem[n].innerHTML.replace(reSpace, reSpace_);         //  содержимое узла <LABEL>
                 if (elem1.search(re922)==-1)  continue;     //  пропуск постороннего узла
                 elem2=elem1.replace(re923, re923_);    //  сохранение фрагмента без пробелов в переменной "elem2" (только для проверки)
                 if (elem2.search(re922ex1)!=-1  ||  elem2.search(re922ex2)!=-1)  continue;     //  пропуск исключений
                 if (elem1.search(re924)==-1)  continue;     //  пропуск случая, когда нельзя удалить пробелы формулой удаления разрядки
                 elem2=elem1.replace(re924, re924_);    //  сохранение фрагмента с удаленной разрядкой в "elem2" (для замены)
                 for (k=0; k<count_Dict1; k++) {
                         if (elem1 == Dict1[k])  { count_921++;  mElem[n].innerHTML = Dict2[k]; continue L921 }  //  повторение замены пользователя
                         if (elem1 == Dict2[k])  continue L921;    }          //  пропуск правильных слов
                 for (k=0; k<count_Dict3; k++)
                         if (elem1 == Dict3[k])  continue L921;          //  повторение пропуска для ранее пропущенных слов
                 if (s.length<50000)                                              // защита от длинных строк
                         GoTo_0(mElem[n]);                                         // переход на узел <LABEL>
                 LABELstyle(mElem[n]);   // добавление стиля

                 if (!Ask_921) {    //  если это первый вопрос

                         if (formatRazrjadki==1  &&  (EmAll  ||  count_158em!=0  ||  count_158emst!=0  ||  (count_155!=0  ||  count_157!=0) && (_format_==1  ||  _format_==3)  ||  count_156!=0 && (_f_o_r_m_a_t_==1  ||  _f_o_r_m_a_t_==3))) {    //  если в тексте есть курсив...
                                 count_Em = fbwBody.getElementsByTagName("EM").length;   //   подсчет курсива
                                 T_pause -= new Date().getTime();                  // определение продолжительности паузы в вычислениях
                                 Otvet_921 = AskYesNo ("•  ОПЕРАЦИЯ  № 921\n"+
                                     "------------------------------------------\n"+
                                     "						        \n"+
                                     "Преобразование  \"Р а з р я д к а ››› курсив\"\n"+
                                     " добавит в текст форматирование  курсивным шрифтом.\n"+
                                     "Но это форматирование не будет уникальным.\n"+
                                     "В тексте книги уже есть "+count_Em+fragmenta[pad(count_Em)]+" в этом формате.\n\n"+
                                 "------------------------------------------------------------\n"+
                                     "◊  Разрешить преобразование\n"+
                                     "    \"Р а з р я д к а ››› курсив\"?");
                                 T_pause += new Date().getTime();                  // определение продолжительности паузы в вычислениях
                                 Ask_921 = true;     //  вопрос задан (индикация)
                                 if (!Otvet_921)                  //   Если отказ...
                                         { otmena = true;  break }    // "Отмена"  и  выход из цикла
                                 }

                         if (formatRazrjadki==2  &&  (StAll  ||  count_158st!=0  ||  count_158emst!=0  ||  (count_155!=0  ||  count_157!=0) && (_format_==2  ||  _format_==3)  ||  count_156!=0 && (_f_o_r_m_a_t_==2  ||  _f_o_r_m_a_t_==3))) {    //  если в тексте есть жирность...
                                 count_St = fbwBody.getElementsByTagName("STRONG").length;   //   подсчет жирности
                                 T_pause -= new Date().getTime();                  // определение продолжительности паузы в вычислениях
                                 Otvet_921 = AskYesNo ("•  ОПЕРАЦИЯ  № 921\n"+
                                     "------------------------------------------\n"+
                                     "						        \n"+
                                     "Преобразование  \"Р а з р я д к а ››› жирность\"\n"+
                                     " добавит в текст форматирование  полужирным шрифтом.\n"+
                                     "Но это форматирование не будет уникальным.\n"+
                                     "В тексте книги уже есть "+count_St+fragmenta[pad(count_St)]+" в этом формате.\n\n"+
                                     "------------------------------------------------------------\n"+
                                     "◊  Разрешить преобразование\n"+
                                     "    \"Р а з р я д к а ››› жирность\"?");
                                 T_pause += new Date().getTime();                  // определение продолжительности паузы в вычислениях
                                 Ask_921 = true;     //  вопрос задан (индикация)
                                 if (!Otvet_921)                  //   Если отказ...
                                         { otmena = true;  break }    // "Отмена"  и  выход из цикла
                                 }

                         if (formatRazrjadki==3  &&  (EmStAll  ||  count_158emst!=0  ||  (count_155!=0  ||  count_157!=0) && _format_==3  ||  count_156!=0 && _f_o_r_m_a_t_==3)) {    //  если в тексте есть жирный курсив...
                                 //   подсчет жирного курсива
                                 count_EmSt=0;
                                 mP = fbwBody.getElementsByTagName("EM");     //  Получение всех фрагментов с курсивом
                                 for (j=0;  j<mP.length;  j++)                                           //  Последовательный просмотр этих фрагментов
                                         count_EmSt += mP[j].getElementsByTagName("STRONG").length;
                                 mP = fbwBody.getElementsByTagName("STRONG");  //  Получение всех фрагментов с жирностью
                                 for (j=0;  j<mP.length;  j++)                                                   //  Последовательный просмотр этих фрагментов
                                         count_EmSt += mP[j].getElementsByTagName("EM").length;

                                 T_pause -= new Date().getTime();                  // определение продолжительности паузы в вычислениях
                                 Otvet_921 = AskYesNo ("•  ОПЕРАЦИЯ  № 921\n"+
                                     "------------------------------------------\n"+
                                     "						        \n"+
                                     "Преобразование  \"Р а з р я д к а ››› жирный курсив\"\n"+
                                     " добавит в текст форматирование  полужирным курсивом.\n"+
                                     "Но это форматирование не будет уникальным.\n"+
                                     "В тексте книги уже есть "+count_EmSt+fragmenta[pad(count_EmSt)]+" в этом формате.\n\n"+
                                     "------------------------------------------------------------\n"+
                                     "◊  Разрешить преобразование\n"+
                                     "    \"Р а з р я д к а ››› жирный курсив\"?");
                                 T_pause += new Date().getTime();                  // определение продолжительности паузы в вычислениях
                                 Ask_921 = true;     //  вопрос задан (индикация)
                                 if (!Otvet_921)                  //   Если отказ...
                                         { otmena = true;  break }    // "Отмена"  и  выход из цикла
                                 }
                         }

                 count_msg++;
                 switch (formatRazrjadki) {                  // Заголовок окна
                         case 1:  msgTitle = "№ 921  •  р а з р я д к а   ›››   курсив  —  "+count_msg;  break;
                         case 2:  msgTitle = "№ 921  •  р а з р я д к а   ›››   жирность  —  "+count_msg;  break;
                         case 3:  msgTitle = "№ 921  •  р а з р я д к а   ›››   жирный курсив  —  "+count_msg;  break;
                         default:  msgTitle = "№ 921  •  удаление  р а з р я д к и  —  "+count_msg;
                         }
                 msg = " ◊  Найден текст:	" + elem1 + "\n ◊  Заменить на:	" + elem2;  //  Текст в окне
                 T_pause -= new Date().getTime();                  // определение продолжительности паузы в вычислениях
                 otvet_txt = window.external.InputBox(msg, msgTitle, elem2);       //  диалоговое окно, запись введенного текста
                 T_pause += new Date().getTime();                  // определение продолжительности паузы в вычислениях
                 LABELstyleOf(mElem[n]);  // удаление стиля
                 otvet = window.external.GetModalResult();            //   возвращение кнопки ответа
                 if (otvet == 2)  { otmena = true;  break }    // "Отмена":  выход из цикла
                 if (otvet == 6)  {                                                   // "Да":  исправление ошибки и запоминание слов
                         if (otvet_txt.search(/^ *$/g)==-1  &&  otvet_txt != elem2)  elem2 = otvet_txt;
                         if (formatRazrjadki == 1) {
                                 elem2 = elem2.replace(re925, re925_em_);                             //  добавление курсива
                                 while (elem2.search(re926_em)!=-1)  elem2 = elem2.replace(re926_em, re926__);    //  коррекция курсива
                                 if (elem2.search(re927_em)!=-1)  elem2 = elem2.replace(re927_em, re927__);    //  коррекция курсива
                                 }
                         if (formatRazrjadki == 2) {
                                 elem2 = elem2.replace(re925, re925_st_);                                //  добавление полужирности
                                 while (elem2.search(re926_st)!=-1)  elem2 = elem2.replace(re926_st, re926__);    //  коррекция полужирности
                                 if (elem2.search(re927_st)!=-1)  elem2 = elem2.replace(re927_st, re927__);    //  коррекция полужирности
                                 }
                         if (formatRazrjadki == 3) {
                                 elem2 = elem2.replace(re925, re925_emst_);                                //  добавление полужирного курсива
                                 while (elem2.search(re926_emst)!=-1)  elem2 = elem2.replace(re926_emst, re926__);    //  коррекция полужирного курсива
                                 if (elem2.search(re927_emst)!=-1)  elem2 = elem2.replace(re927_emst, re927__);    //  коррекция полужирного курсива
                                 }
                         mElem[n].innerHTML = elem2;   // исправление
                         Dict2[count_Dict1] = elem2;        // запоминание
                         Dict1[count_Dict1] = elem1;        // запоминание
                         count_Dict1++;
                         count_921 ++;
                         }
                 if (otvet == 7)  {                                                   // "Нет":  запоминание пропущенного слова
                         Dict3[count_Dict3] = elem1;
                         count_Dict3++;
                         }
                 }
         for (n=mElem.length-1; n>=0; n--)
                 mElem[n].removeNode(false);      //  удаление формата <LABEL> в строке
         if (s != ptr.innerHTML  &&  ! m_GU[m921_N[j]]) {       //  если строка изменена и до этого не изменялась
                 count_GU++;                                                        //  увеличение счетчика изменений строк
                 m_GU[m921_N[j]]=true;      //  отметка строки, как измененная
                 }
         if (s != ptr.innerHTML) {       //  если строка изменена
                 HandleP(ptr);                //  повторная обработка основной функцией
                 if (m_GU[count_P]) {            //  если строка изменена этой обработкой...
                         count_GU--;                    //  поправка счетчика изменений
                         m_GU[count_P]=false;   //  поправка индикатора изменений
                         }
                 count_P--;                    //  поправка счетчика строк
                 }
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 ///  ПОВЫШЕНИЕ ВЕРСИИ ФАЙЛА И ЗАПИСЬ В ИСТОРИЮ ИЗМЕНЕНИЙ
                 //  (применение функции "HistoryChange")

 var versionFile=document.getElementById("diVersion").value; //  Извлечение значения версии файла.
 var newVersion = versionFile;                                                          //  Значение новой версии.

 var HiCh=0;                     //  Код изменения истории.
 var VersionUp=false;   //  Индикатор повышения версии.

//  Если включено автоматическое повышение версии, а также если есть измененные строки или разрешено повышение версии когда нет изменений...
 if (Version_on_off == 1  &&  (count_GU  ||  Vsegda_on_off == 1))
         HistoryChange(ScriptName + " " + NumerusVersion, youName);   //  запускаем функцию для изменения данных истории

// ---------------------------------------------------------------

 window.external.EndUndoUnit(document);    // Конец записи в систему отмен.

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОКНО РЕЗУЛЬТАТОВ  :  Текущее время и дата

 var currentFullDate = new Date();

 var currentHours = currentFullDate.getHours();
 var currentMinutes = currentFullDate.getMinutes();
 var currentSeconds = currentFullDate.getSeconds();

 if (currentMinutes<10) currentMinutes = "0" + currentMinutes;
 if (currentSeconds<10) currentSeconds = "0" + currentSeconds;

 var currentDay = currentFullDate.getDate();
 var currentMonth = 1+currentFullDate.getMonth();
 var currentYear_ = currentFullDate.getFullYear();

 if (currentMonth<10) currentMonth = "0" + currentMonth;
var currentYear = (currentYear_+"").replace(/^.*?(\d{1,2})$/g, "$1");

 var currentTime_ = currentHours + ":" + currentMinutes;
 var currentTime = currentTime_ + ":" + currentSeconds;
 var currentDate_ = currentDay + "." + currentMonth;
 //currentDate_="7.10"   //  для тестирования праздников
 var currentDate = currentDate_ + "." + currentYear;

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОКНО РЕЗУЛЬТАТОВ  :  Праздники

 var Prazdniki=false;         //  Индикатор праздников.
 var PrazdnikiText="";            //  Текст по случаю праздника.

 if (currentDate_=="1.01") {        //  Если сегодня 1 января...
         Prazdniki=true;                               //  включаем индикатор праздников
         PrazdnikiText=" ◊  С  НОВЫМ  ГОДОМ !!!";   //  и заполняем соответствующий текст.
         }
 if (currentDate_=="9.05") {        //  Если сегодня 9 мая...
         Prazdniki=true;                                     //  включаем индикатор праздников
         PrazdnikiText=" ◊  С  ДНЁМ  ПОБЕДЫ !!!";   //  и заполняем соответствующий текст.
         }
 if (currentDate_=="30.12" || currentDate_=="31.12") {   //  Если сегодня 30-31 января...
         Prazdniki=true;                                                                                //  включаем индикатор праздников
         PrazdnikiText=" ◊  С  НАСТУПАЮЩИМ  НОВЫМ  ГОДОМ !!!";   //  и заполняем соответствующий текст.
         }
 if (currentDate_=="12.04") {   //  Если сегодня 12 апреля...
         Prazdniki=true;                                                                                //  включаем индикатор праздников
         PrazdnikiText=" ◊  С  ДНЁМ КОСМОНАВТИКИ !!!";   //  и заполняем соответствующий текст.
         }

 var DR_=false;         //  Индикатор Дня рождения.
 var DR_Text="";           //  Текст по случаю Дня рождения.

 if (currentDate_==DR) {   //  Если сегодня Дня рождения...
         Prazdniki=true;                        //  включаем индикатор праздников,
         DR_Text=" ◊  С  ДНЁМ  РОЖДЕНИЯ !!!";   //  и заполняем соответствующий текст.
         }


 var Srok;     //  Промежуток времени до праздника.
 var ostalsja = ["остался", "осталось", "осталось"];
 var dnej = ["день", "дня", "дней"];


 if (!Prazdniki  &&  Rn_(20) == 0)  {   //  Если сегодня нет праздников и сработала вероятность в 5%...
         if (new Date(currentYear_, 4, 9).getTime() > Ts)                 //  проверяем, не прошел ли в этом году День Победы
                 Srok = new Date(currentYear_, 4, 9).getTime() - Ts;           //  и если не прошел, то считаем миллисекунды до этого праздника в этом году,
             else  Srok = new Date(currentYear_+1, 4, 9).getTime() - Ts;         //  а если прошел, то до даты следующего года.
         Srok = Math.ceil(Srok/86400000);                                                                        //  Затем переводим миллисекунды в дни,
         var ostalsja_eshhjo = [ostalsja[pad(Srok)], ostalsja[pad(Srok)]+" ещё", "ещё"];
         Prazdniki=true;                                                                                                                                  //  включаем индикатор праздников
         PrazdnikiText=" ◊  До Дня Победы " + ostalsja_eshhjo[Rn_(3)] + " " + Srok + " " + dnej[pad(Srok)];   //  и создаем соответствующий текст.
         }

 if (!Prazdniki  &&  Rn_(20) == 0)  {   //  Если сегодня нет праздников и сработала вероятность в 5%...
         Srok = new Date(currentYear_+1, 0, 1).getTime() - Ts;    //  то считаем миллисекунды до начала следующего года,
         Srok = Math.ceil(Srok/86400000);                                                              //  переводим миллисекунды в дни,
         var ostalsja_eshhjo = [ostalsja[pad(Srok)], ostalsja[pad(Srok)]+" ещё", "ещё"];
         Prazdniki=true;                                                                                                                                  //  включаем индикатор праздников
         PrazdnikiText=" ◊  До Нового Года " + ostalsja_eshhjo[Rn_(3)] + " " + Srok + " " + dnej[pad(Srok)];   //  и создаем соответствующий текст.
         }

 var mPoka = ["Всего доброго", "Всего наилучшего", "Всего хорошего", "Всех благ", "До встречи", "До новых встреч", "До связи", "До скорого свидания", "До скорой встречи", "Счастливо оставаться", "Счастливо", "Удачи", "Успехов"];

 if (!Prazdniki  &&  Rn_(20) == 0) {                            //  Если сегодня нет праздников и сработала вероятность в 5%...
         Prazdniki=true;                                                                  //  включаем индикатор праздников
         PrazdnikiText = " ◊  " + mPoka[Rn_(mPoka.length)];   //  и создаем текст пожелания.
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// СОЗДАНИЕ СПИСКА ЦИТАТ

//  Из книги "Пословицы и поговорки Великой Отечественной войны"
//  (составитель Павел Федорович Лебедев)

 var Kn=[ "Одна у человека мать, одна у него и Родина.",   "Родина любимая – мать родимая.",   "Родина – мать, умей за нее постоять.",   "Где ни жить – Родине служить.",   "С Родиной разлука – одна мука.",   "Всякому мила своя сторона.",   "Своя земля и в горсти мила.",   "На чужой стороне и весна не красна.",   "Где кто родится, там и пригодится.",   "На чужбине родная землица во сне снится.",   "На своей стороне мило, на чужой – постыло.",   "На чужой стороне и сокола зовут вороною.",   "Всякая сосна своему лесу весть подает.",   "Родная страна – колыбель, чужая – дырявое корыто.",   "На солнце тепло, на родине добро.",   "Человек без Родины что соловей без песни.",   "Глупа та птица, которой свое гнездо не мило.",   "Кукушка кукует – по бездомью горюет.",   "Расставшийся с другом плачет семь лет, расставшийся с Родиной – всю жизнь.",   "Нет ничего на свете краше, чем Родина наша.",   "Нашей страны шире не найти в мире.",   "Русское раздолье – человеку приволье.",   "Богата русская земля – говорится не зря.",   "Я тобой горжусь, милая Русь.",   "Человек без Родины что солдат без оружия.",   "Счастье Родины дороже жизни.",   "Береги страну как зеницу ока.",   "Может, и голову сложу, а Родине послужу.",   "Нам Отчизна дорога, охраняем родные берега.",   "Пусть знает ворог: нам край свой дорог.",   "Кто любовь к Отчизне имеет, тот врага одолеет.",   "Мы бережем свою Родину-мать, за нее мы готовы жизнь отдать.",   "С нами родная земля, нам светят звезды Кремля.",   "Великие победы нас ждут впереди под лучами красной звезды.",   "Красная звезда светит всегда.",   "Теперь все дороги ведут в Москву.",   "Москва от глаз далека, да сердцу близка.",   "Москва – наша столица, Москвой народ гордится.",   "Москва – всем столицам голова.",   "Москва – столица, любо подивиться.",   "У русской столицы не видать границы.",   "По Москве ходить – глаз с нее не сводить.",   "Москва – Родины украшенье, врагам устрашение.",   "Кремль тем и красен, что с народом согласен.",   "Наша страна дружбой сильна.",   "У нас все народы живут в ладу – врагам на беду.",   "Солнце не померкнет над нами, братство – наша сила и знамя.",   "Народное братство дороже всякого богатства.",   "Если дружба велика, будет Родина крепка.",   "Дружбу нашу не разделят просторы, моря и горы.",   "Страна растет – врагов метет.",   "Не тот человек, кто для себя живет, а тот человек, кто народу силы отдает.",   "За Родину и народ иду вперед.",   "Человек без народа что дерево без плода.",   "Чтобы с врагами биться, надо всем сплотиться.",   "Не трудно врагов победить, если всем заодно быть.",   "Наш народ сплочен и един, он непобедим.",   "Кто на нас нападает, тот в могилу попадает.",   "Россия с давних пор давала врагу отпор.",   "Никогда Россия ярма не носила.",   "За наше Отечество все человечество.",   "Не летать фашистским стаям над нашим краем.",   "Мы не боимся свинцовой тучи: наши полки могучи.",   "Кто на Советский Союз покушается, тот после раскается.",   "Бей фашистов не в бровь, а в глаз – таков народа наказ.",   "Любовь к народу, ненависть к врагу – душа победы.",   "От Родины награда – сердцу отрада.",   "Отчизна родная – для нас святая.",   "Знает свет: тверже русских нет.",   "Наш народ – герой, ходит на врага стеной.",   "Сыновья русских матерей славятся удалью богатырей.",   "Наша страна героями славится.",   "Кто за Родину горой – тот истинный герой.",   "Без патриотизма не разбить фашизма.",   "Защищай Советскую державу, бей фашистскую ораву.",   "Фашистам смерть неси – не опозорь Руси.",   "Даю Родине слово: мстить фашистам сурово.",   "Во имя Отчизны своей где фашиста увидел – бей.",   "За народное дело бейся смело.",   "Для Родины своей ни сил, ни жизни не жалей.",   "Жизнь отдам, а Родину не продам.",   "С родной земли – умри не сходи.",   "За Родину-мать не страшно умирать.",   "За Родину жизни не пощадим, но врагу ничего не отдадим.",   "Кому нашей земли захочется, тот под ней скорчится.",   "Родину любить – фашистов бить.",   "Бей фашистский сброд – за Родину, за народ.",   "Родину любить – верно Родине служить.",   "Родину беречь – врагов сечь.",   "Для нас война не страх – развеем врага в прах.",   "Гитлер пришел к нам незваным, а уйдет от нас драным.",   "Не придется Гитлеру из Ленинграда сделать море, а из Москвы – поле.",   "Думал Гитлер нашими землями управлять, а придется ему подыхать.",   "Штык советский молодец – скоро Гитлеру конец.",   "У Гитлера не столько расчетов, сколько просчетов.",   "Гитлер предполагает, а Красная Армия располагает.",   "Посмотрим, как Гитлер завоет, когда наши огонь по Берлину откроют.",   "Раздавим Гитлера в блин, как придем в Берлин.",   "Гитлеру-палачу местью отплачу.",   "Пора с Гитлером кончать – хватит ему рычать.",   "Гитлер и его правительство ответят за грабительство.",   "Гитлер кричит, мы весь свет разрушим, а мы Гитлера наперед задушим.",   "Сколько Гитлер ни крути, а от петли не уйти.",   "Гитлер победами хвалится, да в могилу свалится.",   "Хотел Гитлер Россию съесть, да пришлось в лужу сесть.",   "Не довелось свинье на небо дивиться, а Гитлеру в нашем огороде рыться.",   "Медведя знают по когтям, а Геббельса по лживым речам.",   "Фашистские собаки сочиняют враки.",   "Фашист брехней живет.",   "Солдаты у Гитлера вшивы, сводки у Геббельса лживы.",   "От осины не жди ягоды, от фашиста – правды.",   "Геббельс вертит языком без меры, да нет ему веры.",   "Геббельс мелет, да никто ему не верит.",   "Германия вот-вот развалится, а Геббельс все хвалится.",   "Германия пылает, а Геббельс все лает.",   "Врет, как фашистский бюллетень.",   "Как Геббельс ни врет, а наша берет.",   "Против фашистской лжи ухо востро держи.",   "Фашистские оковы всей Европе знакомы.",   "Лучше волку в зубы, чем фашистам в руки.",   "Фашист гладок, да вид его гадок.",   "Фашист от когтей до носа похож на барбоса.",   "Фашист и сатана – сущность одна.",   "Не ищи в фашисте человека – не найдешь.",   "Легче шакала превратить в голубя, чем фашиста в человека.",   "Фашистов легче убить, чем вразумить.",   "Фашистская власть – грабить и красть.",   "У фашистов особый спорт: кто больше добра сопрет.",   "Видно птицу по полету, а фашиста – по грабежам.",   "Сколько фашисту ни воровать, а виселицы не миновать.",   "Для предателя сгори хоть целый свет, лишь бы он был согрет.",   "Змея один раз в год меняет кожу, а предатель – каждый день.",   "Предатель фашисту пятки лизал, а фашист и спасибо не сказал.",   "У предателя ни Родины, ни друзей.",   "Лучше глаза лишиться, чем доброго имени.",   "Героям – слава, предателям – смерть.",   "Слава греет, позор жжет.",   "Бесчестье хуже смерти.",   "Кто с врагами пьет и гуляет, того и земля не принимает.",   "Думал фриц нашим богатством нажиться, да пришлось в могилу ложиться.",   "Не видать свинье неба, а фашистам нашего хлеба.",   "Кого к столу приглашают, а в фашиста пулю сажают.",   "Кому чарка, кому две, а фашисту – камнем по голове.",   "Угостили фашистов не водкой, а прямой наводкой.",   "Врага не уговаривай: с ним штыком разговаривай.",   "Убил фашистского гада – душа рада.",   "Съели бы фашисты русского мужика, да кишка тонка.",   "Одного фашиста убить – сто детей спасти.",   "Фашиста убить что змею: сто грехов простится.",   "Лучше смерть на поле, чем позор в неволе.",   "Чем позор и неволю терпеть, лучше в бою умереть.",   "Лучше биться орлом, чем жить зайцем.",   "Никогда фашистам не властвовать над нами, никогда не будем рабами.",   "Лучше злая пуля, чем клеймо раба.",   "Славная смерть лучше постыдной жизни.",   "Воевать – не галушки жевать.",   "Не воевать – победы не видать.",   "Слабого огонь войны испепеляет, а сильного как сталь закаляет.",   "Кто за правое дело дерется, у того двойная сила берется.",   "Наше дело правое – бей врага браво.",   "Бей фашистских властей всех мастей.",   "С какой злостью превеликой мы расправимся с фашистской кликой.",   "С врагами биться – на пули не скупиться.",   "Винтовка хлоп – и фашист в гроб.",   "Пришел фашист из Берлина – получил земли три аршина.",   "Не важно, чем бил, – важно, что фашиста убил.",   "Каждой фашистской гадине висеть на перекладине.",   "Всякому свой путь: журавлю – в небо, волку – в лес, а фашисту – в могилу.",   "Упрямого выправит дубина, а фашиста – могила.",   "Какую яму фашист копал – в такую и попал.",   "Фашисты научились воровать, а мы научились фашистов убивать.",   "Наш порог не для фашистских сапог.",   "Фашиста согнем в бараний рог, чтоб не переступал наш порог.",   "Лося бьют в осень, а фашиста всегда.",   "Наше дело святое и правое, мы расправимся с фашистскою оравою.",   "С фашистом разговор короткий: круши его прямой наводкой.",   "Кричал фашист «гоп», да получил пулю в лоб.",   "Фашиста умертвить – доброе дело сотворить.",   "На фронте воевать – славу добывать.",   "Фронт гремит – у врага земля горит.",   "Гремят вспышки на горизонте: то бьют фашистов на фронте.",   "Фашистов разгромили – и в селе порядок водворили.",   "Фашист замахнулся, да промахнулся.",   "Дрался фашист пылко, да остался без затылка.",   "Фашисты козыряли, да головы потеряли.",   "Фашисты пять раз на дню попадают в западню.",   "У фашистов брожение: попали в окружение.",   "Фашистам не все напирать – пришлось и умирать.",   "Трави фашистскую силу – огнем и штыком загоняй в могилу.",   "Чокнемся, фашист, я парень не гордый: я – прикладом, а ты – мордой.",   "На то у винтовок и ложи, чтобы бить фашиста по роже.",   "Слава русского штыка не померкнет века.",   "Штык остёр загнал фрицев в «котел».",   "Наши штыки разгромят фашистские полки.",   "Фашисты войну начали, а мы кончим.",   "Славу свою добывай в бою.",   "Почет и славу собирают по капле.",   "Народ того уважает, кто фашистов уничтожает.",   "На то мы и внуки Суворова, чтобы сражаться здорово.",   "Как учил Александр Суворов – будь к врагу суровым.",   "На краю света фашистов найдем и на суд приведем.",   "Зря фашист блиндажи строит: все равно снаряд накроет.",   "Смерть фашистской своре – на берегу и в море!",   "Солдата мать родит, отец растит, а бой учит.",   "Дерево в огне сгорает, а солдат от огня крепче бывает.",   "Кто первый бой начинает, тот скорее побеждает.",   "Пришла пора гнать фашистов со двора.",   "Фашист наступает – кричит «гут», а отступает – «Гитлер капут».",   "Красна девушка косами, солдат – орденами.",   "Ученый водит, а неуч сзади ходит.",   "Птицу обманывают кормом, а человека – словом.",   "Слово, сказанное без соображения, подобно выстрелу без прицела.",   "Говорить впустую что стрелять вхолостую.",   "У осла длинные уши, а у болтуна длинный язык.",   "У короткого ума длинный язык.",   "Слово не воробей: выпустишь – не поймаешь.",   "Скажешь – не воротишь, напишешь – не сотрешь, отрубишь – не приставишь.",   "Лучше один раз увидеть, чем сто раз услышать.",   "Острый язык – дарование, длинный язык – наказание.",   "Не всегда говори то, что знаешь, но всегда знай, что говоришь.",   "Кто много болтает, тот врагу помогает.",   "Кто зевает – победителем не бывает.",   "Храбрость города берет, а бдительность их бережет.",   "Зря не болтай у телефона: болтун – находка для шпиона.",   "Нет друга – так ищи, а найдешь – береги.",   "Ищи себе друзей таких, чтобы не было стыда от них.",   "Не ходи, дружок, в неизвестный кружок: к таким людям зайдешь, что навек пропадешь.",   "Плохой друг подобен тени: только в светлые дни его и видишь.",   "Не та дружба сильна, что в словах заключена, а та, что в бою скреплена.",   "Для друзей – пироги, для врагов – кулаки.",   "В недруге пуля что во пне, а в друге что во мне.",   "Все за одного, один за всех – вот и обеспечен в бою успех.",   "Не имей сто рублей, а имей сто друзей.",   "В дружбе – правда.",   "Кто нашел друга – нашел сокровище.",   "Сам пропадай, а товарища выручай.",   "Один в поле не воин, а вдвоем с товарищем – взвод.",   "Где дружба и лад – там и клад.",   "Где дружба и совет – там и свет.",   "Трусливый друг опаснее врага, ибо врага опасаешься, а на друга опираешься.",   "Не тот друг, кто медом мажет, а тот, кто правду скажет.",   "Недруг поддакивает, а друг спорит.",   "Дружба крепка не лестью, а правдой и честью.",   "Новых друзей наживай, а старых не забывай.",   "Прямо страху в глаза смотри – и страх смигнет.",   "Волков бояться – в лес не ходить.",   "Трус умирает тысячу раз, а смелый всего один раз.",   "Советские воины из металла скроены.",   "Чем больше героев, тем скорее фашистов зароем.",   "Храбрость – сестра победы.",   "На смелого собака лает, а трусливого – рвет.",   "Не числом, а храбростью побеждают.",   "Лучше быть мертвым героем, чем живым трусом.",   "Смелого и пуля облетит, смелый и мину перехитрит.",   "Если не будешь овцой, то волк не съест.",   "Косил Гитлер глаз на Донбасс, а Донбасс опять у нас.",   "И про солдатскую честь пословица есть.",   "Потому и смешно, что фашистам горе пришло.",   "Гитлеровским сателлитам быть разбитым.",   "Знаем, за что бьем, потому и с победой придем.",   "Кто за правое дело стоит, тот всегда победит.",   "У правого сила удвоится, говорит пословица.",   "Будет праздник и на улице нашей, всякого праздника краше.",   "Войну закончим – и мир упрочим.",   "Как фашисты нам ни грозили, а мы их сразили.",   "Фашистов разгромили – добро сотворили.",   "Хотел Гитлер покорить весь мир, да лопнул как мыльный пузырь.",   "Задохнулась фашистская стая девятого мая.",   "Разбили фашистскую орду в сорок пятом году.",   "Прогнали фрицев – можно веселиться.",   "Советская Армия врага разгромила, она стоит на страже мира.",   "Курские леса и дубравы полны легендарной славы.",   "Виден в курских лесах боевой размах.",   "Защитим курские дубравы от фашистской оравы!",   "В курских городах разбили фашистов в прах.",   "Как фашисты ни рвались к Курску – не дали им спуску.",   "Бей врага, Суджа, зарывай глубже." ];

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОКНО РЕЗУЛЬТАТОВ  :  Демонстрационный режим

 var VseStroki_on_off = 0;      // 0 ; 1 //      ("0" — отключить, "1" — включить)

 var d=0;
 if (VseStroki_on_off == 1)  d="показать нули";

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОКНО РЕЗУЛЬТАТОВ  :  Сборка массива с результатами обработки (для win XP)

 var Tf=new Date().getTime();
 var mSt=[];
 var ind=0;

                                         mSt[ind]=" "+ScriptName+" v."+NumerusVersion;  ind++;
                                         mSt[ind]="--------------------------------------------------------------";  ind++;
 if (d)                           { mSt[ind]=" Демонстрационный режим";  ind++ }
                                         mSt[ind]="";  ind++;

                                         mSt[ind]="• СТАТИСТИКА:";  ind++;
                                         mSt[ind]="   Время выполнения  .  .  .  .  .  .  .  .	"+time(Tf - Ts - T_pause);  ind++;
 if (T_pause!=d)       { mSt[ind]="   Диалоговые паузы  .  .  .  .  .  .  .  .	"+time(T_pause);  ind++; }
                                         mSt[ind]="   Циклов обработки  .  .  .  .  .  .  .  .	"+count_Cycle;  ind++;
                                         mSt[ind]="   Проверено строк  .  .  .  .  .  .  .  .  .	"+count_P;  ind++;
 if (count_GU!=d)    { mSt[ind]="   Исправлено строк   .  .  .  .  .  .  .  .	"+count_GU;  ind++; }
 if (count_GU==0 || d)  { mSt[ind]="";  ind++;
                                         mSt[ind]="   >> Исправлений нет";  ind++; }

var cTaT=ind;  //  число строк в первом разделе


                                         mSt[ind]="";  ind++;
                                         mSt[ind]="• ВНЕ ОБРАБОТКИ:";  ind++;
 if (count_Code!=d) { mSt[ind]="   Формат «код»   .  .  .  .  .  .  .  .  .  .	"+count_Code;  ind++ }
 if (count_Url1!=d)  { mSt[ind]="   Сноски и ссылки  .  .  .  .  .  .  .  .  .	"+count_Url1;  ind++ }
 if (count_Url3!=d) { mSt[ind]="   Эл. адреса в тексте   .  .  .  .  .  .  .	"+count_Url3;  ind++ }
 if (count_129ex!=d) { mSt[ind]="   Строки из символов   .  .  .  .  .  .  .	"+count_129ex;  ind++ }
 if (countNm!=d)    { mSt[ind]="   Тире между названиями  .  .  .  .  .	"+countNm;  ind++ }

 if (cTaT==ind-2) ind=ind-2;  //  Удаление двух последних строк, если нет пунктов "вне обработки"
 cTaT=ind;


                                         mSt[ind]="";  ind++;
                                         mSt[ind]="• СПЕЦ. РЕЖИМ:";  ind++;
 if (saveDef  ||  d)    { mSt[ind]="   Дефис + цифра  –  сохранение дефиса";  ind++ }
 if (!R_Def  ||  d)       { mSt[ind]="   Дефис + буква   ›››   Тире";  ind++ }
  if (!R_KTi  ||  d)      { mSt[ind]="   Короткое тире + буква   ›››   Тире";  ind++ }
  if (!R_Tire  ||  d)     { mSt[ind]="   Тире + буква   ›››   Короткое тире или Дефис";  ind++ }

 if (cTaT==ind-2) ind=ind-2;  //  Удаление двух последних строк, если нет пунктов "спец, режим"
 cTaT=ind;  //  число строк в общей статистике /или/ минимальная высота колонки


                                      mSt[ind]="";  ind++;
                                      mSt[ind]="• ОПЕРАЦИИ:";  ind++;

 var cTaT2=ind;
 var count_eLine=0;

 if (count_011!=d)  { mSt[ind]="011. ошибочное примечание   .  .  .  .  .  .  .  .	"+count_011;  ind++ }
 if (count_012!=d)  { mSt[ind]="012. объединение ссылок  .  .  .  .  .  .  .  .  .  .	"+count_012;  ind++ }
 if (count_021!=d)  { mSt[ind]="021. лишний пробел перед % в адресе  .  .  .	"+count_021;  ind++ }

 if (cTaT2!=ind)      { mSt[ind]="";  ind++;  cTaT2=ind;  count_eLine++ }   //  Добавление пустой строки, если есть пункты с исправлениями

 if (count_101!=d)  { mSt[ind]="101. лишние спец. символы   .  .  .  .  .  .  .  .  .	"+count_101;  ind++ }
 if (count_102!=d)  { mSt[ind]="102. спец. символы  ›››  обычный пробел  .  .	"+count_102;  ind++ }
 if (count_103!=d)  { mSt[ind]="103. спец. символы  ›››  н/р пробел .  .  .  .  .  .	"+count_103;  ind++ }
 if (count_104!=d)  { mSt[ind]="104. спец. символы  ›››  дефис  .  .  .  .  .  .  .  .	"+count_104;  ind++ }
 if (count_105!=d)  { mSt[ind]="105. спец. символы  ›››  тире .  .  .  .  .  .  .  .  .	"+count_105;  ind++ }
 if (count_106!=d)  { mSt[ind]="106. спец. символ  ›››  запятая  .  .  .  .  .  .  .  .	"+count_106;  ind++ }
 if (count_107!=d)  { mSt[ind]="107. стандартизация апострофов  .  .  .  .  .  .	"+count_107;  ind++ }
 if (count_108!=d)  { mSt[ind]="108. двойной апостроф  ›››  кавычки   .  .  .  .	"+count_108;  ind++ }
 if (count_109!=d)  { mSt[ind]="109. спец. символы  ›››  знак градуса   .  .  .  .	"+count_109;  ind++ }
 if (count_110!=d)  { mSt[ind]="110. символы дробей  ›››  запись с тегами .  .	"+count_110;  ind++ }
 if (count_111!=d)  { mSt[ind]="111. стандартизация надстрочных цифр  .  .	"+count_111;  ind++ }
 if (count_112!=d)  { mSt[ind]="112. стандартизация подстрочных цифр  .  .	"+count_112;  ind++ }
 if (count_114!=d)  { mSt[ind]="114. стандартизация символа «/»  .  .  .  .  .  .	"+count_114;  ind++ }
 if (count_116!=d)  { mSt[ind]="116. пропущенный \"&\"  .  .  .  .  .  .  .  .  .  .  .  .	"+count_116;  ind++ }
 if (count_117!=d)  { mSt[ind]="117. &nbsp;  ›››  н/р пробел   .  .  .  .  .  .  .  .  .	"+count_117;  ind++ }
 if (count_118!=d)  { mSt[ind]="118. чистка пустых ссылок   .  .  .  .  .  .  .  .  .	"+count_118;  ind++ }
 if (count_119!=d)  { mSt[ind]="119. снятие выделения с пробелов   .  .  .  .  .	"+count_119;  ind++ }
 if (count_120!=d)  { mSt[ind]="120. ряд пробелов  ›››  обычный пробел  .  .	"+count_120;  ind++ }
 if (count_121!=d)  { mSt[ind]="121. удаление начального пробела  .  .  .  .  .	"+count_121;  ind++ }
 if (count_122!=d)  { mSt[ind]="122. удаление конечного пробела .  .  .  .  .  .	"+count_122;  ind++ }
 if (count_130!=d)  { mSt[ind]="130. три точки  ›››  многоточие   .  .  .  .  .  .  .	"+count_130;  ind++ }
 if (count_131!=d)  { mSt[ind]="131. многоточие + лишние точки/запятые	"+count_131;  ind++ }
 if (count_132!=d)  { mSt[ind]="132. ? и !  + точки/запятые  ›››  ?.. и !..   .  .  .	"+count_132;  ind++ }
 if (count_133!=d)  { mSt[ind]="133. ?!  + точки/запятая  ›››  ?!.  .  .  .  .  .  .  .	"+count_133;  ind++ }
 if (count_140!=d)  { mSt[ind]="140. две точки  ›››  многоточие   .  .  .  .  .  .  .	"+count_140;  ind++ }
 if (count_150!=d)  { mSt[ind]="150. пунктуация + лишние знаки   .  .  .  .  .  .	"+count_150;  ind++ }
 if (count_152!=d)  { mSt[ind]="152. ряд дефисов/тире  ›››  тире .  .  .  .  .  .  .	"+count_152;  ind++ }
 if (count_155!=d) {
     if (_format_==1  ||  d)  { mSt[ind]="155. _текст в курсив_  .  .  .  .  .  .  .  .  .  .  .  .	"+count_155;  ind++ }
     if (_format_==2  ||  d)  { mSt[ind]="155. _текст в жирность_ .  .  .  .  .  .  .  .  .  .  .	"+count_155;  ind++ }
     if (_format_==3  ||  d)  { mSt[ind]="155. _текст в жирный курсив_ .  .  .  .  .  .  .  .	"+count_155;  ind++ }    }
 if (count_156!=d) {
     if (_f_o_r_m_a_t_==1  ||  d)  { mSt[ind]="156. т_е_к_с_т  ›››  курсив .  .  .  .  .  .  .  .  .  .	"+count_156;  ind++ }
     if (_f_o_r_m_a_t_==2  ||  d)  { mSt[ind]="156. т_е_к_с_т  ›››  жирность   .  .  .  .  .  .  .  .	"+count_156;  ind++ }
     if (_f_o_r_m_a_t_==3  ||  d)  { mSt[ind]="156. т_е_к_с_т  ›››  жирный курсив   .  .  .  .  .	"+count_156;  ind++ }    }
 if (count_157!=d) {
     if (_format_==1  ||  d)  { mSt[ind]="157. _текст_в_курсив_   .  .  .  .  .  .  .  .  .  .  .	"+count_157;  ind++ }
     if (_format_==2  ||  d)  { mSt[ind]="157. _текст_в_жирность_  .  .  .  .  .  .  .  .  .  .	"+count_157;  ind++ }
     if (_format_==3  ||  d)  { mSt[ind]="157. _текст_в_жирный_курсив_  .  .  .  .  .  .  .	"+count_157;  ind++ }    }
 if (count_158em!=d)    { mSt[ind]="158. _буква_  ›››  курсив .  .  .  .  .  .  .  .  .  .  .	"+count_158em;  ind++ }
 if (count_158st!=d)       { mSt[ind]="158. _буква_  ›››  жирность   .  .  .  .  .  .  .  .  .	"+count_158st;  ind++ }
 if (count_158emst!=d) { mSt[ind]="158. _буква_  ›››  жирный курсив   .  .  .  .  .  .	"+count_158emst;  ind++ }
 if (count_172!=d)  { mSt[ind]="172. лишние знаки в начале строки  .  .  .  .  .	"+count_172;  ind++ }
 if (count_180!=d)  { mSt[ind]="180. пробел + лишняя точка .  .  .  .  .  .  .  .  .	"+count_180;  ind++ }
 if (count_182!=d)  { mSt[ind]="182. пробел + лишняя запятая .  .  .  .  .  .  .  .	"+count_182;  ind++ }

 if (cTaT2!=ind)      { mSt[ind]="";  ind++;  cTaT2=ind;  count_eLine++ }   //  Добавление пустой строки, если есть пункты с исправлениями

 if (count_201!=d)  { mSt[ind]="201. объединение курсива/жирности .  .  .  .	"+count_201;  ind++ }
 if (count_202!=d)  { mSt[ind]="202. объединение тегов индекса  .  .  .  .  .  .	"+count_202;  ind++ }
 if (count_203!=d)  { mSt[ind]="203. удаление ссылок без текста  .  .  .  .  .  .	"+count_203;  ind++ }
 if (count_204!=d)  { mSt[ind]="204. удаление пустых тегов .  .  .  .  .  .  .  .  .	"+count_204;  ind++ }
 if (count_205!=d)  { mSt[ind]="205. удаление выделения для знаков  .  .  .  .	"+count_205;  ind++ }
 if (count_215!=d)  { mSt[ind]="215. сложное объединение тегов  .  .  .  .  .  .	"+count_215;  ind++ }
 if (count_220!=d)  { mSt[ind]="220. выделЕние буквы  ›››  ударе́ние   .  .  .  .	"+count_220;  ind++ }
 if (count_241!=d)  { mSt[ind]="241. снятие выделения с пробел+знак   .  .  .	"+count_241;  ind++ }
 if (count_250!=d)  { mSt[ind]="250. снятие выделения с одной скобки  .  .  .	"+count_250;  ind++ }
 if (count_251!=d)  { mSt[ind]="251. выделение пары скобок   .  .  .  .  .  .  .  .	"+count_251;  ind++ }
 if (count_255!=d)  { mSt[ind]="255. выделение пары угловых кавычек  .  .  .	"+count_255;  ind++ }
 if (count_260!=d)  { mSt[ind]="260. выделение запятой .  .  .  .  .  .  .  .  .  .  .	"+count_260;  ind++ }
 if (count_270!=d)  { mSt[ind]="270. снятие выделения со сноски  .  .  .  .  .  .	"+count_270;  ind++ }

 if (cTaT2!=ind)      { mSt[ind]="";  ind++;  cTaT2=ind;  count_eLine++ }   //  Добавление пустой строки, если есть пункты с исправлениями

 if (count_301!=d)  { mSt[ind]="301. дефис рядом с буквой  ›››  тире .  .  .  .  .	"+count_301;  ind++ }
 if (count_310!=d)  { mSt[ind]="310. тире рядом с буквой  ›››  дефис .  .  .  .  .	"+count_310;  ind++ }
 if (count_312!=d)  { mSt[ind]="312. тире между букв  ›››  дефис   .  .  .  .  .  .	"+count_312;  ind++ }
 if (count_320!=d)  { mSt[ind]="320. короткое тире  ›››  дефис .  .  .  .  .  .  .  .	"+count_320;  ind++ }
 if (count_321!=d)  { mSt[ind]="321. короткое тире  ›››  тире .  .  .  .  .  .  .  .  .	"+count_321;  ind++ }

 if (cTaT2!=ind)      { mSt[ind]="";  ind++;  cTaT2=ind;  count_eLine++ }   //  Добавление пустой строки, если есть пункты с исправлениями

 if (count_401!=d)  { mSt[ind]="401. первые кавычки + лишний пробел  .  .	"+count_401;  ind++ }
 if (count_402!=d)  { mSt[ind]="402. первое многоточие + лишний пробел	"+count_402;  ind++ }
 if (count_410!=d)  { mSt[ind]="410. лишний пробел + последние кавычки	"+count_410;  ind++ }
 if (count_411!=d)  { mSt[ind]="411. лишний пробел + многоточие в конце	"+count_411;  ind++ }
 if (count_420!=d)  { mSt[ind]="420. лишний пробел перед знаками .  .  .  .  .	"+count_420;  ind++ }
 if (count_424!=d)  { mSt[ind]="424. лишний пробел перед сноской .  .  .  .  .	"+count_424;  ind++ }
 if (count_425!=d)  { mSt[ind]="425. лишний пробел перед многоточием  	"+count_425;  ind++ }
 if (count_431!=d)  { mSt[ind]="431. кавычки+знак + пропущенный пробел	"+count_431;  ind++ }
 if (count_432!=d)  { mSt[ind]="432. лишний пробел + кавычки+знак .  .  .  .	"+count_432;  ind++ }
 if (count_440!=d)  { mSt[ind]="440. открывающие знаки + лишний пробел	"+count_440;  ind++ }
 if (count_441!=d)  { mSt[ind]="441. сноска + лишний пробел + знак  .  .  .  .	"+count_441;  ind++ }
 if (count_450!=d)  { mSt[ind]="450. знаки + пропущенный пробел  .  .  .  .  .	"+count_450;  ind++ }
 if (count_460!=d)  { mSt[ind]="460. вставка пробела перед кавычкой   .  .  .	"+count_460;  ind++ }
 if (count_470!=d)  { mSt[ind]="470. перемещение сноски за кавычки .  .  .  .	"+count_470;  ind++ }
 if (count_471!=d)  { mSt[ind]="471. сноска + пропущенный пробел   .  .  .  .	"+count_471;  ind++ }
 if (count_472!=d)  { mSt[ind]="472. сноска+знак + пропущенный пробел 	"+count_472;  ind++ }

 if (cTaT2!=ind)      { mSt[ind]="";  ind++;  cTaT2=ind;  count_eLine++ }   //  Добавление пустой строки, если есть пункты с исправлениями

 if (count_501!=d)  { mSt[ind]="501. короткое тире меж римских чисел   .  .	"+count_501+"*";  ind++ }
 if (count_503!=d)  { mSt[ind]="503. короткое тире между числительными	"+count_503+"*";  ind++ }
 if (count_504!=d)  { mSt[ind]="504. короткое тире между месяцами  .  .  .  .	"+count_504+"*";  ind++ }
 if (count_506!=d)  { mSt[ind]="506. число-месяц через н/р пробел  .  .  .  .  .	"+count_506;  ind++ }
 if (count_507!=d)  { mSt[ind]="507. короткое тире в сложных датах   .  .  .  . 	"+count_507+"*";  ind++ }
 if (count_510!=d)  { mSt[ind]="510. короткое тире рядом с числом .  .  .  .  .	"+count_510;  ind++ }
 if (count_511!=d)  { mSt[ind]="511. число-буква через дефис .  .  .  .  .  .  .  .	"+count_511;  ind++ }
 if (count_512!=d)  { mSt[ind]="512. лишний пробел в промежутке чисел	"+count_512;  ind++ }
 if (count_514!=d)  { mSt[ind]="514. короткое тире между числами  .  .  .  .  .	"+count_514+"*";  ind++ }
 if (count_520!=d)  { mSt[ind]="520. дефис в конце строки  ›››  тире .  .  .  .  .	"+count_520;  ind++ }
 if (count_521!=d)  { mSt[ind]="521. дефис меж пробелов  ›››  тире   .  .  .  .  .	"+count_521;  ind++ }
 if (count_530!=d)  { mSt[ind]="530. дефис после знаков  ›››  тире .  .  .  .  .  .	"+count_530;  ind++ }
 if (count_534!=d)  { mSt[ind]="534. дефис + многоточие  ›››  тире .  .  .  .  .  .	"+count_534;  ind++ }
 if (count_550!=d)  { mSt[ind]="550. обычный пробел после тире  .  .  .  .  .  .	"+count_550;  ind++ }
 if (count_551!=d)  { mSt[ind]="551. тире + н/р пробел в начале строки   .  .	"+count_551;  ind++ }
 if (count_561!=d)  { mSt[ind]="561. обычный пробел перед тире  .  .  .  .  .  .	"+count_561;  ind++ }
 if (count_562!=d)  { mSt[ind]="562. н/р пробел перед тире   .  .  .  .  .  .  .  .  .	"+count_562;  ind++ }
 if (count_570!=d)  { mSt[ind]="570. н/р пробел перед конечным тире  .  .  .	"+count_570;  ind++ }
 if (count_580!=d)  { mSt[ind]="580. неучтенный дефис  ›››  короткое тире 	"+count_580+"*";  ind++ }
 if (count_581!=d)  { mSt[ind]="581. код ISBN, ББК, УДК, ГОСТ через дефис	"+count_581+"*";  ind++ }

 if (cTaT2!=ind)      { mSt[ind]="";  ind++;  cTaT2=ind;  count_eLine++ }   //  Добавление пустой строки, если есть пункты с исправлениями

 if (count_601!=d)  { mSt[ind]="601. сокращ. + Имя через н/р пробел .  .  .  .	"+count_601;  ind++ }
 if (count_610!=d)  { mSt[ind]="610. висящее слово в конце строки  .  .  .  .  .	"+count_610;  ind++ }
 if (count_611!=d)  { mSt[ind]="611. висящее слово в конце предложения	"+count_611;  ind++ }
 if (count_615!=d)  { mSt[ind]="615. прикрепление предлога .  .  .  .  .  .  .  .  .	"+count_615;  ind++ }
 if (count_616!=d)  { mSt[ind]="616. висящее слово в начале предложения	"+count_616;  ind++ }
 if (count_630!=d)  { mSt[ind]="630. н/р пробел в аббревиатуре  .  .  .  .  .  .  .	"+count_630;  ind++ }
 if (count_631!=d)  { mSt[ind]="631. н/р пробел после аббревиатуры  .  .  .  .	"+count_631;  ind++ }
 if (count_690!=d)  { mSt[ind]="690. н/р пробел  ›››  обычный   .  .  .  .  .  .  .  .	"+count_690;  ind++ }

 if (cTaT2!=ind)      { mSt[ind]="";  ind++;  cTaT2=ind;  count_eLine++ }   //  Добавление пустой строки, если есть пункты с исправлениями

 if (count_730!=d)  { mSt[ind]="730. т.е., т.д., и т.п.  через н/р пробел   .  .  .	"+count_730;  ind++ }
 if (count_731!=d)  { mSt[ind]="731. н.э., с.г., и.о.  через н/р пробел   .  .  .  .	"+count_731;  ind++ }
 if (count_732!=d)  { mSt[ind]="732. с.ш., в.д., ю.ш., з.д.  через н/р пробел	"+count_732;  ind++ }
 if (count_735!=d)  { mSt[ind]="735. г.р., л.с., у.е.  через н/р пробел   .  .  .  .	"+count_735;  ind++ }
 if (count_740!=d)  { mSt[ind]="740. восстановление знака \"№\"  .  .  .  .  .  .  .	"+count_740;  ind++ }
 if (count_741!=d)  { mSt[ind]="741. градус Цельсия, Кельвина и др.   .  .  .  .	"+count_741;  ind++ }
 if (count_742!=d)  { mSt[ind]="742. восстановление знака градуса  .  .  .  .  .	"+count_742;  ind++ }
 if (count_743!=d)  { mSt[ind]="743. градусы-минуты-секунды .  .  .  .  .  .  .  .	"+count_743;  ind++ }
 if (count_744!=d)  { mSt[ind]="744. н/р пробел после №, §, стр. и т.п.   .  .  .	"+count_744;  ind++ }
 if (count_745!=d)  { mSt[ind]="745. пробелы в перечне номеров  .  .  .  .  .  .	"+count_745;  ind++ }
 if (count_748!=d)  { mSt[ind]="748. лишний пробел перед \"%\" .  .  .  .  .  .  .  .	"+count_748;  ind++ }
 if (count_750!=d)  { mSt[ind]="750. кв. и куб. ед. изм.  через н/р пробел  .  .	"+count_750;  ind++ }
 if (count_755!=d)  { mSt[ind]="755. число + ед. изм.  через н/р пробел .  .  .	"+count_755;  ind++ }
 if (count_760!=d)  { mSt[ind]="760. н/р пробел в маркированных списках	"+count_760;  ind++ }
 if (count_765!=d)  { mSt[ind]="765. P. S., P.P.S., P.S.S.  через н/р пробел  .  .	"+count_765;  ind++ }
 if (count_770!=d)  { mSt[ind]="770. XX век, V съезд и т.п.  через н/р пробел	"+count_770;  ind++ }
 if (count_771!=d)  { mSt[ind]="771. 1 час, 5 дней и т.п.  через н/р пробел  	"+count_771;  ind++ }
 if (count_772!=d)  { mSt[ind]="772. 1 литр, 5 тонн и т.п.  через н/р пробел	"+count_772;  ind++ }
 if (count_790!=d)  { mSt[ind]="790. лишние точки в заголовках .  .  .  .  .  .  .	"+count_790;  ind++ }

 if (cTaT2!=ind)      { mSt[ind]="";  ind++;  cTaT2=ind;  count_eLine++ }   //  Добавление пустой строки, если есть пункты с исправлениями

 if (count_801!=d)  { mSt[ind]="801. выделение всей строки .  .  .  .  .  .  .  .  .	"+count_801;  ind++ }
 if (count_802!=d)  { mSt[ind]="802. выделение начала строки   .  .  .  .  .  .  .	"+count_802;  ind++ }
 if (count_803!=d)  { mSt[ind]="803. выделение предложения  .  .  .  .  .  .  .  .	"+count_803;  ind++ }

 if (cTaT2!=ind)      { mSt[ind]="";  ind++;  cTaT2=ind;  count_eLine++ }   //  Добавление пустой строки, если есть пункты с исправлениями

 if (count_901!=d)  { mSt[ind]="901. ошибочный °C  ›››  исходный текст  .  .  .	"+count_901;  ind++ }
 if (count_911!=d)  { mSt[ind]="911. выделЕние кАпсом  ›››  ударе́ние  .  .  .  .	"+count_911;  ind++ }
 if (count_921!=d) {
     if (formatRazrjadki==0  ||  d)  { mSt[ind]="921. удаление  р а з р я д к и   .  .  .  .  .  .  .  .	"+count_921;  ind++ }
     if (formatRazrjadki==1  ||  d)  { mSt[ind]="921. р а з р я д к а  ›››  курсив  .  .  .  .  .  .  .  .	"+count_921;  ind++ }
     if (formatRazrjadki==2  ||  d)  { mSt[ind]="921. р а з р я д к а  ›››  жирность .  .  .  .  .  .  .	"+count_921;  ind++ }
     if (formatRazrjadki==3  ||  d)  { mSt[ind]="921. р а з р я д к а  ›››  жирный курсив .  .  .  .	"+count_921;  ind++ }    }

 if (cTaT2!=ind)      { mSt[ind]="";  ind++;  cTaT2=ind;  count_eLine++ }   //  Добавление пустой строки, если есть пункты с исправлениями


 //  Удаление пустых строк в разделе "Исправления"
 if (count_eLine !=0  &&  (ind-cTaT-2-count_eLine)/count_eLine  <=1.5)   //  если в подразделе в среднем оказалось по 1,5 операции (или меньше)
         for (n=cTaT+2; n<ind; n++)                                                //  ищем пустые строки
                 if (mSt[n] =="")  { mSt.splice(n, 1);  ind-- }               // и удаляем их


 if (mSt[ind-1]=="")   ind--;   //  Удаление последней пустой строки, если она есть

 if (cTaT==ind-2) ind=ind-2;  //  Удаление двух последних строк, если нет пунктов в разделе "Исправления"


 // подсчет количества помеченных операций (не исправлений), и создание текста соответствующего этому числу
 var count_stars = !!count_501 + !!count_503 + !!count_504 + !!count_507 + !!count_514 + !!count_581 + !!count_580;
 //  * Двойное "НЕ" преобразует "0" в "false", остальные числа - в "true". При сложении, "false" преобразуется в "0", "true" - в "1".
 if (d)  count_stars = 7;                //  Для демонстрационного режима отмечаются все семь операций.
 var odna_dve = ["", "", "две ", "три ", "четыре ", "пять ", "шесть ", "семь ", "восемь ", "девять ", "десять "];
 var otmechennye_operatsii = ["отмеченная операция", "отмеченные операции", "отмеченных операций"];
 var vozvrashhajut = ["возвращает", "возвращают", "возвращают"];
 if (count_stars)  {                           //  Если число отметок не равно нулю...
         mSt[ind]="";  ind++;                 //  добавляется пустая строка
         mSt[ind]="* "+odna_dve[count_stars]+otmechennye_operatsii[pad(count_stars)]+" часто "+vozvrashhajut[pad(count_stars)];  ind++;   //  и текст.
         mSt[ind]="      текст в исходное состояние";  ind++;
         }

//  История
 if (VersionUp ||  HiCh  ||  d)  { mSt[ind]="";  ind++ }
 if (VersionUp  ||  d)                 { mSt[ind]="• Версия файла:  "+versionFile+"  ›››  "+newVersion;  ind++ }
 if (HiCh==1  ||  d)                    { mSt[ind]="• Добавлена новая строка в историю";  ind++ }
 if (HiCh==2  ||  d)                    { mSt[ind]="• Добавлены две строки в историю";  ind++ }
 if (HiCh==3  ||  d)                    { mSt[ind]="• Изменены данные в строке истории";  ind++ }


//  Сборка строк текущей даты и времени
 mSt[ind]="";  ind++;
 mSt[ind]= "• "+currentDate+" • "+currentTime+" •";  ind++;


 mSt[ind]="";  ind++;
 mSt[ind]="--------------------------------------------------------------";  ind++;

//  Сборка строк цитаты
 if (!Prazdniki)  {
         var reZit = new RegExp("([^ ].{0,47})(?=\\\s\\\s.{0,}|$)","g");   // Рег. выражение для разделения цитаты на строки.
         mSt= mSt.concat(Kn[Rn_(Kn.length)].replace(/ /g, "  ").match(reZit));   //  Добавление массива строк цитаты в основной массив.
         for (j=mSt.length-1; j>=ind; j--)  mSt[j]=" "+mSt[j];   //  Добавление отступа.
         //for (j=mSt.length-1; j>=ind; j--)  { mSt.splice(j+1, 0, ""+mSt[j].length) }   //  Добавление длины строк цитаты (отключено)
         ind = mSt.length;    //  Определение индекса.
         }

//  Праздники
 if (PrazdnikiText) { mSt[ind]=PrazdnikiText;  ind++ }
 if (DR_Text)            { mSt[ind]=DR_Text;  ind++ }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОКНО РЕЗУЛЬТАТОВ  :  Подсчет количества и высоты колонок в таблице с результатами обработки

 if (Vysota_teksta<30)  Vysota_teksta=30;  // установка минимальной высоты
 var Kolo=Vysota_teksta-3;   //  высота колонки (в конце сборки страниц могут добавиться 3 строки)
 var page;   // страницы
 var firstPage = 0;   //  Учет возможного добавления пустой строки в конце первой страницы


 if (Vysota_teksta >= ind) {   // Если все строки могут поместиться на одной странице
         page=1;
         Kolo=ind;
         }
     else {         // иначе...
         page=Math.ceil(ind/Kolo);  //  подсчет количества страниц
         Kolo=Math.ceil(ind/page);  //  подсчет высоты колонки при равномерном распределении строк по страницам
         if  (Kolo<=cTaT-1) {      //  если высота колонки оказалась меньше высоты статистики...
                 Kolo=cTaT-1;  //  увеличение высоты колонки до высоты "статистики" (с учетом возможного добавления одной строки)
                 page=Math.ceil(ind/Kolo);  //  пересчет количества страниц
                 }
             else  if  (Kolo<cTaT+6) {                  //  если высота колонки оказалась немного выше "статистики"
                     Kolo=Math.ceil((ind-cTaT)/(page-1));   //  пересчет высоты колонки с учетом будущего добавления пустых строк после статистики
                     for (n=0; n<Kolo-cTaT; n++) {
                             mSt.splice(cTaT, 0, "");   // добавление пустых строк в массив результатов (после статистики)
                             ind++;
                             }
                     }
                 else  firstPage = 1;  //  в остальных случаях колонка и страницы не меняются, но есть вероятность добавления пустой строки в конце первой страницы

         Kolo=Math.ceil((ind-2+firstPage)/page+1);  //  пересчет высоты колонки с учетом возможного добавления пустых строк в конце страниц (не считая первую и последнюю [page-2]) + вероятность добавления пустой строки в конце первой страницы (firstPage)
// * Поскольку предыдущая операция может и не добавить строку в колонку, необходимо сделать контрольный пересчет:
         if  (Kolo<=cTaT) {     //  если высота колонки оказалась меньше высоты статистики...
                 Kolo=cTaT;  //  увеличение высоты колонки до высоты "статистики"
                 }
         }

 while  ( ind <= Kolo*page+5)  { mSt[ind]="";  ind++ }  //  Добавление пустых строк до полного заполнения ими общей высоты во всех страницах
//  * +5 строк - на всякий случай (лишний запас не помешает)

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОКНО РЕЗУЛЬТАТОВ  :  Распределение строк по страницам

 var mPage=[];   // массив страниц
 var _k=0;  // смещение строк

 for (n=0; n < page; n++) {
         mPage[n]="";
         if (mSt[n*Kolo+_k] == "")  _k++;  //  пропуск пустой строки в начале страницы
         for (k=0 ;  k<Kolo;  k++) {
                 if (k==Kolo-1  &&        //  если "последняя" строка на странице...
                     (mSt[k+n*Kolo+_k].search(/^• [А-ЯЁ][А-ЯЁ]/) != -1  ||           //  это заголовок
                     mSt[k+n*Kolo+_k+2] == ""  &&      //  или это 2-я строка перед пустой строкой,
                         mSt[k+n*Kolo+_k+1] != ""  &&      //  при условии, что следующая строка не пустая...
                         mSt[k+n*Kolo+_k-2] != ""))                //  и что вторая строка выше не пустая...
                             { mPage[n]+="\n";  _k--;   break }      //  то в конце страницы добавляется пустая строка, а "последняя" строка переносятся на следующую страницу.
                 mPage[n]+=mSt[k+n*Kolo+_k]+"	\n";        // Стандартное заполнение страницы
                 }
         if (page!=1) {
                 mPage[n]+="\n";
                 if (n!=page-1)  mPage[n]+="◊  Стр. "+(n+1)+"  ◊  Показать  следующую  страницу?";
                         else  mPage[n]+="◊  Стр. "+(n+1)+" (последняя)  ◊  Закрыть окно?";
                 }
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОКНО РЕЗУЛЬТАТОВ  :  Вывод страниц с результатами на экран

 otvet = true;
 n=0;

 while (otvet) {        // Цикл для страниц
         if (page == 1) {
                 MsgBox (mPage[0]);
                 break;
                 }
         otvet = AskYesNo (mPage[n]);
         n++;
         if (n == page)  {
                 n=0;
                 otvet = !otvet;
                 }
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------

}




                 ///  ИСТОРИЯ ИЗМЕНЕНИЙ


//   За основу взят скрипт "Генеральная уборка" (v.2.2)
//   Авторы: jurgennt, Sclex, Faiber (01.05.2007 – 07.05.2008)

// v.3.0 — Общая редакция — Александр Ка (11.02.2024)
// • В 2-3 раза увеличено количество функций.
// • В среднем на 45% увеличена скорость выполнения.
// • В 10 раз уменьшено количество ошибок обработки.
// • Меньше пропущенных ошибок.
// • Режимы обработки.
// • Экранирование от изменений формата "код", эл. адресов и ссылок.
// • Значительно улучшено окно вывода результатов.
// • Автоматическая запись в историю изменений.
//  и т.д.

// v.3.1 — Александр Ка (18.03.2024)
// Добавлены окна вопросов об обработке/экранировании кода
// Увеличено количество пословиц

// v.3.2 — Александр Ка (27.03.2024)
// Добавлена автоматическая повторная обработка строки
// Расширены и улучшены операции по преобразования выделения подчеркиванием в курсивный/полужирный шрифт (№ 155-157).
// Упорядочена структура скрипта (теперь он немного понятней)

// v.3.3 — Александр Ка (25.06.2024)
// Удален №101. Удаление лишних идентификаторов (иногда ошибается)
// Удален №430. Кавычки (») + пропущенный пробел (иногда ошибается)
// Добавлен №901. Исправление ошибочного добавления градуса Цельсия (°C)
// Добавлен №512. Лишний пробел между числами через короткое тире
// Объединение некоторых схожих строк статистики ("исправления")
// Увеличение ширины строк статистики

// v.3.4 — Александр Ка (01.09.2024)
// Настройки: Добавлена возможность отключения расстановки ударений; Регулировка высоты колонки в статистике; Возможность включения демонстрационного режима.
// Замена основных циклов на более быстрые и устойчивые к аномалиям структуры
// Небольшая адоптация окон к стилю win7 (удаление/замена декора)
// Исключение из окон вопросов строк с дефисом/тире между римскими числами
// Добавлены, проверены и улучшены операции, предложенные TaKir-ом: № 011, 101, 102, 103, 104, 105, 106, 107, 116.
// Добавлен раздел "Постобработка" с двумя полуавтоматическими операциями:    №901 и новая операция №911

// v.3.5 — Александр Ка (10.09.2024)
// Устранение замедления при выборе в FBE прозрачного символа для н/р пробела
// Сохранение длинного тире без пробелов между названиями (например: "Москва—Кассиопея")
// Добавление названий сезонов в промежутки времени

// v.3.6 — Александр Ка (1.01.2025)
// Удален №115 (в "Чистке структуры" есть более полная версия этой операции)
// Улучшено добавление строк в "историю"
// Удалена настройка режима "Повторить всё" (теперь он всегда включен)
// Исправлены все ошибки в окнах для win7
// Страничный вид окна результатов

// v.3.7 — Александр Ка (14.01.2025)
// Добавлен № 921. обработка р а з р я д к и (с настройками)
// Исправлена ошибка версии 3.6 (окно вопроса по длинному тире)

// v.3.8 — Александр Ка (22.01.2025)
// Исправлены мелкие ошибки в № 690, 921, связанные с н/р пробелами в разрядке.

// v.3.9 — Александр Ка (28.01.2025)
// Изменен номер "515" на "581. ISBN, ББК, УДК, ГОСТ", + расширение функций этой операции.

// v.3.10 — Александр Ка (4.02.2025)
// Отмена объединения некоторых строк статистики ("исправления").
// Из-за чего добавились отдельные строки для операций № 158, 570, 631, 731, 732, 772; и изменились названия некоторых других операций.
// Улучшены операции № 155-158, 610, 611, 615, 616, 921.
// Исправлены две ошибки

// v.3.11 — Александр Ка (12.04.2025)
// Изменено название скрипта (было "Генеральная уборка")
// Улучшена функция повышения версии файла и запись в историю изменений
// Добавлены "настройки"
// Добавлены счетчики дней до праздников
// операция 119. снятие выделения с пробелов  -  расширена на все внутренние теги
// операция 160. диакрúтика  ›››  ударе́ние  -  расширена на одну замену ò ››› о́
// Добавлены операции:
//   012. объединение ссылок
//   109. спец. символы  ›››  знак градуса
//   110. символы дробей  ›››  запись с тегами
//   111. стандартизация надстрочных цифр
//   112. стандартизация подстрочных цифр
//   114. стандартизация символа «/»
//   202. объединение тегов индекса
//   203. удаление ссылок без текста
//   204. удаление пустых тегов

// v.3.12 — Александр Ка (26.04.2025)
// Удалена операция №160. диакрúтика  ›››  ударе́ние (перенесена в скрипт "Кириллица-латиница")

// v.3.14 — Изменение функции "повышения версии файла и запись в историю изменений" — Александр Ка (19.05.2025)

// v.3.15 — Исправление ошибок для режима "Сохранение дефиса рядом с цифрой" — Александр Ка (13.06.2025)











