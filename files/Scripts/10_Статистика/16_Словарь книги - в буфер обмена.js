//----------------------------------------------------------------------------------------------------------------------------
//                     «Словарь книги – в буфер обмена»
//  Скрипт предназначен для создания списка уникальных слов книги (авторский словарь)
//----------------------------------------------------------------------------------------------------------------------------
//  Скрипт тестировался в FBE v.2.7.7 (win XP, IE8 и win 7, IE11)
//----------------------------------------------------------------------------------------------------------------------------
// v.1.0 — Создание скрипта — Александр Ка (22.02.2025)
// v.1.1 — Мелкие правки — Александр Ка (02.05.2025)
//----------------------------------------------------------------------------------------------------------------------------

function Run() {

 var NumerusVersion="1.1";
 var Ts=new Date().getTime();

// ---------------------------------------------------------------
                 ///  НАСТРОЙКИ
// ---------------------------------------------------------------

         //     Показывать предупреждение о продолжительном времени вычислений

 var Preduprezhdenie_on_off = 1;      // 0 ; 1 //      ("0" — отключить, "1" — показывать)

 // * Скрипт медленно работает только в winXP

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 ///  Функция склонения по падежам в зависимости от числа

 var ok=0;
 function pad(Numer) {
         var m1;
         var m2;
         var Numer;
         ok=2;
         m1=Numer % 10;
         m2=Numer % 100;
         if (m2<11 || m2>19) {
                 if (m1==1) ok=0;
                 else  if (m1==2 || m1==3 || m1==4) ok=1;    }
         return ok;
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ВЫЧИСЛЕНИЯ

 var T_pause=0;  //  продолжительность диалоговых пауз.

         //   Получение всех слов из <body>

 var Txt="";   //  Текст <body>
 var fbwBody=document.getElementById("fbw_body");
 var mChild = fbwBody.children;     //  Получение всех первых разделов "fbw_body"
 var n=0;

 for (n=0;  n<mChild.length;  n++)            //  Последовательный просмотр этих разделов.
         if (mChild[n].className == "body") {     //  Если встретилось <body>...
                 Txt=mChild[n].innerText.toUpperCase();    //  сохраняем весь текст без тегов, в верхнем регистре
                 break;                                                         //  и завершаем поиск.
                 }

 if (Txt.search(/[А-Я́Ё]+/) == -1) {                         //  Если в тексте нет русских букв...
         MsgBox ("   В разделе <body> нет слов.                 ");   //  делаем соответствующее сообщение
         return;                                                          //  и выходим из скрипта.
         }

 var mSlovo1=[];                           //  Первый массив для слов (все слова без сортировки).
 mSlovo1=Txt.match(/[A-Z0-9\-]*[А-ЯЁ][А-Я́ЁA-Z0-9\-]*/g);


         //  Проверка на сложность вычислений

 var count_Slovo=mSlovo1.length;           //  Количество слов.
 var slov = [" слово", " слова", " слов"];

 if (Preduprezhdenie_on_off == 1  &&  count_Slovo>=130000  &&  count_Slovo<200000) {
         T_pause -= new Date().getTime();  // Определение продолжительности паузы в вычислениях.
         if (!AskYesNo("В разделе <body> найдено "+(count_Slovo+"").replace(/(\d)(?=(\d\d\d)+$)/g, "$1.")+slov[pad(count_Slovo)]+".              \n"+
                            "Для такого количества, дальнейшее              \n"+
                            "составление списка уникальных слов              \n"+
                            "может занять продолжительное время.              \n\n"+
                            "                    Продолжить?\n\n"))  return;
         T_pause += new Date().getTime();  // Определение продолжительности паузы в вычислениях.
         }

 if (Preduprezhdenie_on_off == 1  &&  count_Slovo>=200000) {
         T_pause -= new Date().getTime();  // Определение продолжительности паузы в вычислениях.
         if (!AskYesNo("В разделе <body> найдено "+(count_Slovo+"").replace(/(\d)(?=(\d\d\d)+$)/g, "$1.")+slov[pad(count_Slovo)]+".              \n"+
                            "     Для дальнейшего составления\n"+
                            "           списка уникальных слов\n"+
                            "может  потребоваться  значительный\n"+
                            "             промежуток  времени.\n\n"+
                            "                    Продолжить?\n\n"))  return;
         T_pause += new Date().getTime();  // Определение продолжительности паузы в вычислениях.
         }


         //  Первая сортировка (получение массива с уникальными словами - сортировка по алфавиту)

 var mSlovo2=[" ", "№"];            //  Второй массив слов обрамляется заведомо непреодолимыми минимумом и максимумом.
 var m_Count_Slovo2=[0, 0];   //  Массив для счетчиков слов - обрамляется любыми значениями.

 var k1=0;                               //  Индексы первого и последнего элемента в фрагменте массива.
 var k2=0;
 var k_Midi=0;                   //  Индекс для среднего элемента в фрагменте массива.

 aaa:     // метка
 for (n=0; n<count_Slovo; n++) {      // Последовательный просмотр первого массива.
         k1=0;                                                  //  Исходное значение  для начала фрагмента.
         k2=m_Count_Slovo2.length-1;   //  Исходное значение  для конца фрагмента.
         while (k2-k1 != 1) {                                        //  Цикл, который будет выполняться, пока фрагмент массива не будет состоять из двух элементов.
                 k_Midi = Math.floor((k2+k1)/2);          //  Получение индекса среднего элемента  внутри фрагмента.
                 if (mSlovo1[n] == mSlovo2[k_Midi]) {     //  Если проверяемое слово совпадает со словом во втором массиве...
                         m_Count_Slovo2[k_Midi]++;           //  увеличивается счетчик для этого слова,
                         continue aaa;                                   //  и переходим к следующему слову.
                         }
                 if (mSlovo1[n] > mSlovo2[k_Midi])    //  Если слово больше среднего элемента...
                         k1=k_Midi;                                       //   сдвигаем начало фрагмента на место среднего элемента,
                     else  k2=k_Midi;                               //  а если нет - сдвигаем конец фрагмента.
                 }                                                              //  После того, как фрагмент уменьшился до двух элементов...
         mSlovo2.splice(k2, 0, mSlovo1[n]);     //  добавляем во 2-й массив проверяемое слово между этими элементами,
         m_Count_Slovo2.splice(k2, 0, 1);         //  и добавляем во 2-й массив счетчиков количество этого слова ("1")
         }

 mSlovo2.pop();                 //  Удаляем уже ненужное обрамление в обоих массивах.
 mSlovo2.shift();
 m_Count_Slovo2.pop();
 m_Count_Slovo2.shift();

 // * Разбиение второго массива на несколько подмассивов приводит к уменьшению скорости. На 40 подмассивов - в 2 раза, на 2 - в 15 раз.


         //  Вторая сортировка (получение полностью отсортированного массива с уникальными словами)

 var count_dict=m_Count_Slovo2.length;               //  Счетчик уникальных слов

 var mSlovo3=["", ""];                                  //  Третий массив слов - обрамляется любыми значениями.
 var m_Count_Slovo3=[1000000, 0];     //  Третий массив счетчиков - обрамляется заведомо непреодолимыми максимумом и минимумом.

 for (n=0; n<count_dict; n++) {      // Последовательный просмотр 2-го массива.
         k1=0;                                                  //  Исходное значение  для начала фрагмента.
         k2=m_Count_Slovo3.length-1;   //  Исходное значение  для конца фрагмента.
         while (k2-k1 != 1) {                                        //  Цикл, который будет выполняться, пока фрагмент массива не будет состоять из двух элементов.
                 k_Midi = Math.floor((k2+k1)/2);          //  Получение индекса среднего элемента  внутри фрагмента.
                 if (m_Count_Slovo2[n] <= m_Count_Slovo3[k_Midi])   //  Если очередной счетчик массива меньше или равен среднему элементу...
                         k1=k_Midi;                                   //   сдвигаем начало фрагмента* на середину,
                     else  k2=k_Midi;                             //   а если нет - сдвигаем конец фрагмента.
                 }                                                              //  После того, как фрагмент уменьшился до двух элементов...
         mSlovo3.splice(k2, 0, mSlovo2[n]);                              //  добавляем во 3-й массив проверяемое слово между этими элементами,
         m_Count_Slovo3.splice(k2, 0, m_Count_Slovo2[n]);  //  и добавляем во 3-й массив счетчиков общее количество этого слова ("1")
         }
         // * Начало фрагмента сдвигается чаще, поэтому новый элемент чаще добавляется ближе к концу массива, а это быстрее.

 mSlovo3.pop();                 //  Удаляем уже ненужное обрамление в обоих массивах.
 mSlovo3.shift();
 m_Count_Slovo3.pop();
 m_Count_Slovo3.shift();

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОКНО РЕЗУЛЬТАТОВ  :  Текущее время и дата

 var currentFullDate = new Date();

 var currentHours = currentFullDate.getHours();
 var currentMinutes = currentFullDate.getMinutes();
 var currentSeconds = currentFullDate.getSeconds();

 if (currentMinutes<10) currentMinutes = "0" + currentMinutes;
 if (currentSeconds<10) currentSeconds = "0" + currentSeconds;

 var currentDay = currentFullDate.getDate();
 var currentMonth = 1+currentFullDate.getMonth();
 var currentYear = currentFullDate.getFullYear();

 if (currentMonth<10) currentMonth = "0" + currentMonth;
 currentYear = (currentYear+"").replace(/^.*?(\d{1,2})$/g, "$1");

 var currentTime = currentHours + ":" + currentMinutes + ":" + currentSeconds;
 var currentDate = currentDay + "." + currentMonth + "." + currentYear;

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОКНО РЕЗУЛЬТАТОВ  :  Подсчет чистого компьютерного времени, потраченного на обработку текста

 var Tf=new Date().getTime();
 var tempus=0;

 var T2=(Tf-Ts-T_pause);
 var Tmin  = Math.floor((T2)/60000);
 var TsecD = ((T2)%60000)/1000;
 var Tsec = Math.floor(TsecD);

 if (Tmin ==0)
         tempus = (+(TsecD+"").replace(/(.{1,5}).*/g, "$1")+"").replace(".", ",")+" сек";
     else {
             tempus = Tmin+" мин";
             if (Tsec !=0)
                     tempus += " " + Tsec+ " с" }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОКНО РЕЗУЛЬТАТОВ  :  Сборка массива с результатами обработки

 var mSt=[];
 var ind=0;
 var protsent = (Math.round(count_dict/count_Slovo*1000)/10 + "").replace(".", ",");

 mSt[ind]=" «Словарь книги – в буфер обмена» v."+NumerusVersion;  ind++;
 mSt[ind]="--------------------------------------------------------";  ind++;
 mSt[ind]="					   ";  ind++;

 mSt[ind]="• СТАТИСТИКА:				";  ind++;
 mSt[ind]="   Время выполнения  .  .  .  .  .  .  .  .	"+tempus;  ind++;
 mSt[ind]="   Всего слов  .  .  .  .  .  .  .  .  .  .  .  .	"+count_Slovo;  ind++;
 mSt[ind]="   Уникальных слов .  .  .  .  .  .  .  .  .	"+count_dict+" ("+protsent+"%)";  ind++;

 //  Сборка строк текущей даты и времени
 mSt[ind]="";  ind++;
 mSt[ind]= "• "+currentDate+" • "+currentTime+" •";  ind++;

 mSt[ind]="";  ind++;
 mSt[ind]="--------------------------------------------------------";  ind++;
 mSt[ind]=" ◊  Отправить список уникальных слов";  ind++;
 mSt[ind]="                  в буфер обмена?\n";  ind++;

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОКНО РЕЗУЛЬТАТОВ  :  Вывод окна результатов на экран

 var st2="";  //  текст результатов

 for  ( n=0; n!=ind; n++ )
        st2+=mSt[n]+"\n";  //  Добавление элемента из массива.


 //  Вывод окна результатов (и вопроса о сохранении в буфер)

 if (!AskYesNo(st2))  return;       //  при отрицательном ответе - выход из скрипта.

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// СОХРАНЕНИЕ СПИСКА

 var Txt2="Число слов в тексте	Слово\n";     //  Первая строка текста, который отправится в буфер.

 for (n=0; n<count_dict; n++)       //  Последовательный перебор всех слов и счетчиков к ним.
         Txt2+=m_Count_Slovo3[n]+"	"+mSlovo3[n].replace(/(.).*/g, "$1")+mSlovo3[n].replace(/^(.)/g, "").toLowerCase()+"\n";      //  Сборка очередной строки (с понижением регистра букв).

 window.clipboardData.setData("text", Txt2);     //  Отправка полученного текста в буфер обмена.

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------

}







