//======================================
//             «Чистка структуры»
// Скрипт тестировался в FBE v.2.7.6 (win XP, IE8 и win 7, IE9 и IE11)
// * История изменений в конце скрипта
//======================================

function Run() {
 var ScriptName="«Чистка структуры»";
 var NumerusVersion="1.12";
 var Ts=new Date().getTime();

//--------------------------------------------------------------------
                 ///  НАСТРОЙКИ
//--------------------------------------------------------------------

//     Переоформление иллюстраций (Выведение картинки из пустого параграфа)
//     * Обрабатываются картинка выделенная курсивом, жирностью, зачеркиванием, верхним/нижним индексом. Кроме того, рядом с картинкой могут быть пробелы.
//     ** Все остальные случаи не обрабатываются. Например, когда в строке есть вторая картинка, текст, или если картинка служит сноской или ссылкой.
//     *** Кроме того, не обрабатывается параграф в заголовке, аннотации, истории, эпиграфе, в стихах, в цитате -- там возможна графика только внутри текста

var Obrabotka_Img_v_Texte_on_off = 1;      // 0 ; 1 ; 2 //      ("0" — никогда не переоформлять, "1" — всегда переоформлять, "2" — всегда спрашивать)

//--------------------------------------------------------------------

//     Перемещать иллюстрации из "кармана" в отдельную секцию
//     <section> ... [иллюстрация] [внутренние секции] </section>   ›››   <section> ... [иллюстрация в отдельной секции] [внутренние секции] </section>
//     *  Под многоточием (...) может скрываться заголовок и/или эпиграфы
//     **  После перемещения, рядом с иллюстрацией создается ещё и новая пустая строка

var Obrabotka_karm_Img = 1;      // 0 ; 1 ; 2 //      ("0" — никогда не перемещать, "1" — всегда перемещать, "2" — всегда спрашивать)

//--------------------------------------------------------------------

//     Удалять пустую строку посреди текста заголовка

var Obrabotka_Entity_ttl = 1;      // 0 ; 1 ; 2 //      ("0" — никогда не удалять, "1" — всегда удалять, "2" — всегда спрашивать)

//--------------------------------------------------------------------

//               Добавление пустой строки рядом с иллюстрацией (внутри секции)

//     1. Пустая строка между иллюстрацией и [подзаголовком, цитатой или обычным текстом]

var Add_Entity_Img_Podpis = 0;      // 0 ; 1 //       ("0" — не изменять, "1" — всегда добавлять)

//     * Подзаголовки, цитаты и обычный текст могут использоваться как подписи или надписи к иллюстрациям.
//        Принято не добавлять пустую строку между ними.
//        Более качественная расстановка пустых строк между иллюстрациями и надписями/подписями есть в скрипте "Пустые строки рядом с иллюстрациями".


//     2. Пустая строка между иллюстрацией и заголовком

var Add_Entity_Img_Title = 0;      // 0 ; 1 //       ("0" — не изменять, "1" — всегда добавлять)

//     * Принято не добавлять пустую строку между ними. Но в некоторых читалках может получиться некрасиво


//     3. Пустая строка между двумя иллюстрациями

var Add_Entity_Img_Img = 0;      // 0 ; 1 //       ("0" — не изменять, "1" — всегда добавлять)

//     * Возможно это две части разрезанной иллюстрации (например, высокой таблицы)
//        Более качественная расстановка пустых строк между двумя иллюстрациями есть в скрипте "Пустые строки рядом с иллюстрациями".

// ---------------------------------------------------------------

         //   •  Расположение найденного слова или строки
 var Raspolozhenie = 82;      // проценты //       50% — середина окна с текстом книги;  больше/меньше 50% — выше/ниже середины.

// ---------------------------------------------------------------

         //  Автоматическое повышение версии файла и запись в историю изменений

 var Version_on_off = 0;      // 0 ; 1 //      ("0" — отключить, "1" — включить)

//  Добавлять, если не сделано ни одного исправления
 var Vsegda_on_off = 0;      // 0 ; 1 //      ("0" — отключить, "1" — включить)

//   Имя используемое в добавленной записи:
 var youName = "Зорро";

//  * Можно использовать почти любые символы. Исключения:   |  "  |  \  |    Но и любой из этих знаков можно добавить, если поставить перед ним наклонную черту ("\"), например: "\\" = "\"
//  ** Или можно оставить эти кавычки пустыми (""), тогда строка в истории будет без имени.

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОБЩИЕ ПЕРЕМЕННЫЕ

//   Неразрывный пробел из настроек FBE
 var nbspEntity="&nbsp;";    //  Присваиваем переменной н/р пробела значение стандартного кода.
 try  {
         var nbspChar=window.external.GetNBSP();   //  Получаем выбранный символ неразрывного пробела.
         if (nbspChar.charCodeAt(0) != 160)   //  Если используется нестандартный символ...
                 nbspEntity = nbspChar;   //  то заменяем стандартный код на этот символ.
         }
 catch(e) {            //  Если команда для получения символа н/р пробела вызывает ошибку...
         var nbspChar=String.fromCharCode(160);   //  то используем стандартный символ н/р пробела
         }

//  Счетчики цикла
var i = 0;
var j = 0;
var jj = 0;
var n = 0;
var k = 0;

//  Структура текста (аннотация + история + все <body>, иначе говоря, всё что видно в режиме "B"-дизайн)
 var fbwBody=document.getElementById("fbw_body");
 var fbwBodyMargin=false;   //  Индикатор добавления полей для "fbw_body"

//  Подсчет времени, затраченного на паузы при открытии окон
 var T_pause=0;

 var StyleDiv;      //  Раздел стилей.

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ФУНКЦИЯ "Генератор случайных чисел, с округлением"

 function Rn_(rndN) {
         return Math.floor(("0000000"+Math.tan(Ts+Math.random()*2000)).replace(/[\.\-]/g, "").replace(/.+(\d\d\d\d\d\d)\d$/g, "0.$1")*rndN);  //  Генерация случайных чисел от 0 до "rndN".
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ФУНКЦИЯ ПЕРЕХОДА

// * В отличии от встроенной функции "GoTo", положение курсора не меняется, но есть прокрутка влево.

 function GoTo_0(elem) {
         var b=elem.getBoundingClientRect();                     //  Получение координат элемента.
         var c=fbwBody.parentNode.getBoundingClientRect();    //  Получение координат раздела <BODY>.
         var wH=window.external.GetViewHeight() - 6;         //  Высота окна с текстом книги (с запасом по 3 пикселя по краям).
         var wW=window.external.GetViewWidth();         //  Ширина окна с текстом книги.
         var h=b.bottom-b.top;                  //  Высота элемента (в пикселях).
         var Width=c.left;         //  Сдвиг вбок.

         if (b.right-c.left > wW) {      //  Если правый край элемента может выйти за границу окна...
                 if (b.right-b.left < wW)     //  то проверяем длину элемента, и если она меньше длины окна,
                         Width = b.right-wW;   //  то выставляем элемент впритык к правому краю окна,
                     else  Width = b.left;      //  а если больше - то выставляем элемент впритык к левому краю.
                 }

         if (h <= wH)          //  Если высота элемента меньше высоты окна...
                 window.scrollBy(Width, b.top - 3 - (wH-h)*(1-Raspolozhenie*0.01))   //  то выставляем элемент согласно указанному расположению,
             else  window.scrollBy(Width, b.top - 3);       //  а если нет - то выставляем элемент почти впритык к верхнему краю.
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ФУНКЦИЯ ДЛЯ ОБНОВЛЕНИЯ нескольких ИЛЛЮСТРАЦИЙ
                 // * обновление вернет на место "сдвинутые" иллюстрации

 var nextP;              //  Раздел параграфа.

 function updateImg(nextP) {
         var mImgR=[];    //  Массив для иллюстраций из одной строки
         var MyImg;
         var pic_id;
         for (var ii=0; ii<=10; ii++) {        //  Проверяется указанный раздел + 10 разделов после него.
                 if (nextP.nodeName =="P"  &&  nextP.innerHTML.search("<IMG ") != -1) {       //  Если найденный раздел - параграф, в котором есть тег <IMG>...
                         mImgR = nextP.getElementsByTagName("IMG");            //  Получаем массив с разделами <IMG>
                         for (i=mImgR.length-1; i>=0; i--) {                                         //  и перезаписываем имена иллюстраций.
                                 MyImg=mImgR[i];
                                 pic_id=MyImg.src;
                                 MyImg.src="";
                                 MyImg.src=pic_id;
                                 //MyImg.outerHTML=MyImg.outerHTML;   //  Перезапись раздела иллюстрации (вроде бы лишнее).
                                 }
                         }
                 if (nextP.nodeName != "P"  &&  nextP.firstChild)  //  Если найденный раздел - не параграф, и в нем есть другие элементы...
                         nextP=nextP.firstChild;                                            //  переходим на самый первый элемент этого раздела.
                 else {                                                                     //  Иначе...
                         while (! nextP.nextSibling)  {                    //  пока не появится у нашего элемента сосед справа...
                                 nextP=nextP.parentNode;                 //   выходим из разделов.
                                 if (nextP == fbwBody) return;    //  А если при этом процессе оказываемся в корневом разделе, то выходим из этой функции.
                                 }
                         nextP=nextP.nextSibling;              //  Сосед справа есть - Переходим на следующий элемент.
                         }
                 }
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ФУНКЦИЯ КОНВЕРТАЦИИ ВРЕМЕНИ  (мс  => мин, сек)

 var tempus=0;
 var T;

 function time(T) {

         var Tmin  = Math.floor(T/60000);
         var TsecD = (T%60000)/1000;
         var Tsec = Math.floor(TsecD);

         if (Tmin ==0)
                 tempus = (+(TsecD+"").replace(/(.{1,5}).*/g, "$1")+"").replace(".", ",")+" сек";
             else {
                     tempus = Tmin+" мин";
                     if (Tsec !=0)
                             tempus += " " + Tsec+ " с" }

         return tempus;

         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ФУНКЦИЯ СКЛОНЕНИЯ ПО ПАДЕЖАМ В ЗАВИСИМОСТИ ОТ ЧИСЛА

 var ok=0;

 function pad(Numer) {
         var m1;
         var m2;
         var Numer;
         ok=2;
         m1=Numer % 10;
         m2=Numer % 100;
         if (m2<11 || m2>19) {
                 if (m1==1) ok=0;
                 else  if (m1==2 || m1==3 || m1==4) ok=1;    }
         return ok;
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 ///   Функция преобразования в код

 function inCode(text) {      //  Преобразование обычного текста в код.
         return  text.replace(/&/g, "&amp;").replace(/ /g, nbspEntity).replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/­/g, "&shy;");
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 ///  ФУНКЦИЯ ПОВЫШЕНИЯ ВЕРСИИ ФАЙЛА И ЗАПИСЬ В ИСТОРИЮ ИЗМЕНЕНИЙ

 function HistoryChange(Script_Name, youName) {


         // Получение раздела истории

// var fbwBody=document.getElementById("fbw_body");     //  **  эта строка уже есть в скрипте  **
 var History=fbwBody.firstChild;   //  Предполагаемый раздел истории.

 //  Поиск раздела "историй"
 while (History != null  &&  History.className != "history")    //  Пока не найдем настоящий раздел истории, или окажется, что истории нет в тексте...
         History = History.nextSibling;         //  переходим на следующий раздел.

//  Добавление раздела истории
 if (History==null)  {                 //   Если нет истории...
         History = document.createElement("DIV");     //   Создание нового раздела
         var Annotation=fbwBody.firstChild;
         while (Annotation!=null  &&  Annotation.className!="annotation") Annotation=Annotation.nextSibling;   //  Поиск аннотации к книге
         if (Annotation!=null)  Annotation.insertAdjacentElement("afterEnd",History);      //  Размещаем новый раздел    или после аннотации (если она есть)...
                 else  fbwBody.insertAdjacentElement("afterBegin",History);                //  ...или в начале "fbwBody"
         History.className = "history";      //  Присваиваем новому разделу    класс "история" и необходимые атрибуты
         History.setAttribute("xmlns:l", xlNS);    //  "xlNS" и "fbNS" - переменные из "main.js"
         History.setAttribute("xmlns:f", fbNS);
         History.insertAdjacentElement("beforeEnd",document.createElement("P"));     //  Добавляем пустую строку
         window.external.inflateBlock(History.lastChild)=true;
         }


         //  Создание массива с прошедшими датами

 var mDate=[];         //  Массив с прошедшими датами.
 var D = new Date().getTime();   //  Начальное значение даты.
 var fullDate;
 var Day;
 var Month;
 var Year;

 for (var j=0; j<10; j++) {              //  Запускаем цикл для получения недавних дат, в котором...
         fullDate = new Date(D);                         //  получаем полную дату,
         Day = fullDate.getDate();                            //  день месяца,
         Month = ("0" + (1+fullDate.getMonth())).replace(/^.*?(\d\d)$/g, "$1");   //  месяц,
         Year = fullDate.getFullYear();       //  год,
         mDate[j] = Day + "." + Month + "." + Year;             //  и заполняем массив текстом очередной даты (Д.ММ.ГГ).
         D -= 86400000;                       //  При этом каждый раз уменьшаем проверяемую дату на один день.
         }


         //  Поиск недавней записи в "истории"

 var povtorD = false;   //  Индикатор повторной обработки в последние 10 дней.
 var mP = History.getElementsByTagName("P");   //  Получение всех строк в "Истории".
 var s="";               //  Содержимое строки.
 var k=0;               //  Счетчик цикла.

fff:
 for (j=mP.length-1;  j>=0;  j--) {    //  Последовательный просмотр строк истории.
         s = mP[j].innerHTML;                //  Содержимое строки.
         for (k=0; k<10; k++) {                //  и запускаем цикл для проверки даты.
                 if (s.search(mDate[k]) !=-1) {   //  Если проверяемая дата есть в строке истории...
                         povtorD = true;                    //  то отмечаем это,
                         break fff;                            //  и прерываем оба цикла проверки.
                         }
                 }
         }


         //  Обновление записи в истории изменений

 try  { youName = fbeUserName }   //  Если есть строка:   var fbeUserName = "Имя";   в файле "main.js"  --  Изменение имени в соответствии с глобальной переменной.
 catch(e)  {}                                            //  Если глобальная переменная отсутствует - пропуск операции по изменению имени.

 var textYouName = inCode(youName+"");    //  Имя в тексте.
 if (youName!="")                           //  Если есть заполненное имя...
         textYouName += ", ";   //  то добавляем к текстовой записи запятую.

 Script_Name = inCode(Script_Name);    //  Имя скрипта текстом.

 var reHist00s = new RegExp("[^А-яЁёA-Za-z0-9]"+Script_Name+"[^А-яЁёA-Za-z0-9]","");   //  Стартовая.
 //  Добавление точки с запятой
 var reHist01 = new RegExp("(.[^…\\\?!\\\.,;:—])(\\\s|"+nbspEntity+")(— "+textYouName+mDate[k]+")","");
 var reHist01_ = "$1; $3";
 //  Добавление точки
 var reHist02 = new RegExp("(.[^…\\\?!\\\.,;:—])[,;:]{0,1}(\\\s|"+nbspEntity+")(— "+textYouName+mDate[k]+")","");
 var reHist02_ = "$1. $3";
 //  Добавление слова "Скрипт"
 var reHist03 = new RegExp("(.)(\\\s|"+nbspEntity+")(— "+textYouName+mDate[k]+")","");
 var reHist03_ = "$1 Скрипт: $3";
 //  Добавление имени скрипта
 var reHist04 = new RegExp("(.)(\\\s|"+nbspEntity+")(— "+textYouName+mDate[k]+")","");
 var reHist04_ = "$1 "+Script_Name+" $3";

 if (povtorD) {                                         //  Если найдена запись с недавней датой...
         if (s.search(reHist04) !=-1) {    //  и если в строке имя пользователя и дата записаны по форме: "— (Имя, Дата)"...
                 if (s.search(reHist00s) ==-1) {    //  то проверяем строку на наличие записи имени скрипта, и если этой записи нет...
                         if (s.search(/([Сс]крипт):/) !=-1)  s = s.replace(/([Сс]крипт):/g, "$1ы:");   //  то заменяем при необходимости слово "Скрипт" на "Скрипты",
                         if (s.search(reHist01) !=-1)  s = s.replace(reHist01, reHist01_);                   //  добавляем при необходимости точку с запятой,
                         if (s.search(/[Сс]крипты?:/) ==-1)  s = s.replace(reHist02, reHist02_).replace(reHist03, reHist03_);   //  добавляем при необходимости слово "Скрипт"
                         s = s.replace(reHist04, reHist04_);      //  и добавляем имя скрипта.
                         }
                 if (k != 0)                                                    //  Затем проверяем дату, и если она не сегодняшняя...
                         s = s.replace(mDate[k], mDate[0]);   //  то заменяем на сегодняшнюю.
                 if (mP[j].innerHTML != s) {                //  Затем проверяем изменилась ли строка истории, и если она изменилась...
                         mP[j].innerHTML = s;          //  то сохраняем её в тексте
                         HiCh=3;   //  и отмечаем это на индикаторе.
                         }
                 }
             else                                  // Если же есть недавняя дата, но запись сделана не по форме...
                 povtorD = false;   //  Объявляем, что недавняя дата - посторонняя, и надо повышать версию и добавлять новую строку в историю.
         }

 if (povtorD)  return;   //  Если производилась обработка записи в истории - выход из функции.


         //  Повышение версии

 var versionText = "";           //  Текст с версией в истории изменений.

 //  Проверка на валидность версии файла
 var ValidationVersion=(versionFile.length <=10  &&  versionFile.search(/^\d{0,10}(\.\d{1,8})?$/g) !=-1);    //  сравнение с шаблоном:  "цифры + (точка + цифры)"

 //   Изменение версии файла
 if (ValidationVersion) {
         if (versionFile =="")          //  Если версия не заполнена...
                 versionFile = "1.0";    //  то изменяем начальную версию на "1.0".
         if (versionFile.search(/^\d+$/g) !=-1)   //  Если версия без точки...
                 newVersion = versionFile + ".1";     //  то для новой версии добавляем ".1".
             else {                                                                                         //  Если в версии есть точка...
                     newVersion = +versionFile.replace(/^\d+\./g, "");  //  извлекаем цифры после точки,
                     newVersion++;                                                                                           //  увеличиваем полученное число на единицу
                     newVersion = versionFile.replace(/\.\d+$/g, "")+"."+newVersion;   //   и добавляем к нему первую группу цифр.
                     }
         if (newVersion.length <=10)                                        //  Если новая версия валидна...
                 document.getElementById("diVersion").value=newVersion;   //  то изменяем версию в файле,
                 VersionUp=true;                                                          //  отмечаем это на индикаторе
                 var versionText="v."+newVersion+" — ";    //  и создаем текст для истории.
         }


         //   Добавление строк в историю изменений

 var reHist11 = new RegExp("^(\\\s|"+nbspEntity+"){0,}$","");   //  Признак пустой строки.
 var reHist12 = new RegExp("(^|\\n)[^0-9]{0,12}"+versionFile.replace(/\./, "\\.")+"([^0-9]|$)","");   //  Поиск старой версии.

 //   Добавление строки с информацией о старой версии
 if (ValidationVersion  &&  History.innerText.search(reHist12)==-1) {       //  Если в истории нет записи о старой версии...
         if (History.lastChild.innerHTML.search(reHist11)==-1)                                               //  то проверяем наличие пустой строки в конце истории
                 History.insertAdjacentElement("beforeEnd",document.createElement("P"));       //  и если ее нет - добавляем новую.
         History.lastChild.innerHTML = "v."+versionFile+" — ?";  //  Затем добавляем в строку информацию о старой версии
         HiCh++;                                        //  и изменяем индикатор истории.
         }

 //   Добавление строки с информацией о новой версии
 if (History.lastChild.innerHTML.search(reHist11)==-1)                                   //  Если в конце истории нет готовой пустой строки...
         History.insertAdjacentElement("beforeEnd",document.createElement("P"));   //  то добавляем новую строку.
 History.lastChild.innerHTML = versionText+" Скрипт: "+Script_Name+" — "+textYouName+mDate[0];  //  Добавляем в строку информацию о новой версии.
 HiCh++;                       //  Изменяем индикатор истории.

 }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ПРОВЕРКА РЕЖИМА

 if (fbwBody.style.display == "none") {
         window.external.SetStatusBarText("  •  Скрипт "+ScriptName+" v." + NumerusVersion + " можно запустить только в режиме «B» (Дизайн)");
         return;
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОБРАБОТКА ТЕКСТА _1_  :  Параграфы <P>  :  операции  № 100-103
                 //      (регулярные выражения)

       //  Восстановление параграфа <P> из текстовых элементов и внутренних тегов
 var re100 = new RegExp("^(STRONG|EM|SUP|SUB|STRIKE|SPAN|A)$","g");
 var re101 = new RegExp("</?P>","g");
 var count_100 = 0;

       //  Удаление внутренних тегов вне параграфа
 var count_103 = 0;

       //  Восстановление конечного тега </P>
 var re104 = new RegExp("</P>$","g");

// ---------------------------------------------------------------

 window.external.BeginUndoUnit(document, ScriptName+" v."+NumerusVersion);    // Начало записи в систему отмен.

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОБРАБОТКА ТЕКСТА _1_  :  Параграфы <P>  :  операции  № 100-103
                 //      (Восстановление параграфов)

 var ptr=fbwBody;                                                           //  Начальное значение переменной "ptr"
 var ProcessingEnding=false;                              //  Флаг завершения обработки
 var mPtr;                              //  Узел, который выше параграфа
 var newP;                             //  Новый параграф

 while (!ProcessingEnding)  {             //  Если конца текста не видно — продолжаем путешествие.
         if (ptr.nodeType == 3  ||  (ptr.nodeName.search(re100) != -1  &&  ptr.innerHTML.search(re101) == -1))  {       //  Если встретился текстовый эл-т или внутренний тег...
                 newP = document.createElement("P");              // создаем новый параграф
                 if (ptr.previousSibling)  ptr.previousSibling.insertAdjacentElement("afterEnd", newP);   // если перед "текстом" есть раздел, то вставляем новый <P> после него
                     else ptr.parentNode.insertAdjacentElement("afterBegin", newP);                   // если нет - вставляем в начало родительского раздела
                 // в книге может быть ряд из текстовых элементов и внутренних тегов. Переносим их всех в новую оболочку <P> по очереди
                 while (newP.nextSibling  &&  (newP.nextSibling.nodeType==3  ||  (newP.nextSibling.nodeName.search(re100)!=-1  &&  newP.nextSibling.innerHTML.search(re101) == -1))) {
                         if (newP.nextSibling.nodeType==3)
                                 newP.innerHTML += newP.nextSibling.nodeValue;   // для текстового эл-та получаем значения командой "nodeValue"
                         if (newP.nextSibling.nodeName.search(re100)!=-1)
                                 newP.innerHTML += newP.nextSibling.outerHTML;  // для внутреннего тега - обычной командой "outerHTML"
                         newP.nextSibling.removeNode(true);   // после копирования, удаляем ненужный оригинал
                         }
                 ptr=newP;   // после переноса, заполненный новый параграф становится основной переменной "ptr"
                 count_100++;    // отмечаем проделанную операцию в счетчике
                 }
         if (ptr.nodeName=="P")                  //  Если встретился параграф...
                 if (ptr.outerHTML.search(re104)==-1)  {            // и в этом параграфе отсутствует конечный тег
                         newP = document.createElement("P");              // создаем новый параграф
                         newP.innerHTML = ptr.innerHTML;                       // копируем в него содержание ущербного параграфа
                         ptr.insertAdjacentElement("afterEnd", newP);    // вставляем новый параграф после "оригинала"
                         ptr = newP;                                                                   // присваиваем ему имя "ptr"
                         ptr.previousSibling.removeNode(true);   // удаляем ненужный оригинал
                         count_100++;
                         }
         if (ptr.firstChild!=null  &&  ptr.nodeName!="P")                //  Если есть куда углубляться, и это всё ещё не параграф...
                 { ptr=ptr.firstChild }                                                       //  ...тогда спускаемся на один уровень.
             else {                                                                                                //  Если углубляться нельзя...
                     while (ptr.nextSibling==null)  {                              //  ...и если нет прохода на соседний элемент...
                             if (ptr.parentNode.nodeName.search(re100)!=-1) {
                                     mPtr=ptr.parentNode.getElementsByTagName("P");
                                     for (j=0; mPtr[j]; j++)
                                             mPtr[j].innerHTML= "<"+ptr.parentNode.nodeName+">"+mPtr[j].innerHTML+"</"+ptr.parentNode.nodeName+">";
                                     ptr.parentNode.removeNode(false);   //  удаляем внутренние теги сверху
                                     count_103++;
                                     }
                                 else {
                                         ptr=ptr.parentNode;                                           //  или поднимаемся, пока не появится проход на соседний элемент
                                         if (ptr==fbwBody) {ProcessingEnding=true }           // А если поднявшись, оказываемся в "fbw_body" — объявляем о завершении обработки текста.
                                         }
                             }
                             ptr=ptr.nextSibling;                     //  Затем переходим на соседний элемент.
                     }
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ДОБАВЛЕНИЕ РАЗРЫВА СЕКЦИИ перед заголовком

 var mDiv=fbwBody.getElementsByTagName("DIV");  //  массив с узлами "DIV"
 var div;                //  один из узлов "DIV"

 var section_1;
 var section_2;
 var count_150 = 0;

 for (j=mDiv.length-1; j>=0; j--) {

         div = mDiv[j];

         // Добавление разрыва секции перед заголовком, если заголовок расположен посреди секции
         if (div.className =="title"  &&  div.parentNode.className == "section"  &&  div.previousSibling != null) {
                 section_1 = div.parentNode;
                 section_2 = section_1.cloneNode(false);                                     //  Тогда, копируем оболочку секции...
                 section_1.insertAdjacentElement("afterEnd",section_2);       //  ...и вставляем её после оригинальной секцией.
                 section_2.removeAttribute("id");                                         //  В новой секции удаляем "id", чтобы не получилось два одинаковых индекса в тексте.

                 while (section_1.lastChild.className != "title") {
                         section_2.insertAdjacentElement("afterBegin",section_1.lastChild);      //  ...последовательно переносим все элементы после заголовка в новую оболочку секции.
                         }

                 section_2.insertAdjacentElement("afterBegin",section_1.lastChild);      //  Переносим последний элемент (заголовок) в новую оболочку секции.

                 count_150++;
                 }
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОБРАБОТКА ТЕКСТА _2_  :  Параграфы <P>  :  операции  № 2хх
                 //      (регулярные выражения)

          // Замена кода н/р пробела на принятое обозначение в FBE
          // Устраняет небольшой глюк, который получается после вставки в FBE нескольких строк, или после некоторых скриптов
 var re211 = new RegExp("&nbsp;","g");
 var re211_ = nbspChar;
 var count_211 = 0;

         // Чистка пустых строк от пробелов и внутренних тегов
 var re212 = new RegExp("^(\\\s|"+nbspChar+"|<[^>]{1,}>){1,}$","g");
 var re212ex = new RegExp("<SPAN [^>]{0,}?class=image","g");
 var re212_ = "";
 var count_212 = 0;

         // Снятие форматирования "подзаголовок" с пустой строки
 var count_213 = 0;

         // Снятие форматирования "автор текста" с пустой строки
 var count_214 = 0;


         // Добавление формата "подзаголовок" для строк из символов

//  Разделы, где могут быть подзаголовки
 var re221 = new RegExp("^(annotation|poem|cite|history|section)$","g");

//  Для удаления пяти внутренних тегов
 var re222 = new RegExp("</{0,1}STRONG>|</{0,1}EM>|</{0,1}SUP>|</{0,1}SUB>|</{0,1}STRIKE>","g");

//  Для преобразования строк в подзаголовок, состоящих из символа ⁂ (три звездочки), или из 1-9 одинаковых символов ( • | * | + ), или из 3-9 одинаковых символов ( х | - | – | — | ~)  (дефисы/тире здесь считаются одинаковыми символами)
 var re223 = new RegExp("^(\\\s|"+nbspChar+"|<[^>]{1,}>){0,}((\\\s|"+nbspChar+"){0,}⁂|((\\\s|"+nbspChar+"){0,}•){1,9}|((\\\s|"+nbspChar+"){0,}\\\*){1,9}|((\\\s|"+nbspChar+"){0,}\\\+){1,9}|((\\\s|"+nbspChar+"){0,}[-–—]){3,9}|((\\\s|"+nbspChar+"){0,}~){3,9}|((\\\s|"+nbspChar+"){0,}[хx]){3,9})(\\\s|"+nbspChar+"|<[^>]{1,}>){0,}$","g");

//  Для удаления внутренних тегов жирности и курсива
 var re224 = new RegExp("</{0,1}STRONG>|</{0,1}EM>","g");

// Замена символа ⁂ (три звездочки) на строку из трех звездочек   (символ ⁂ не видит большинство шрифтов)
 var re225 = new RegExp("^(\\\s|"+nbspChar+"|<[^>]{1,}>){0,}⁂(\\\s|"+nbspChar+"|<[^>]{1,}>){0,}$","g");
 var re225_ = "<SUB>*</SUB><SUP>*</SUP><SUB>*</SUB>";

//  Добавление пробелов между символами  | • | * | + |  для строк, состоящих из 2-5 таких одинаковых символов
 var re226s = new RegExp("^(<[^>]{1,}>){0,}(((\\\s|"+nbspChar+"){0,}•){2,5}|((\\\s|"+nbspChar+"){0,}\\\*){2,5}|((\\\s|"+nbspChar+"){0,}\\\+){2,5})(\\\s|"+nbspChar+"|<[^>]{1,}>){0,}$","g");
 var re226 = new RegExp("([•\\\*\\\+])(\\\s|"+nbspChar+"){0,}(?=[•\\\*\\\+])","g");
 var re226_ = "$1 ";

 var count_227 = 0;  //  Счетчик изменений внутри строки
 var count_228 = 0;  //  Счетчик добавлений формата "подзаголовок"


         //  Внутренняя чистка графики в пустом параграфе  (от пробелов и внутренних тегов)
 var re231s = new RegExp("<SPAN [^>]{0,}?class=image","g");
 var re231 = new RegExp("^(&nbsp;|\\\s|"+nbspChar+"|<[^>]{1,}>){0,}(<SPAN [^>]{0,}?class=image[^>]{0,}>)(<[^>]{1,}>){0,}(<IMG [^>]{1,}>)(&nbsp;|\\\s|"+nbspChar+"|<[^>]{1,}>){0,}$","g");
 var re231_ = "$2$4</SPAN>";
 var count_231 = 0;
 var q_231 = false;

         // Снятие внешнего форматирования с графики в пустом параграфе
 var count_232 = 0;

         //  Блоки, после которых добавляется пустая строка, если они стоят в конце секции
 var re241 = new RegExp("^(title|epigraph|annotation)$","g");
 var count_241 = 0;

         //  Счетчик удаления дублей пустых строк
 var count_251 = 0;

         // Снятие внешнего форматирования с пустой строки
 var re252 = new RegExp("^(title|epigraph|stanza|poem|cite)$","g");  //  класс форматов, разрешенных к очистке
 var count_252 = 0;

         //  Удаление пустых строк в "body" и "fbw_body" (вне секции)
 var count_253=0;

         //  Удаление пустых "body"
 var count_262 = 0;

         //  Удаление пустых секций
 var count_263 = 0;

         //  Удаление пустых строк на окраине всех разделов, кроме таблиц
 var re271 = new RegExp("^(title|epigraph|image|annotation)$","g"); //  класс блоков:   между ними и концом секции сохраняется пустая строка
 var count_271 = 0;

         //  Удаление пустых строк за окраиной блоков
 var re272 = new RegExp("^(title|annotation|stanza|poem|epigraph|cite|subtitle|section)$","g");  //  класс блоков
 var count_272 = 0;

         //  Замена пустых строк на разрыв строф  (в стихах)
 var count_281 = 0;

       //  Поиск графики в тексте
 var re001 = new RegExp("^<SPAN [^>]{0,}?class=image[^>]{0,}><IMG [^>]{1,}></SPAN>$","g");
 var m_001 = [];
 var count_001 = 0;

       //  Поиск пустых строк между строк заголовка
 var m_002 = [];
 var count_002 = 0;

       //  Поиск ссылок
 var m_003 = [];

         // Возвращение кода   "&nbsp;"
 var reNBSPon = new RegExp(nbspChar,"g");
 var reNBSPon_ = "&nbsp;";

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОБРАБОТКА ТЕКСТА _2_  :  Параграфы <P>  :  операции  № 2хх
                 //      (сборка функции "HandleP(ptr)")

         //  Переменные для "большого удаления дублей..."
 var re201test = new RegExp("<(STRONG|EM|SUP|SUB|STRIKE|SPAN)>.{0,}<\\1>.{0,}</\\1>.{0,}</\\1>","g");  //  Грубая проверка на повторные теги.
 var if_201 = true;    // условие для запуска "большого удаления дублей...".
 var subPtr;           // Внутренние элементы параграфа.
 var newSubPtr;  // Внутренний пробный элемент параграфа (кандидат на удаление).
 var mNodeName = [];  //  Массив с внутренними тегами : nodeName.
 var mClassName = [];  //  Массив с внутренними тегами : className (для SPAN).
 var mElement = [];      //  Массив с элементами.
 var addM = false;        //  Индикатор добавления данных в массив.
 var otvet_201;              //  Код кнопки ответа.
 var re201 = new RegExp("^(\\\s|"+nbspEntity+"|[…\\\(\\\[«„“\\\"’—–\\\-]){0,}(.{0,}?)(\\\s|"+nbspEntity+"|[…\\\.,:;\\\?!\\\)\\\]»“”\\\"’—–\\\-]){0,}$","g");   //  Отсекание пунктуации.
 var re201_ = "$2";
 var count_201 = 0;    //  Счетчик удаленных тегов.
 var newCite;                 //  Раздел цитаты.
 var if_202 = true;    // условие для добавления цитаты.
 var count_202 = 0;   //  Счетчик добавленных цитат.

         //  Остальные переменные
 var s="";  // Содержание абзаца
 var sct="";  // Копия абзаца без некоторых тегов
 var sosedi;  //  Соседние узлы
 var stanza_1;  //  Оригинальная строфа
 var stanza_2;  //  Копия строфы
 var ptrUp;  //  Узлы, которые выше параграфа


 function HandleP(ptr) {

   s=ptr.innerHTML;


         ///  БОЛЬШОЕ УДАЛЕНИЕ ДУБЛЕЙ ТЕГОВ ВНУТРИ ПАРАГРАФА

 if_201 = (ptr.children.length !=0  &&  s.search(re201test)!=-1);

 if (if_201) {          //  Если в параграфе есть большая вероятность повторных вложений...
         ptr.innerHTML = s;   //  Перезапись параграфа (без неё может некорректно работать отмена действий этого скрипта).
         subPtr=ptr;                             //  Начальное значение переменной "subPtr"
         mNodeName = [];                       //  Очистка массивов с данными об элементах
         mClassName = [];
         mElement = [];
         }

 //  Поиск и удаление дублей
 aaa:
 while (if_201)  {             //  Путешествие по структуре, пока не будет специального объявления о завершении цикла

         addM = false;

         if (subPtr.firstChild!=null  &&  subPtr.children.length !=0)  {   //  Если есть куда углубляться...
                 mNodeName.push(subPtr.nodeName);                   //  то записываем данные элемента "subPtr" в три массива,
                 mClassName.push(subPtr.className);
                 mElement.push(subPtr);
                 addM = true;                                       //  отмечаем это на индикаторе
                 newSubPtr=subPtr.firstChild;     //  и пробуем спуститься на один уровень.
                 }

             else {                                                                   //  Если углубляться нельзя...
                     while (!subPtr.nextSibling)  {            //  В частности, если нет даже прохода на соседний элемент...
                             subPtr=subPtr.parentNode;     //  тогда постепенно поднимаемся, пока не появится этот проход
                             mNodeName.pop();                    //  и в процессе подъема удаляем последние записи.
                             mClassName.pop();
                             mElement.pop();
                             if (subPtr==ptr) break aaa;     // А если поднявшись, вдруг оказываемся в "ptr" — выходим из основного цикла.
                             }
                     newSubPtr=subPtr.nextSibling;    //  Затем совершаем пробный переход на соседний элемент.
                     }

         if (newSubPtr.nodeType !=1) {   //   Если элемент является текстовым или специфическим элементом...
                 subPtr=newSubPtr;         //  то переходим на новый элемент
                 continue;                        //  и переходим к началу основного цикла.
                 }

         for  (j=0; j<mNodeName.length; j++)                               //  Цикл проверки совпадения нового элемента с верхними элементами.
                 if (mNodeName[j] == newSubPtr.nodeName  &&  mClassName[j] == newSubPtr.className)   //   Если тег нового элемента совпадает с тегом верхнего элемента...
                         if (mNodeName[j] != "A"  &&  (mNodeName[j] != "SPAN"  ||  mClassName[j] != "image"))   //  и если это не тег ссылки или иллюстрации...
                                 break;                 //  то прерываем цикл проверки.

         if (j == mNodeName.length) {    //  Если все циклы проверки не принесли результата...
                 subPtr=newSubPtr;       //  то переходим на новый элемент
                 continue;                   //  и переходим к началу основного цикла.
                 }

         //  Автоматическое удаление вложенного тега

         if (mElement[j].innerText.replace(re201, re201_) == newSubPtr.innerText.replace(re201, re201_)) {   //  Если текст в обоих тегах одинаковый...
                 newSubPtr.removeNode(false);      //  удаляем вложенный тег
                 count_201++;                                  //  и отмечаем удаление в счетчике.
                 if (addM) {                                  //  А если добавлялись записи...
                         mNodeName.pop();       //  то удаляем их.
                         mClassName.pop();
                         mElement.pop();
                         }
                 continue;                   //  Затем переходим к началу основного цикла.
                 }

         if (!fbwBodyMargin) {   //  Если поля для "fbw_body" не добавлялись...
                 fbwBody.style.paddingTop = window.external.GetViewHeight() + "px";        //  то добавляем внутренние поля.
                 fbwBody.style.paddingBottom = window.external.GetViewHeight() + "px";
                 fbwBodyMargin=true;
                 }

         //  Полуавтоматическое удаление

         //  Коррекция названия тега
         var nameTeg = mNodeName[j];
         switch (mNodeName[j]) {
                 case "EM":  nameTeg = "emphasis";  break;
                 case "STRONG":  nameTeg = "strong";  break;
                 case "SUP":  nameTeg = "sup";  break;
                 case "SUB":  nameTeg = "sub";  break;
                 case "STRIKE":  nameTeg = "strikethrough";  break;
                 case "SPAN":  if (mClassName[j] == "code")  nameTeg = "code";  else  nameTeg = "style: "+mClassName[j];  break;
                 }

         //  добавление стилей
         var  StyleFont_01 = document.createElement("SPAN");   //  Создаем раздел стилей для внешнего тега.
         mElement[j].insertAdjacentElement("beforeBegin", StyleFont_01);       //   Добавляем раздел стилей в текст.
         StyleFont_01.insertAdjacentElement("afterBegin", mElement[j]);       //   Вставляем "mElement[j]" в этот раздел.
         StyleFont_01.style.backgroundColor="#C9B766";   //  Добавляем фон,
         StyleFont_01.style.color="black";                               //  цвет шрифта
         StyleFont_01.style.paddingLeft="0.2em";         //  и внутренние поля.
         StyleFont_01.style.paddingRight="0.2em";

         var  StyleFont_02 = document.createElement("SPAN");   //  Создаем раздел стилей для внутреннего тега.
         newSubPtr.insertAdjacentElement("beforeBegin", StyleFont_02);       //   Добавляем раздел стилей в текст.
         StyleFont_02.insertAdjacentElement("afterBegin", newSubPtr);       //   Вставляем "newSubPtr" в этот раздел.
         StyleFont_02.style.backgroundColor="#821A1A";   //  Добавляем фон,
         StyleFont_02.style.color="#EEF47C";                       //  цвет шрифта
         StyleFont_02.style.paddingLeft="0.1em";         //  и внутренние поля.
         StyleFont_02.style.paddingRight="0.1em";

         //  переход на "ошибочный" тег, и диалог
         GoTo_0(newSubPtr);
         T_pause -= new Date().getTime();                  // определение продолжительности паузы в вычислениях
         window.external.InputBox(" ДА:	Удаление общего тега <"+nameTeg+"> (желтый фон)\n НЕТ:	Удаление вложенного тега <"+nameTeg+"> (красный фон)", "Тег <"+nameTeg+"> внутри тега <"+nameTeg+">", "");       //  диалоговое окно, запись введенного текста
         T_pause += new Date().getTime();                  // определение продолжительности паузы в вычислениях
         otvet_201 = window.external.GetModalResult();   //  Получение кода нажатой кнопки.

         //  удаление стилей
         StyleFont_01.removeNode(false);
         StyleFont_02.removeNode(false);

         //  Обработка ответа "Да"
         if (otvet_201 == 6)  {
                 if_202 = (mElement[j].innerText.replace(re201, re201_) == ptr.innerText.replace(re201, re201_)  &&  ptr.parentNode.className != "cite");  //  возможность добавления цитаты
                 mElement[j].removeNode(false);          //  удаляем общий тег
                 mNodeName.splice(j, 1);                           //   удаляем записи об этом теге
                 mClassName.splice(j, 1);
                 mElement.splice(j, 1);
                 count_201++;              //  отмечаем удаление в счетчике

                 if (if_202) {                                    // Если возможно добавление цитаты

                         StyleDiv = document.createElement("DIV");   //  Создаем раздел стилей.
                         ptr.insertAdjacentElement("beforeBegin", StyleDiv);       //   Добавляем раздел стилей в текст.
                         StyleDiv.insertAdjacentElement("afterBegin", ptr);       //   Вставляем строку в этот раздел.
                         StyleDiv.style.backgroundColor="#C9B766";        //  Добавляем фон,
                         StyleDiv.style.color="black";                                          //  цвет шрифта
                         StyleDiv.style.border="none";                                      //  и убираем рамку.

                         T_pause -= new Date().getTime();                  // Определение продолжительности паузы в вычислениях.
                         window.external.InputBox(" Добавить для этого параграфа формат \"Цитата\"?", "Тег <"+nameTeg+"> внутри тега <"+nameTeg+"> (продолжение)", "");  //  Диалог.
                         T_pause += new Date().getTime();                  // Определение продолжительности паузы в вычислениях.

                         StyleDiv.removeNode(false);                            //  Удаляем раздел стилей.

                         if (window.external.GetModalResult() == 6) {          // Если второй ответ "Да"
                                 newCite = document.createElement("DIV");      // создаем раздел цитаты
                                 newCite.className = "cite";
                                 ptr.insertAdjacentElement("beforeBegin", newCite);  // вставляем этот раздел перед параграфом
                                 newCite.insertAdjacentElement("afterBegin", ptr);    //  переносим параграф внутрь цитаты
                                 count_202++;                    // отмечаем это действие в счетчике
                                 if (newCite.previousSibling !=null  &&  newCite.previousSibling.innerHTML ==""
                                     &&  (newCite.previousSibling.previousSibling ==null  ||  newCite.previousSibling.previousSibling.className !="image"))
                                         { newCite.previousSibling.removeNode(true); count_272++ }   //  если предыдущая строка пустая и ее можно удалить -- удаляем
                                 }
                         }
                 subPtr=newSubPtr;     //  Переходим на новый элемент.
                 continue;                   //  Переходим к началу основного цикла.
                 }

         //  Обработка ответа "Нет"
         if (otvet_201 == 7)  {
                 newSubPtr.removeNode(false);   //  Удаляем вложенный тег.
                 count_201++;                               //  Отмечаем удаление в счетчике.
                 if (addM) {                                  //  Если добавлялись записи...
                         mNodeName.pop();       //   удаляем их.
                         mClassName.pop();
                         mElement.pop();
                         }
                 continue;                   //  Переходим к началу основного цикла.
                 }

         //  Остался только один случай (обработка ответа "Отмена")
         subPtr=newSubPtr;

         }   //  конец основного цикла

 if (if_201)
         s=ptr.innerHTML;   //  Перезапись переменной с содержимым строки.

//  ------------ конец для   "Большое удаление дублей..." ------------


         // Коррекция неразрывных пробелов
 if (s.search(re211)!=-1)  {
         if (nbspEntity!="&nbsp;")  count_211+=s.match(re211).length;   //  подсчет невозвратных замен для ошибочного написания н/р пробела (&nbsp;)
         s=s.replace(re211, re211_);         //  замена кода н/р пробела (&nbsp;) на обычный символ (в т.ч. временная замена прозрачного н/р пробела)
         }

         // Чистка пустых строк от пробелов и внутренних тегов
 if (s.search(re212)!=-1  &&  s.search(re212ex)==-1)  { s=s.replace(re212, re212_); count_212++ }

         // Снятие форматирования "подзаголовок" с пустой строки
 if (s==""  &&  ptr.className=="subtitle")  {
         ptr.insertAdjacentElement("afterEnd", document.createElement("P"));  // добавление пустой строки
         ptr=ptr.nextSibling;
         window.external.inflateBlock(ptr)=true;               // легализация пустой строки
         ptr.previousSibling.removeNode(true);                // удаление пустого подзаголовка
         count_213++ }
         //  * В коде этой операции нет ничего лишнего. Если записать проще (как для №214), то в IE11 может произойти серьезная ошибка


         // Снятие форматирования "автор текста" с пустой строки (если предыдущая строка без этого формата)
 if (s==""  &&  ptr.className=="text-author"  &&  (ptr.previousSibling==null  ||  (ptr.previousSibling!=null  &&  ptr.previousSibling.className!="text-author")))
         { ptr.removeAttribute("className"); count_214++ }


         // Добавление формата "подзаголовок" для строк из символов
 if (ptr.parentNode.className.search(re221)!=-1)  {                     //  Если строка в разделе, где может быть подзаголовок, то
         if (s.search(re222)!=-1)  { sct=s.replace(re222, "") }  else sct=s;                     //  сохраняем копию этой строки, но без пяти внутренних форматов
         if (sct.search(re223)!=-1)  {                     //  Если копия строки соответствует требованиям для подзаголовка, то
                 sct=s;                                              //  сохраняем уже полноценную копию строки, в которой
                 if (sct.search(re224)!=-1)  { sct=sct.replace(re224, "") }                     //  если возможно, удаляем жирность и курсив
                 if (sct.search(re225)!=-1)  { sct=sct.replace(re225, re225_) }                     //  и, если возможно, заменяем символ из трех звездочек на корректную строку
                 if (sct.search(re226s)!=-1)  { sct=sct.replace(re226, re226_) }                     //  и, если возможно, добавляем необходимые пробелы
                 if (sct.search("х")!=-1)  { sct=sct.replace(/х/g, "x") }                     //  и, если возможно, заменяем русские "х" на латинские
                 if (ptr.className !="subtitle")  {                     //  А если строка не имела формат подзаголовка, то
                         ptr.className="subtitle";                     //  добавляем его
                         count_227++;                     //  и отмечаем это действие в соответствующем счетчике
                         if (ptr.previousSibling !=null  &&  ptr.previousSibling.innerHTML ==""                     //  при этом, если перед новым подзаголовком есть пустая строка
                             &&  (ptr.previousSibling.previousSibling ==null  ||  ptr.previousSibling.previousSibling.className !="image"))  // и ее можно удалить, то
                                 { ptr.previousSibling.removeNode(true); count_272++ }                     //  удаляем ее, и отмечаем это действие в соответствующем счетчике
                         }
                 if (s !=sct)  { s=sct; count_228++ }                     //  Если копия изменялась, то сохраняем эти изменения в "s", и отмечаем это в соответствующем счетчике
                 }
         }

         //  Внутренняя чистка графики в пустом параграфе  (от пробелов и внутренних тегов)
 if (s.search(re231s)!=-1  &&  s.match(re231s).length==1  &&  s.search(re231)!=-1) {
         s_=s.replace(re231, re231_);
         q_231 = true;
         if (s!=s_)
                 { s=s_; count_231++ }    }
     else  q_231 = false;

         //  возвращение кода н/р пробела
 if (nbspEntity=="&nbsp;"  &&  s.search(reNBSPon)!=-1)  s=s.replace(reNBSPon, reNBSPon_);


 //  сохранение абзаца в оригинале только в том случае, если он действительно изменен
 if (ptr.innerHTML != s)   ptr.innerHTML=s;

         //  * Далее преобразования выполняются без участия переменной "s"


         // Снятие внешнего форматирования с графики в пустом параграфе
 if (q_231) {
         while (ptr.parentNode !=null  &&  ptr.parentNode.children.length==1
             &&  (ptr.parentNode.className=="cite"  ||  ptr.parentNode.className=="poem"
                 ||  ptr.parentNode.className=="stanza"  &&  ptr.parentNode.parentNode !=null  &&  ptr.parentNode.parentNode.children.length==1  &&  ptr.parentNode.parentNode.className=="poem"))
                             { ptr.parentNode.removeNode(false); count_232++ }
       }

         // Добавление пустой строки между "карманным" блоком  [заголовок или эпиграф или аннотация]    и    концом секции
 if (ptr.innerHTML !="")  {
         ptrUp = ptr;
         while (ptrUp.nextSibling ==null  &&  ptrUp.parentNode !=null  &&  ptrUp.parentNode.className !="section")
                 { ptrUp=ptrUp.parentNode }
         if (ptrUp.nextSibling ==null  &&  ptrUp.parentNode !=null  &&  ptrUp.parentNode.className =="section")
                 if (ptrUp.className.search(re241) !=-1) {
                         ptrUp.insertAdjacentElement("afterEnd", document.createElement("P"));
                         window.external.inflateBlock(ptrUp.nextSibling)=true;
                         count_241++ }
         }


         //  ОПЕРАЦИИ с очищенными пустыми строками

         // начало фильтра пустых строк
 if (ptr.innerHTML ==""  &&  ptr.className !="th"  &&  ptr.className !="td")  //  Пустая строка, которая расположена где угодно, но только не в таблице
         {

               // Удаление первой пустой строки в ряде из двух пустых строк (одного уровня, и под одним общим форматом)
         if (ptr.previousSibling !=null  &&  ptr.previousSibling.innerHTML =="")
                 { ptr.previousSibling.removeNode(true); count_251++ }

               // Удаление внешних тегов для единственной пустой строки
         while (ptr.parentNode !=null                // Пока у пустой строки есть родительский элемент...
             &&  ptr.parentNode.children.length==1                //  ...причем, пустая строка должна быть единственной в этом разделе...
             &&  (ptr.parentNode.className.search(re252)!=-1                //  ...и это может быть эпиграф, стихи, цитата...
                 ||  ptr.parentNode.className =="annotation"   &&  ptr.parentNode.parentNode !=null   &&  ptr.parentNode.parentNode.getAttribute("id") !="fbw_body"))     //  ...или аннотация, которая не в "fbw_body".
                         { ptr.parentNode.removeNode(false); count_252++ }                //  ...всегда удаляем внешнее форматирование

         //  Удаление ошибочных пустых строк в "body" и "fbw_body" (вне секции)
         if (ptr.parentNode!=null  &&  (ptr.parentNode.className=="body"  ||  ptr.parentNode.getAttribute("id")=="fbw_body"))
                 { ptr.removeNode(true); count_253++;  return }


         if (ptr.parentNode !=null  &&  ptr.parentNode.children.length ==1) {   //  Если пустая строка - единственный элемент раздела

                 //  Удаление пустых "body"
                 ptrUp=ptr;
                 while (ptrUp.parentNode !=null  &&  ptrUp.parentNode.children.length ==1  &&  ptrUp.className !="body")
                         { ptrUp=ptrUp.parentNode }
                 if (ptrUp.className =="body"
                     &&  (ptrUp.previousSibling !=null  &&  ptrUp.previousSibling.className =="body"
                     ||  ptrUp.nextSibling !=null  &&  ptrUp.nextSibling.className =="body"))
                             { ptrUp.removeNode(true); count_262++; return }

                 //  Удаление пустых секций
                 ptrUp=ptr;
                 while (ptrUp.parentNode !=null  &&  ptrUp.parentNode.children.length ==1  &&  ptrUp.parentNode.className =="section")
                         { ptrUp=ptrUp.parentNode }       //   Пока сверху есть секция, обрамляющая единственный раздел, поднимаемся на один уровень вверх.
                 if (ptrUp.className =="section"    //   Если верхний узел - секция,
                     &&  (ptrUp.previousSibling !=null  &&  ptrUp.previousSibling.className =="section"    //  и при этом, либо позади неё есть еще одна секция,
                         ||  ptrUp.nextSibling !=null  &&  ptrUp.nextSibling.className =="section"  &&  ptrUp.previousSibling ==null   //  либо впереди есть еще одна секция, а позади ничего нет,
                         ||  ptrUp.parentNode !=null  &&  ptrUp.parentNode.getAttribute("id")=="fbw_body"))   //  либо она, вообще, оказалась в запретном месте для секций,
                                 { ptrUp.removeNode(true); count_263++; return }   //  тогда удаляем всю секцию со всем ее содержимым

                 }

         //  Удаление пустых строк на окраине разделов
         //  Исключение:  пустая строка после картинки, заголовка, эпиграфа или аннотации
         if (ptr.previousSibling ==null  &&  ptr.nextSibling !=null
             ||  ptr.nextSibling ==null  &&  ptr.previousSibling !=null  &&  ptr.previousSibling.className.search(re271) ==-1)
                     { ptr.removeNode(true); count_271++; return }

         //  Удаление пустых строк рядом с разделами и подзаголовками
         //  Исключение:  пустая строка рядом с картинкой
         if (ptr.previousSibling !=null  &&  ptr.nextSibling !=null  &&  ptr.parentNode !=null
             &&  (ptr.previousSibling.className.search(re272) !=-1  &&  ptr.nextSibling.className !="image"
                 ||  ptr.nextSibling.className.search(re272) !=-1  &&  ptr.previousSibling.className !="image"))
                         { ptr.removeNode(true); count_272++; return }

         //  Замена пустых строк в стихах на разрыв строф
         if (ptr.parentNode!=null  &&  ptr.parentNode.className =="stanza"    //  Если есть родительский узел над пустой строкой, и этот узел - строфа...
             &&  ptr.previousSibling !=null  &&  ptr.previousSibling.nodeName =="P"    //  ...и предыдущая строка - параграф...
             &&  ptr.nextSibling !=null  &&  ptr.nextSibling.nodeName =="P")    //  ...и следующая строка - параграф.
                 {
                 stanza_1=ptr.parentNode;    //  Тогда, копируем оболочку строфы...
                 stanza_2=stanza_1.cloneNode(false);    //  Тогда, копируем оболочку строфы...
                 stanza_1.insertAdjacentElement("beforeBegin",stanza_2);    //  ...и вставляем её перед оригинальной строфой.
                 stanza_1.removeAttribute("id");    //  В оригинальной строфе удаляем "id", чтобы не получилось два одинаковых индекса в тексте.
                 while (stanza_1.firstChild.innerHTML != "")    //  Затем, пока не встретим пустую строку в оригинальной строфе...
                         stanza_2.insertAdjacentElement("beforeEnd", stanza_1.firstChild)    //  ...и последовательно переносим все строки в новую оболочку строфы.
                 stanza_1.firstChild.removeNode(true);    //  В конце удаляем пустую строку.
                 count_281++; return;    //  Увеличиваем счетчик изменений на единицу, и выходим из функции "HandleP(ptr)"
                 }

         }         // конец фильтра пустых строк


         //  Поиск графики в тексте
 if (Obrabotka_Img_v_Texte_on_off  !=0  &&  ptr.innerHTML.search(re001)!=-1  &&  (ptr.parentNode.className =="section"  ||  ptr.parentNode.className =="body"))
         { m_001[count_001]=ptr;  count_001++ }

         //  Поиск пустых строк между строк заголовка + сохранение следующей строки в массиве
 if (Obrabotka_Entity_ttl !=0  &&  ptr.parentNode.className =="title"&&  ptr.previousSibling !=null  &&  ptr.previousSibling.innerHTML =="")
         { m_002[count_002]=ptr;  count_002++ }

         //  Поиск ссылок
 if (ptr.innerHTML.search(/<\/A>/) != -1)
         m_003.push(ptr);


}   //  конец функции "HandleP(ptr)"

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОБРАБОТКА ТЕКСТА _2_  :  Параграфы <P>  :  операции  № 2хх
                 //      (применение функции "HandleP")

 ptr=fbwBody;                                                           //  Начальное значение переменной "ptr"
 var SaveNext=ptr;                                           //  Элемент, который будет следующим после "ptr"
 ProcessingEnding=false;                              //  Флаг завершения обработки

 while (!ProcessingEnding) {                       //  Если конца текста не видно — продолжаем путешествие.
         if (SaveNext.firstChild!=null  &&  SaveNext.nodeName!="P")    //  Если есть куда углубляться, и это всё ещё не параграф...
                 { SaveNext=SaveNext.firstChild }                                                       //  ...тогда спускаемся на один уровень.
             else {                                                                                                             //  Если углубляться нельзя...
                     while (SaveNext.nextSibling==null)  {                                          //  ...и если нет прохода на соседний элемент...
                             SaveNext=SaveNext.parentNode;                                          //  ...тогда поднимаемся, пока не появится этот проход.
                             if (SaveNext==fbwBody) {ProcessingEnding=true }       // А если поднявшись, оказываемся в "fbw_body" — объявляем о завершении обработки текста.
                             }
                 SaveNext=SaveNext.nextSibling;                      //  Затем переходим на соседний элемент.
                 }
         if (ptr.nodeName=="P")                 //  Если встретился параграф...
                 HandleP(ptr);                                   //  ...обрабатываем его функцией "HandleP".
         ptr=SaveNext;                                   //  Меняем отработанный элемент на следующий найденный элемент
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОБРАБОТКА ТЕКСТА _3_  :  Сохраненные разделы "P"  :  операции  № 3хх  ;  вопросы  № 001, 002

         // Выведение картинки из текста

 var izobrazhenij_kotorye = [ " изображение, которое", " изображения, которые", " изображений, которые" ];
 var kartinok = [ "картинки", "картинок", "картинок" ];

 var otvet_001 = false;


 if (count_001 != 0  &&  Obrabotka_Img_v_Texte_on_off == 2)  {
         pad(count_001);
         T_pause-=new Date().getTime();
         otvet_001=AskYesNo("                     ◊  КАРТИНКИ в ТЕКСТЕ  ◊                                      \n\n"+
                                             "Найдено "+count_001+izobrazhenij_kotorye[ok]+" можно вывести\n"+
                                             "                        из пустого параграфа\n\n"+
                                             "                             ПРЕОБРАЗОВАТЬ\n"+
                                             "                       оформление "+kartinok[ok]+"?");
         T_pause+=new Date().getTime();
         }


 var re301 = new RegExp("<P( [^>]{1,}){0,1}><SPAN( [^>]{0,}?class=image[^>]{0,}><IMG [^>]{1,}>)</SPAN></P>","g");
 var re301_ = "<DIV$2</DIV>";
 var count_301 = 0;

 if (otvet_001  ||  Obrabotka_Img_v_Texte_on_off ==1)
         for (n=0; n<count_001; n++)
                 { m_001[n].outerHTML=m_001[n].outerHTML.replace(re301, re301_);  count_301++ }


         //  Удаление пустой строки посреди заголовка

 var otvet2=0;
 var msg1="";
 var msg2="";
 var msgTitle="";
 var textOtvet="";

 var count_311 = 0;

         //   Контролируемое удаление пустых строк посреди заголовка
 if (Obrabotka_Entity_ttl ==2) {
         if (!fbwBodyMargin  &&  count_002 != 0) {   //  Если поля для "fbw_body" не добавлялись, и есть пустые строки посреди заголовка...
                 fbwBody.style.paddingTop = window.external.GetViewHeight() + "px";        //  то добавляем внутренние поля для "fbw_body".
                 fbwBody.style.paddingBottom = window.external.GetViewHeight() + "px";
                 fbwBodyMargin=true;
                 }
         for (n=0; n<count_002; n++) {
                 msg1 = " УДАЛИТЬ пустую строку посреди заголовка?";
                 msgTitle="• 311. Пустая строка внутри заголовка  •  "+(n+1)+" из "+count_002+" • ";

                 GoTo_0(m_002[n].previousSibling);   //  Прокрутка на пустую строку.
                 updateImg(m_002[n]);           //  Обновление ближайших иллюстраций.

                 StyleDiv = document.createElement("DIV");            //  Создаем раздел стилей.
                 m_002[n].previousSibling.insertAdjacentElement("beforeBegin", StyleDiv);    //   Добавляем раздел стилей в текст.
                 StyleDiv.insertAdjacentElement("afterBegin", m_002[n].previousSibling);   //   Вставляем строку в этот раздел.
                 StyleDiv.style.backgroundColor="#C9B766";        //  Добавляем фон,
                 StyleDiv.style.border="none";                        //  и убираем рамку.

                 T_pause -= new Date().getTime();                  // определение продолжительности паузы в вычислениях
                 window.external.InputBox(msg1, msgTitle, "");       //  диалоговое окно
                 T_pause += new Date().getTime();                  // определение продолжительности паузы в вычислениях
                 otvet2 = window.external.GetModalResult();    //  Получение кода нажатой кнопки.

                 StyleDiv.removeNode(false);                            //  Удаляем раздел стилей.

                 if (otvet2 ==6) {
                         m_002[n].previousSibling.removeNode(true);
                         count_311++ }
                 if (otvet2 ==2) break;
                 }
         }

         //   Удаление всех пустых строк посреди заголовка
 if (Obrabotka_Entity_ttl ==1) {
         for (n=0; n<count_002; n++) {
                 m_002[n].previousSibling.removeNode(true);
                 count_311++ }
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// Удаление лишнего форматирования для примечаний и комментариев

 var mA=[];          //  массив с узлами "A"
 var NC;                //  Одно из примечаний или комментариев
 var mSUP=[];   //  массив с узлами "SUP"
 var mSPAN=[];   //  массив с узлами "SPAN"
 var elCopy;       //  Копия элемента (внутренний формат)
 var re320 = new RegExp("^\\\{\\\d{1,4}\\\}$","");    //  Признак комментария.
 var re321 = new RegExp("</?(STRONG|EM|SUP|SUB|STRIKE)>","g");   //  Для удаления внутреннего формата в примечаниях.
 var re322 = new RegExp("</?(STRONG|EM|SUB|STRIKE)>","g");           //  Для удаления внутреннего формата в комментариях.
 var re323 = new RegExp("(<[^/>][^>]{0,}>)((\\\s|"+nbspEntity+"){1,})","g");   //  Для переноса пробелов за окраину элементов.
 var re323_ = "$2$1";
 var change_n = false;          //  Индикатор изменения примечания
 var change_c = false;          //  Индикатор изменения комментария
 var count_320 = 0;          //  Счетчик удалений форматирования примечаний
 var count_321 = 0;          //  Счетчик удалений форматирования комментариев
 var count_322 = 0;          //  Счетчик добавлений верхнего индекса для комментариев

 for (k=m_003.length-1; k>=0; k--) {                     //  Цикл для параграфов, в которых есть ссылки
         mA=m_003[k].getElementsByTagName("A");   //  Получение массива со всеми ссылками из одного параграфа.
         for (j=mA.length-1; j>=0; j--) {                 //  Цикл для ссылок.
                 NC = mA[j];                             //  Сохраняем очередную ссылку в переменной.
                 if (NC.className == "note"  ||  NC.innerText.search(re320) != -1) {
                 //  Если ссылка является примечанием или комментарием, то...
                         if (NC.className == "note") {                                 //  Если это примечание...
                                 if (NC.innerHTML.search(re321) != -1) {                  //  то проверяем в ней наличие простых внутренних тегов, и если они есть...
                                         NC.innerHTML = NC.innerHTML.replace(re321, "");   //  то удаляем их
                                         change_n = true;              //  и отмечаем изменение.
                                         }
                                 }
                             else {                                        //  Если это комментарий, то...
                                 if (NC.innerHTML.search(re322) != -1) {                  //  Проверяем в нём наличие простых внутренних тегов, и если они есть...
                                         NC.innerHTML = NC.innerHTML.replace(re322, "");   //  то удаляем их
                                         change_c = true;              //  и отмечаем изменение.
                                         }
                                 mSUP=NC.getElementsByTagName("SUP");    //  находим все теги с верхним индексом.
                                 if (mSUP.length != 0) {                 //  Если они есть...
                                         for (jj=mSUP.length-1; jj>=1; jj--) {
                                                 mSUP[jj].removeNode(false);     //  то удаляем их все, кроме самого первого индекса
                                                 change_c = true;              //  и отмечаем изменение.
                                                 }
                                         if (mSUP[0].innerText != NC.innerText) {     //  Если первый формат верхнего индекса не охватывает весь текст комментария...
                                                 mSUP[0].removeNode(false);    //  то удаляем и его,
                                                 change_c = true;                               //  отмечаем изменение,
                                                 NC.innerHTML = "<SUP>" + NC.innerHTML + "</SUP>";    //  затем добавляем правильное выделение
                                                 count_322++;                            //  и увеличиваем счетчик добавлений верхнего индекса.
                                                 }
                                         }
                                     else {        //  Если же в комментарии нет тегов верхнего индекса...
                                         NC.innerHTML = "<SUP>" + NC.innerHTML + "</SUP>";    //  то добавляем правильное выделение
                                         count_322++;                            //  и увеличиваем счетчик добавлений верхнего индекса.
                                         }
                                 }
                         if (NC.innerHTML.search("</SPAN>") != -1) {         //  Если в ссылке есть спец. формат, то...
                                 mSPAN=NC.getElementsByTagName("SPAN");     //  Находим все эти форматы
                                 for (jj=mSPAN.length-1; jj>=0; jj--) {     //  Запускаем для них цикл.
                                         if (mSUP.className != "image") {        //  Если это не внутристрочная картинка (а формат код или стиль)...
                                                 mSPAN[jj].removeNode(false);    //  то удаляем этот формат,
                                                 if (NC.className == "note")
                                                         change_n = true;       //  и отмечаем изменение примечания
                                                     else  change_c = true;    //  либо изменение комментария.
                                                 }
                                         }
                                 }
                         while (NC.parentNode.nodeName.search(/^(P|DIV)$/) == -1) {    //  Если над примечанием/комментарием есть внутренний формат, то...
                                 if (NC.className == "note")        //  Если это примечание...
                                         change_n = true;          //  то заранее отмечаем изменение примечания,
                                     else  change_c = true;    //  в противном случае - отмечаем изменение комментария.
                                 if (NC.previousSibling == null  &&  NC.nextSibling == null) {    //  Если во внутреннем формате только элемент ссылки...
                                         NC.parentNode.removeNode(false);         //  то удаляем внутренний формат
                                         continue;                 //  и возвращаемся к началу цикла.
                                         }
                                 if (NC.previousSibling == null) {       //  Если элемент ссылки располагается в начале внутреннего формата...
                                         NC.parentNode.insertAdjacentElement("beforeBegin", NC);    //  то ставим элемент ссылки перед этим внутренним форматом
                                         continue;                 //  и возвращаемся к началу цикла.
                                         }
                                 if (NC.nextSibling == null) {       //  Если элемент ссылки располагается в конце внутреннего формата...
                                         NC.parentNode.insertAdjacentElement("afterEnd", NC);    //  то ставим элемент ссылки после этого внутреннего формата
                                         continue;                 //  и возвращаемся к началу цикла.
                                         }
                                 //  Остался только случай, когда элемент ссылки располагается по середине внутреннего формата.
                                 elCopy = NC.parentNode.cloneNode(false);         //  Создаём копию оболочки внутреннего формата.
                                 NC.parentNode.insertAdjacentElement("afterEnd", elCopy);   //  Вставляем копию после оригинального внутреннего формата.
                                 s="<SPAN>_</SPAN>";               //  Добавляем переменную для текста внутри копии, и заполняем его временым элементом.
                                 //  Временный элемент необходим для сохранения начальных пробелов будущего текста, иначе они будут удалены при перемещении внутрь копии.
                                 while (NC.nextSibling != null) {         //  Создаем цикл, который будет выполняться, пока после элемента ссылки есть какой-либо элемент.
                                         if (NC.nextSibling.nodeType==3)    //  Если после элемента ссылки идет текстовый элемент...
                                                 s += NC.nextSibling.nodeValue;   //  то добавляем текст этого элемента в строку с помощью команды "nodeValue".
                                             else                 //  Если после элемента ссылки идет любой другой элемент...
                                                 s += NC.nextSibling.outerHTML;  //  то добавляем текстовый вид этого элемента в строку с помощью команды "outerHTML".
                                         NC.nextSibling.removeNode(true);   // после копирования, удаляем ненужный элемент.
                                         }
                                 elCopy.innerHTML=s;       //  Вставляем полученный текст в копию внутреннего формата.
                                 NC.parentNode.insertAdjacentElement("afterEnd", NC);    //  Ставим элемент ссылки после оригинального внутреннего формата.
                                 }
                         if (change_n) {           //  Если были изменения примечания...
                                 count_320++;     //  то увеличиваем счетчик удаления форматирования примечаний
                                 change_n = false;   //  и гасим индикатор изменения.
                                 }
                         if (change_c) {           //  Если были изменения комментария...
                                 count_321++;     //  то увеличиваем счетчик удаления форматирования комментариев
                                 change_c = false;   //  и гасим индикатор изменения.
                                 }
                         }
                 }
         if (m_003[k].innerHTML.search("<SPAN>_</SPAN>") != -1) {             //  Если в строке со ссылками находим временые элементы...
                 m_003[k].innerHTML = m_003[k].innerHTML.replace(/<SPAN>_<\/SPAN>/g, "");    //  то удаляем их,
                 while (m_003[k].innerHTML.search(re323) != -1)             //  и если в строке со ссылками есть пробелы на окраине элементов...
                         m_003[k].innerHTML = m_003[k].innerHTML.replace(re323, re323_);    //  то переносим их за окраину.
                 }
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОБРАБОТКА ТЕКСТА _4_  :  Разделы "DIV"  :  операции  № 4хх  ;  Создание массивов с разделами "image", "section" и "body"
                 //  * В обратном порядке

 mDiv=fbwBody.getElementsByTagName("DIV");

 var count_401 = 0;
 var count_402 = 0;

 var mImg=[];  //  массив с узлами "image"
 var mSection=[];  //  массив с узлами "section"
 var mBody=[];  //  массив с узлами "body"


 for (j=mDiv.length-1; j>=0; j--) {

         div = mDiv[j];

         // Удаление пустых узлов "DIV"
         if (div.innerHTML =="") {
                 div.removeNode(true);
                 count_401++; continue }

         // Чистка двойных разделов "DIV"
         //  * Например, эпиграф в эпиграфе, или секция в секции (<section><section>.........</section></section>)
         if (div.children.length ==1  &&  div.className ==div.firstChild.className) {
                 div.removeNode(false);
                 count_402++; continue }


         // Создание массива с узлами "image"
         if (div.className =="image")
                 mImg.push(div);

         // Создание массива с узлами "section"
         if (div.className =="section")
                 mSection.push(div);

         // Создание массива с узлами "body"  (без "body" примечаний, и комментариев)
         if (div.className =="body"  &&  div.getAttribute("fbname") !="notes"  &&  div.getAttribute("fbname") !="comments"  &&  div.parentNode ==fbwBody)
                 mBody.push(div);

         }

 var count_Img = mImg.length;
 var count_Section = mSection.length;
 var count_Body = mBody.length;

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ВОПРОС  :  Разделы "body"  :  вопрос  № 011

 var otvet_011 = false;
  var razdel = [ " раздел", " раздела", " разделов" ];


 if (count_Body >1)  {
         pad(count_Body);
         T_pause-=new Date().getTime();
         otvet_011=AskYesNo("               ◊  СЛИШКОМ МНОГО \"body\"  ◊\n\n"+
                                                      "                   Найдены "+count_Body+razdel[ok]+" \"body\"\n\n"+
                                                      "                ОБЪЕДИНИТЬ в один раздел?                                  ");
         T_pause+=new Date().getTime();
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОБРАБОТКА ТЕКСТА _5_  :  Разделы "body"   :  операции  № 501-503

 var Body;                  //  Один из узлов "body"
 var div2;                  //  Дополнительный узел

 var count_501 = 0;
 var count_502 = 0;
 var count_503 = 0;


         //  Объединение  "body"

 var q_503 = false;
 var newSection;
 var newTitle;

 if (otvet_011) {

         //  Копирование оболочки первого "body" и его вставка перед оригиналом
         var newBody = mBody[count_Body-1].cloneNode(false);
         newBody.removeAttribute("fbname");
         mBody[count_Body-1].insertAdjacentElement("beforeBegin",newBody);


         for (j=mBody.length-1; j>=0; j--) {   //  Цикл выдает прямой порядок разделов в структуре книги.
                 Body=mBody[j];

                 // Вставка новой секции в конце нового "body"
                 newSection = document.createElement("DIV");
                 newSection.className = "section";
                 newBody.insertAdjacentElement("beforeEnd",newSection);

                 // Удаление лишнего обрамления секцией
                 if (Body.children.length ==1  &&  Body.firstChild.className =="section")
                         { Body.firstChild.removeNode(false) }

                 // Перестановка заглавной картинки "body". ("body" скоро станет секцией, а в секциях другой порядок)
                 //    Картинка + Заголовок + Эпиграф   ›››   Заголовок + Эпиграф + Картинка
                 div2=Body.firstChild;
                 if (div2 !=null  &&  div2.className =="image") {
                         while(div2.nextSibling !=null)
                                 if (div2.nextSibling.className =="title"  ||  div2.nextSibling.className =="epigraph")
                                         div2=div2.nextSibling;
                                     else break;
                         if (div2.className !="image") {
                                 div2.insertAdjacentElement("afterEnd",Body.firstChild);
                                 count_502++ }
                         }

                 // Создание заголовка из имени "body" (если возможно)
                 if (Body.getAttribute("fbname") !=null  &&  Body.getAttribute("fbname") !=""  &&  Body.firstChild !=null  &&  Body.firstChild.className !="title") {
                         newTitle = document.createElement("DIV");
                         newTitle.className = "title";
                         newTitle.insertAdjacentElement("afterBegin", document.createElement("P"));
                         newTitle.firstChild.innerHTML = Body.getAttribute("fbname");
                         Body.insertAdjacentElement("afterBegin",newTitle);
                         count_503++;
                         q_503=true;
                         }
                     else q_503=false;

                 // Перемещение "body" в новую секцию и удаление оболочки этого "body"
                 newSection.insertAdjacentElement("beforeEnd",Body);
                 Body.removeNode(false);
                 count_501++;

                 // Проверка для нового заголовка
                 if (q_503) {
                         if (!fbwBodyMargin) {   //  Если поля для "fbw_body" не добалялись...
                                 fbwBody.style.paddingTop = window.external.GetViewHeight() + "px";        //  то добавляем внутренние поля.
                                 fbwBody.style.paddingBottom = window.external.GetViewHeight() + "px";
                                 fbwBodyMargin=true;
                                 }
                         msg1 = " СОХРАНИТЬ ЗАГОЛОВОК, полученный из имени <body>?\n"+
                                         "    (текст заголовка можно отредактировать)";
                         msgTitle="• 503. Заголовок <body> •";
                         msg2=newTitle.firstChild.innerHTML;

                         GoTo_0(newTitle);
                         updateImg(newTitle);           //  Обновление ближайших иллюстраций.

                         StyleDiv = document.createElement("DIV");            //  Создаем раздел стилей.
                         newTitle.insertAdjacentElement("afterBegin", StyleDiv);    //   Добавляем раздел стилей в текст.
                         StyleDiv.insertAdjacentElement("afterBegin", newTitle.lastChild);   //   Вставляем строки заголовка в этот раздел.
                         StyleDiv.style.backgroundColor="#821A1A";        //  Добавляем фон,
                         StyleDiv.style.color="#EEF47C";                             //  цвет шрифта
                         StyleDiv.style.border="none";                        //  и убираем рамку.

                         T_pause -= new Date().getTime();                  // определение продолжительности паузы в вычислениях
                         textOtvet = window.external.InputBox(msg1, msgTitle, msg2);       //  диалоговое окно
                         T_pause += new Date().getTime();                  // определение продолжительности паузы в вычислениях
                         otvet2 = window.external.GetModalResult();    //  Получение кода нажатой кнопки.

                         StyleDiv.removeNode(false);                            //  Удаляем раздел стилей.

                         if (otvet2 ==6) newTitle.firstChild.innerHTML=textOtvet;
                             else  {
                                 newTitle.removeNode(true);
                                 count_503-- }
                         }

                 }
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОБРАБОТКА ТЕКСТА _6_  :  Разделы "section"   :  операции  № 511-521

 var Section;                  //  Один из узлов "section".
 var classStroka="";    //  Строка с записью классов разделов, где каждый класс обозначен одной буквой.

 var count_511 = 0;
 var count_512 = 0;
 var count_514 = 0;
 var count_521 = 0;

 for (j=count_Section-1; j>=0; j--) {   //  Цикл выдает прямой порядок разделов в структуре книги.
         Section=mSection[j];

         //  Чистка секций в <body>:
         //  <body>[заголовок]<section>[эпиграф][ряд секций]</section></body>   и т.п.     ›››     <body>[заголовок][эпиграф][ряд секций]</body>
bbb: {
         if (Section.parentNode !=null  &&  Section.parentNode.className =="body") {
                 classStroka="";
                 div2=Section.parentNode.firstChild;
                 while (div2 !=null) {
                         if (div2.nodeName !="DIV")  break bbb;
                             else if (div2.className =="image")  classStroka+="i";
                                 else if (div2.className =="title")  classStroka+="t";
                                     else if (div2.className =="epigraph")  classStroka+="e";
                                         else if (div2.className =="section")  { if (classStroka.search("s") !=-1)  break bbb;  classStroka+="s" }
                                             else  break bbb;
                         div2=div2.nextSibling;
                         }
                 div2=Section.firstChild;
                 while (div2 !=null) {
                         if (div2.nodeName !="DIV")  break bbb;
                             if (div2.className =="title")  classStroka+="t";
                                 else if (div2.className =="epigraph")  classStroka+="e";
                                     else if (div2.className !="section")  break bbb;
                                         else  break;
                         div2=div2.nextSibling;
                         }
                 if (classStroka.search(/t.*t|e.*t/) !=-1)  break bbb; // проверка валидности при гипотетическом удалении тегов секции
                 Section.removeNode(false);
                 mSection.splice(j, 1);
                 count_511++;
                 continue;
                 }
         }

         //  Чистка внутренних секций
         //  (<section>[заголовок]<section>[эпиграф][строки или ряд секций]</section></section>   и т.п.     ›››     <section>[заголовок][эпиграф][строки или ряд секций]</section>)
ccc: {
         if (Section.parentNode !=null  &&  Section.parentNode.className =="section") {
                 classStroka="";
                 div2=Section.parentNode.firstChild;
                 while (div2 !=null) {
                         if (div2.nodeName !="DIV")  break ccc;
                             else if (div2.className =="title")  classStroka+="t";
                                 else if (div2.className =="epigraph")  classStroka+="e";
                                     else if (div2.className =="image")  classStroka+="i";
                                         else if (div2.className =="annotation")  classStroka+="a";
                                             else if (div2.className =="section")  { if (classStroka.search("s") !=-1)  break ccc;  classStroka+="s" }
                                                 else  break ccc;
                         div2=div2.nextSibling;
                         }
                 div2=Section.firstChild;
                 while (div2 !=null  &&  div2.nodeName =="DIV") {
                         if (div2.className =="title")  break ccc;
                             else if (div2.className =="epigraph")  classStroka+="e";
                                 else if (div2.className =="image")  classStroka+="i";
                                     else if (div2.className =="annotation")  classStroka+="a";
                                         else if (div2.className =="section")  { if (classStroka.search(/s$/g) !=-1)  break;  classStroka+="s" }
                                             else  break;
                         div2=div2.nextSibling;
                         }
                 if (classStroka.search(/.t|i.*e|i.*i.*[as]|a.*e/) !=-1)  break ccc;   // проверка валидности при гипотетическом удалении тегов секции
                 Section.removeNode(false);
                 mSection.splice(j, 1);
                 count_512++;
                 continue;
                 }
         }

         //  Объединение двух секций вида:    1) Заголовок + пустая строка   и   2) Секция с текстом, который можно добавить к заголовку.
 if (Section.children.length ==2  &&  Section.firstChild.className =="title"  &&  Section.lastChild.nodeName =="P"  &&  Section.lastChild.innerHTML ==""
     &&  Section.nextSibling  &&  Section.nextSibling.className =="section"  &&  Section.nextSibling.firstChild.className !="title") {
             // Чистка двойных разделов "DIV" (удаление секции над двойной секцией)
             if (Section.parentNode.children.length ==2  &&  Section.parentNode.className =="section") {
                     Section.parentNode.removeNode(false);
                     mSection.splice(j+1, 1);
                     count_402++; }
             //  Объединение двух секций (продолжение)
             Section.nextSibling.insertAdjacentElement("afterBegin", Section.firstChild);
             Section.removeNode(true);
             mSection.splice(j, 1);
             count_514++;
             continue;
             }

 }    //  конец цикла для секций


 for (j=mSection.length-1; j>=0; j--) {   //  Цикл выдает прямой порядок разделов в структуре книги.
         Section=mSection[j];

         // Перемещение заголовка основной секции   в   <body>
         //  <body>[картинка]<section>[заголовок][ряд строк]</section></body>     ›››     <body>[картинка][заголовок]<section>[ряд строк]</section></body>
ddd: {
         if (Section.parentNode !=null  &&  Section.parentNode.className =="body") {
                 classStroka="";
                 div2=Section.parentNode.firstChild;
                 while (div2 !=null) {
                         if (div2.nodeName !="DIV")  break ddd;
                             else if (div2.className =="image")  classStroka+="i";
                                 else if (div2.className =="section")  { if (classStroka.search("s") !=-1)  break ddd;  classStroka+="s" }
                                     else  break ddd;
                         div2=div2.nextSibling;
                         }
                 div2=Section.firstChild;
                 while (div2 !=null) {
                         if (div2.className =="title")  classStroka+="t";
                             else if (div2.className =="section")  break ddd;
                                 else if (div2.nodeName =="P")  break;
                         div2=div2.nextSibling;
                         }
                 if (classStroka.search(/^[^t]+$|[^s]t/) !=-1)  break ddd;
                 Section.insertAdjacentElement("beforeBegin",Section.firstChild);
                 count_521++;
                 }
         }

 }    //  конец цикла для секций

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ВОПРОС  :  Разделы "image"  :  вопрос  021

 var count_021 = 0;
 var otvet_021 = false;
 var img;                //  одна из картинок ("DIV")

 for (j=count_Img-1; j>=0; j--) {   //  Цикл выдает прямой порядок разделов в структуре книги.
         img=mImg[j];

                 //  Подсчет сочетаний:   Иллюстрация + Пустая_строка + Секция   или   Иллюстрация + Секция
         if (img.parentNode.className =="section") {
                 if (img.nextSibling !=null  &&  img.nextSibling.innerHTML ==""  &&  img.nextSibling.nextSibling !=null  &&  img.nextSibling.nextSibling.className =="section"
                     ||  img.nextSibling !=null  &&  img.nextSibling.className =="section")
                            { count_021++ }
                 }

         }


         //   Вопросы к пользователю

 var Najden = [ "Найдена ", "Найдены ", "Найдены " ];
 var ill_v_karm = [ " иллюстрация в кармане", " иллюстрации в карманах", " иллюстраций в карманах" ];
 var ill_nov_razd = [ "иллюстрацию новой внутренней секцией", "иллюстрации новыми внутренними секциями", "иллюстрации новыми внутренними секциями" ];


 if (count_021!=0  &&  Obrabotka_karm_Img ==2)  {
         pad(count_021);
         T_pause-=new Date().getTime();
         otvet_021=AskYesNo("               ◊  ИЛЛЮСТРАЦИЯ В КАРМАНЕ  ◊                                 \n\n"+
                                                      ""+Najden[ok]+count_021+ill_v_karm[ok]+" секций:\n\n"+
                                                      "< Начало внешней секции >\n"+
                                                      "    < . . . . . >\n"+
                                                      "    < Иллюстрация >\n"+
                                                      "    < Внутренние секции >\n"+
                                                      "< Конец внешней секции >\n\n"+
                                                      "ОБРАМИТЬ "+ill_nov_razd[ok]+"?");
         T_pause+=new Date().getTime();
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОБРАБОТКА ТЕКСТА _7_  :  Разделы "image"  :  операции  № 6хх

 var imgUp;          //  узлы рядом с картинкой
 var count_601 = 0;   var count_611 = 0;   var count_621 = 0;   var count_622 = 0;   var count_631 = 0;   var count_632 = 0;   //  Счетчики

 //  Сборка рег. выражения "re611ex"
 var Re_Add_Entity = "&";
 if (Add_Entity_Img_Podpis != 1)  Re_Add_Entity += "|cite|subtitle||normal";
 if (Add_Entity_Img_Title != 1)  Re_Add_Entity += "|title";
 if (Add_Entity_Img_Img != 1)  Re_Add_Entity += "|image";
 var re611ex = new RegExp("^("+Re_Add_Entity+")$","g");      //  класс тегов -- исключения для автоматической редакции


 for (j=0; j<count_Img; j++) {   //  Цикл выдает обратный порядок разделов в структуре книги (здесь порядок разделов не важен).
         img=mImg[j];
         if (img.parentNode.className =="section") {


                   //  Удаление пустых строк рядом с картинкой в "кармане" секций: <section>[заголовок]+[эпиграфы]+[картинка]+[аннотация]<section>.....</section></section>
                   //  * По правилам FBE, в "кармане" может быть только указанный порядок тегов (если они есть). И между ними не может быть ничего другого, в т.ч. и пустых строк
                   if (img.nextSibling !=null  &&  img.nextSibling.innerHTML ==""
                       &&  img.nextSibling.nextSibling !=null  &&  (img.nextSibling.nextSibling.className =="section"  ||  img.nextSibling.nextSibling.className =="annotation"))
                               { img.nextSibling.removeNode(true); count_601++ }   //  удаление пустой строки после картинки
                   if (img.previousSibling !=null  &&  img.previousSibling.innerHTML ==""
                       &&  img.nextSibling !=null  &&  (img.nextSibling.className =="section"  ||  img.nextSibling.className =="annotation"))
                               { img.previousSibling.removeNode(true); count_601++ }   //  удаление пустой строки перед картинкой


                   if (img.nextSibling ==null  ||  img.nextSibling !=null  &&  img.nextSibling.className !="section"  &&  img.nextSibling.className !="annotation")
                           {                    //  ----------------   начало отбора картинок, которые не в "кармане"

                           //  Вставка пустой строки перед картинкой (внутри секции)
                           if (img.previousSibling !=null  &&  img.previousSibling.innerHTML !=""  &&  img.previousSibling.className.search(re611ex)==-1) {
                                   img.insertAdjacentElement("beforeBegin", document.createElement("P"));
                                   window.external.inflateBlock(img.previousSibling)=true;
                                   count_611++ }

                           //  Вставка пустой строки после картинки (внутри секции)
                           if (img.nextSibling !=null  &&  img.nextSibling.innerHTML !=""  &&  img.nextSibling.className.search(re611ex)==-1) {
                                   img.insertAdjacentElement("afterEnd", document.createElement("P"));
                                   window.external.inflateBlock(img.nextSibling)=true;
                                   count_611++ }

                           //  Удаление пустой строки между границей секции и картинкой
                           if (img.previousSibling !=null  &&  img.previousSibling.previousSibling ==null  &&  img.previousSibling.innerHTML =="")
                                   { img.previousSibling.removeNode(true); count_622++ }

                           //  Вставка пустой строки между картинкой и границей секции (если кроме картинки, в секции больше ничего нет)
                           if (img.previousSibling ==null  &&  img.nextSibling ==null) {
                                   img.insertAdjacentElement("afterEnd", document.createElement("P"));
                                   window.external.inflateBlock(img.nextSibling)=true;
                                   count_621++ }

                           //  Удаление пустой строки между картинкой и границей секции (если перед картинкой что-то есть)
                           if (img.previousSibling !=null  &&  img.nextSibling !=null  &&  img.nextSibling.nextSibling ==null  &&  img.nextSibling.innerHTML=="")
                                   { img.nextSibling.removeNode(true); count_622++ }

                           }                    //  ----------------   конец отбора картинок, которые не в "кармане"


                   //  Перемещение картинки из "кармана" в отдельную секцию
                   if ((Obrabotka_karm_Img ==1  ||  otvet_021)  &&  img.nextSibling !=null  &&  img.nextSibling.className =="section")  {
                           newSection = document.createElement("DIV");   newSection.className ="section";      //  создание новой секции
                           img.insertAdjacentElement("afterEnd",newSection);     //  Вставка новой секции после картинки
                           newSection.insertAdjacentElement("afterBegin", document.createElement("P"));     //  Вставка оболочки будущей пустой строки в новую секцию
                           window.external.inflateBlock(newSection.firstChild)=true;     //  Вставка содержимого пустой строки
                           newSection.insertAdjacentElement("afterBegin",img);     //  Перемещение картинки в новую секцию (в начало секции)
                           count_631++;
                           //  Далее проверка наличия пустой секции, стоящей после новой секции, и её удаление
                           if (newSection.nextSibling !=null) {
                                   imgUp = newSection.nextSibling;
                                   if (imgUp.className =="section"  &&  imgUp.children.length ==1  &&  imgUp.firstChild.nodeName =="P"  &&  imgUp.firstChild.innerHTML =="")
                                           { imgUp.removeNode(true); count_263++ }
                                   }
                           //  Далее повторная проверка на наличие лишнего обрамления секцией, и её удаление
                          eee: {
                                   if (newSection.parentNode.className =="section"  &&  newSection.parentNode.parentNode !=null  &&  newSection.parentNode.parentNode.className =="body") {
                                           classStroka="";
                                           div2=newSection.parentNode.parentNode.firstChild;
                                           while (div2 !=null) {
                                                   if (div2.nodeName !="DIV")  break eee;
                                                       else if (div2.className =="image")  classStroka+="i";
                                                           else if (div2.className =="title")  classStroka+="t";
                                                               else if (div2.className =="epigraph")  classStroka+="e";
                                                                   else if (div2.className =="section")  { if (classStroka.search("s") !=-1)  break eee;  classStroka+="s" }
                                                                       else  break eee;
                                                   div2=div2.nextSibling;
                                                   }
                                           div2=newSection.parentNode.firstChild;
                                           while (div2 !=null) {
                                                   if (div2.nodeName !="DIV")  break eee;
                                                       if (div2.className =="title")  classStroka+="t";
                                                           else if (div2.className =="epigraph")  classStroka+="e";
                                                               else if (div2.className !="section")  break eee;
                                                                   else  break;
                                                   div2=div2.nextSibling;
                                                   }
                                           if (classStroka.search(/t.*t|e.*t/) !=-1)  break eee; // проверка валидности при гипотетическом удалении тегов секции
                                           newSection.parentNode.removeNode(false);
                                           count_511++;
                                           }
                                   }
                           }                    //  ----------------   конец для    "Перемещение картинки из кармана в отдельную секцию"

                   }                    //  ----------------   конец отбора картинок в секции


           //  Перемещение картинки из <body> в отдельную секцию (когда расположение картинки невалидно - расположена не в начале <body>)
           if (img.parentNode.className =="body"  &&  img.previousSibling !=null  &&  img.nextSibling !=null  &&  img.nextSibling.className =="section")  {
                   newSection = document.createElement("DIV");   newSection.className ="section";      //  создание новой секции
                   img.insertAdjacentElement("afterEnd",newSection);     //  Вставка новой секции после картинки
                   newSection.insertAdjacentElement("afterBegin", document.createElement("P"));     //  Вставка оболочки будущей пустой строки в новую секцию
                   window.external.inflateBlock(newSection.firstChild)=true;     //  Вставка содержимого пустой строки
                   newSection.insertAdjacentElement("afterBegin",img);     //  Перемещение картинки в новую секцию (в начало секции)
                   count_632++;
                   //  Далее проверка наличия пустой секции, стоящей после новой секции, и её удаление
                   if (newSection.nextSibling !=null) {
                           imgUp = newSection.nextSibling;
                           if (imgUp.className =="section"  &&  imgUp.children.length ==1  &&  imgUp.firstChild.nodeName =="P"  &&  imgUp.firstChild.innerHTML =="")
                                   { imgUp.removeNode(true); count_263++ }
                           }
                   }

           }                    //  ----------------   конец цикла перебора всех картинок

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// Подсчет общего количества исправлений

 var itogi = count_100 + count_103 + count_150 + count_201 + count_213 + count_214 + count_227 + count_232 + count_241 + count_251 + count_252 + count_253 + count_262 + count_263 + count_271 + count_272 + count_281 + count_301 + count_311 + count_401 + count_402 + count_501 + count_502 + count_503 + count_511 + count_512 + count_514 + count_521 + count_601 + count_611 + count_621 + count_622 + count_631 + count_632;


 if (itogi != 0)  window.focus();  // Удаление курсора из текста, при результативной обработке

// * Если этого не делать, то при нахождении курсора на месте удаленной или значительно преобразованной строки, он может оказаться в запретном месте, и тогда ручной ввод любого текста может привести к вылету FBE (происходит такое в браузере IE11), либо к созданию аномальной структуры (происходит такое везде).
// ** По идее курсор надо бы переместить внутрь параграфа, но этого я не умею.

 itogi += count_211 + count_212 + count_228 + count_231 + count_320 + count_321 + count_322;  // наиболее безопасные операции для курсора

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 ///  Очистка полей в "fbw_body"

 if (fbwBodyMargin) {   //  Если поля в "fbw_body" добавлялись...
         var H_first_Elem = fbwBody.firstChild.getBoundingClientRect().top;   //  то определяем высоту первого элемента книги,
         fbwBody.style.removeAttribute("paddingTop");        //  удаляем поля
         fbwBody.style.removeAttribute("paddingBottom");
         window.scrollBy(0, fbwBody.firstChild.getBoundingClientRect().top - H_first_Elem);   //  и сдвигаем текст в исходное положение.
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 ///  ПОВЫШЕНИЕ ВЕРСИИ ФАЙЛА И ЗАПИСЬ В ИСТОРИЮ ИЗМЕНЕНИЙ
                 //  (применение функции "HistoryChange")

 var versionFile=document.getElementById("diVersion").value; //  Извлечение значения версии файла.
 var newVersion = versionFile;                                                          //  Значение новой версии.

 var HiCh=0;                     //  Код изменения истории.
 var VersionUp=false;   //  Индикатор повышения версии.

//  Если включено автоматическое повышение версии, а также если есть измененные строки или разрешено повышение версии когда нет изменений...
 if (Version_on_off == 1  &&  (itogi  ||  Vsegda_on_off == 1))
         HistoryChange(ScriptName + " " + NumerusVersion, youName);   //  запускаем функцию для изменения данных истории

// ---------------------------------------------------------------

 window.external.EndUndoUnit(document);    // Конец записи в систему отмен.

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОКНО РЕЗУЛЬТАТОВ  :  Текущее время и дата

 var currentFullDate = new Date();

 var currentHours = currentFullDate.getHours();
 var currentMinutes = currentFullDate.getMinutes();
 var currentSeconds = currentFullDate.getSeconds();

 if (currentMinutes<10) currentMinutes = "0" + currentMinutes;
 if (currentSeconds<10) currentSeconds = "0" + currentSeconds;

 var currentDay = currentFullDate.getDate();
 var currentMonth = 1+currentFullDate.getMonth();
 var currentYear = currentFullDate.getFullYear();

 if (currentMonth<10) currentMonth = "0" + currentMonth;
 currentYear = (currentYear+"").replace(/^.*?(\d{1,2})$/g, "$1");

 var currentTime = currentHours + ":" + currentMinutes + ":" + currentSeconds;
 var currentDate = currentDay + "." + currentMonth + "." + currentYear;

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// СОЗДАНИЕ СПИСКА ЦИТАТ

//  Из книги "Пословицы и поговорки Великой Отечественной войны"
//  (составитель Павел Федорович Лебедев)

 var Kn=[ "Одна у человека мать, одна у него и Родина.",   "Родина любимая – мать родимая.",   "Родина – мать, умей за нее постоять.",   "Где ни жить – Родине служить.",   "С Родиной разлука – одна мука.",   "Всякому мила своя сторона.",   "Своя земля и в горсти мила.",   "На чужой стороне и весна не красна.",   "Где кто родится, там и пригодится.",   "На чужбине родная землица во сне снится.",   "На своей стороне мило, на чужой – постыло.",   "На чужой стороне и сокола зовут вороною.",   "Всякая сосна своему лесу весть подает.",   "Родная страна – колыбель, чужая – дырявое корыто.",   "На солнце тепло, на родине добро.",   "Человек без Родины что соловей без песни.",   "Глупа та птица, которой свое гнездо не мило.",   "Кукушка кукует – по бездомью горюет.",   "Расставшийся с другом плачет семь лет, расставшийся с Родиной – всю жизнь.",   "Нет ничего на свете краше, чем Родина наша.",   "Нашей страны шире не найти в мире.",   "Русское раздолье – человеку приволье.",   "Богата русская земля – говорится не зря.",   "Я тобой горжусь, милая Русь.",   "Человек без Родины что солдат без оружия.",   "Счастье Родины дороже жизни.",   "Береги страну как зеницу ока.",   "Может, и голову сложу, а Родине послужу.",   "Нам Отчизна дорога, охраняем родные берега.",   "Пусть знает ворог: нам край свой дорог.",   "Кто любовь к Отчизне имеет, тот врага одолеет.",   "Мы бережем свою Родину-мать, за нее мы готовы жизнь отдать.",   "С нами родная земля, нам светят звезды Кремля.",   "Великие победы нас ждут впереди под лучами красной звезды.",   "Красная звезда светит всегда.",   "Теперь все дороги ведут в Москву.",   "Москва от глаз далека, да сердцу близка.",   "Москва – наша столица, Москвой народ гордится.",   "Москва – всем столицам голова.",   "Москва – столица, любо подивиться.",   "У русской столицы не видать границы.",   "По Москве ходить – глаз с нее не сводить.",   "Москва – Родины украшенье, врагам устрашение.",   "Кремль тем и красен, что с народом согласен.",   "Наша страна дружбой сильна.",   "У нас все народы живут в ладу – врагам на беду.",   "Солнце не померкнет над нами, братство – наша сила и знамя.",   "Народное братство дороже всякого богатства.",   "Если дружба велика, будет Родина крепка.",   "Дружбу нашу не разделят просторы, моря и горы.",   "Страна растет – врагов метет.",   "Не тот человек, кто для себя живет, а тот человек, кто народу силы отдает.",   "За Родину и народ иду вперед.",   "Человек без народа что дерево без плода.",   "Чтобы с врагами биться, надо всем сплотиться.",   "Не трудно врагов победить, если всем заодно быть.",   "Наш народ сплочен и един, он непобедим.",   "Кто на нас нападает, тот в могилу попадает.",   "Россия с давних пор давала врагу отпор.",   "Никогда Россия ярма не носила.",   "За наше Отечество все человечество.",   "Не летать фашистским стаям над нашим краем.",   "Мы не боимся свинцовой тучи: наши полки могучи.",   "Кто на Советский Союз покушается, тот после раскается.",   "Бей фашистов не в бровь, а в глаз – таков народа наказ.",   "Любовь к народу, ненависть к врагу – душа победы.",   "От Родины награда – сердцу отрада.",   "Отчизна родная – для нас святая.",   "Знает свет: тверже русских нет.",   "Наш народ – герой, ходит на врага стеной.",   "Сыновья русских матерей славятся удалью богатырей.",   "Наша страна героями славится.",   "Кто за Родину горой – тот истинный герой.",   "Без патриотизма не разбить фашизма.",   "Защищай Советскую державу, бей фашистскую ораву.",   "Фашистам смерть неси – не опозорь Руси.",   "Даю Родине слово: мстить фашистам сурово.",   "Во имя Отчизны своей где фашиста увидел – бей.",   "За народное дело бейся смело.",   "Для Родины своей ни сил, ни жизни не жалей.",   "Жизнь отдам, а Родину не продам.",   "С родной земли – умри не сходи.",   "За Родину-мать не страшно умирать.",   "За Родину жизни не пощадим, но врагу ничего не отдадим.",   "Кому нашей земли захочется, тот под ней скорчится.",   "Родину любить – фашистов бить.",   "Бей фашистский сброд – за Родину, за народ.",   "Родину любить – верно Родине служить.",   "Родину беречь – врагов сечь.",   "Для нас война не страх – развеем врага в прах.",   "Гитлер пришел к нам незваным, а уйдет от нас драным.",   "Не придется Гитлеру из Ленинграда сделать море, а из Москвы – поле.",   "Думал Гитлер нашими землями управлять, а придется ему подыхать.",   "Штык советский молодец – скоро Гитлеру конец.",   "У Гитлера не столько расчетов, сколько просчетов.",   "Гитлер предполагает, а Красная Армия располагает.",   "Посмотрим, как Гитлер завоет, когда наши огонь по Берлину откроют.",   "Раздавим Гитлера в блин, как придем в Берлин.",   "Гитлеру-палачу местью отплачу.",   "Пора с Гитлером кончать – хватит ему рычать.",   "Гитлер и его правительство ответят за грабительство.",   "Гитлер кричит, мы весь свет разрушим, а мы Гитлера наперед задушим.",   "Сколько Гитлер ни крути, а от петли не уйти.",   "Гитлер победами хвалится, да в могилу свалится.",   "Хотел Гитлер Россию съесть, да пришлось в лужу сесть.",   "Не довелось свинье на небо дивиться, а Гитлеру в нашем огороде рыться.",   "Медведя знают по когтям, а Геббельса по лживым речам.",   "Фашистские собаки сочиняют враки.",   "Фашист брехней живет.",   "Солдаты у Гитлера вшивы, сводки у Геббельса лживы.",   "От осины не жди ягоды, от фашиста – правды.",   "Геббельс вертит языком без меры, да нет ему веры.",   "Геббельс мелет, да никто ему не верит.",   "Германия вот-вот развалится, а Геббельс все хвалится.",   "Германия пылает, а Геббельс все лает.",   "Врет, как фашистский бюллетень.",   "Как Геббельс ни врет, а наша берет.",   "Против фашистской лжи ухо востро держи.",   "Фашистские оковы всей Европе знакомы.",   "Лучше волку в зубы, чем фашистам в руки.",   "Фашист гладок, да вид его гадок.",   "Фашист от когтей до носа похож на барбоса.",   "Фашист и сатана – сущность одна.",   "Не ищи в фашисте человека – не найдешь.",   "Легче шакала превратить в голубя, чем фашиста в человека.",   "Фашистов легче убить, чем вразумить.",   "Фашистская власть – грабить и красть.",   "У фашистов особый спорт: кто больше добра сопрет.",   "Видно птицу по полету, а фашиста – по грабежам.",   "Сколько фашисту ни воровать, а виселицы не миновать.",   "Для предателя сгори хоть целый свет, лишь бы он был согрет.",   "Змея один раз в год меняет кожу, а предатель – каждый день.",   "Предатель фашисту пятки лизал, а фашист и спасибо не сказал.",   "У предателя ни Родины, ни друзей.",   "Лучше глаза лишиться, чем доброго имени.",   "Героям – слава, предателям – смерть.",   "Слава греет, позор жжет.",   "Бесчестье хуже смерти.",   "Кто с врагами пьет и гуляет, того и земля не принимает.",   "Думал фриц нашим богатством нажиться, да пришлось в могилу ложиться.",   "Не видать свинье неба, а фашистам нашего хлеба.",   "Кого к столу приглашают, а в фашиста пулю сажают.",   "Кому чарка, кому две, а фашисту – камнем по голове.",   "Угостили фашистов не водкой, а прямой наводкой.",   "Врага не уговаривай: с ним штыком разговаривай.",   "Убил фашистского гада – душа рада.",   "Съели бы фашисты русского мужика, да кишка тонка.",   "Одного фашиста убить – сто детей спасти.",   "Фашиста убить что змею: сто грехов простится.",   "Лучше смерть на поле, чем позор в неволе.",   "Чем позор и неволю терпеть, лучше в бою умереть.",   "Лучше биться орлом, чем жить зайцем.",   "Никогда фашистам не властвовать над нами, никогда не будем рабами.",   "Лучше злая пуля, чем клеймо раба.",   "Славная смерть лучше постыдной жизни.",   "Воевать – не галушки жевать.",   "Не воевать – победы не видать.",   "Слабого огонь войны испепеляет, а сильного как сталь закаляет.",   "Кто за правое дело дерется, у того двойная сила берется.",   "Наше дело правое – бей врага браво.",   "Бей фашистских властей всех мастей.",   "С какой злостью превеликой мы расправимся с фашистской кликой.",   "С врагами биться – на пули не скупиться.",   "Винтовка хлоп – и фашист в гроб.",   "Пришел фашист из Берлина – получил земли три аршина.",   "Не важно, чем бил, – важно, что фашиста убил.",   "Каждой фашистской гадине висеть на перекладине.",   "Всякому свой путь: журавлю – в небо, волку – в лес, а фашисту – в могилу.",   "Упрямого выправит дубина, а фашиста – могила.",   "Какую яму фашист копал – в такую и попал.",   "Фашисты научились воровать, а мы научились фашистов убивать.",   "Наш порог не для фашистских сапог.",   "Фашиста согнем в бараний рог, чтоб не переступал наш порог.",   "Лося бьют в осень, а фашиста всегда.",   "Наше дело святое и правое, мы расправимся с фашистскою оравою.",   "С фашистом разговор короткий: круши его прямой наводкой.",   "Кричал фашист «гоп», да получил пулю в лоб.",   "Фашиста умертвить – доброе дело сотворить.",   "На фронте воевать – славу добывать.",   "Фронт гремит – у врага земля горит.",   "Гремят вспышки на горизонте: то бьют фашистов на фронте.",   "Фашистов разгромили – и в селе порядок водворили.",   "Фашист замахнулся, да промахнулся.",   "Дрался фашист пылко, да остался без затылка.",   "Фашисты козыряли, да головы потеряли.",   "Фашисты пять раз на дню попадают в западню.",   "У фашистов брожение: попали в окружение.",   "Фашистам не все напирать – пришлось и умирать.",   "Трави фашистскую силу – огнем и штыком загоняй в могилу.",   "Чокнемся, фашист, я парень не гордый: я – прикладом, а ты – мордой.",   "На то у винтовок и ложи, чтобы бить фашиста по роже.",   "Слава русского штыка не померкнет века.",   "Штык остёр загнал фрицев в «котел».",   "Наши штыки разгромят фашистские полки.",   "Фашисты войну начали, а мы кончим.",   "Славу свою добывай в бою.",   "Почет и славу собирают по капле.",   "Народ того уважает, кто фашистов уничтожает.",   "На то мы и внуки Суворова, чтобы сражаться здорово.",   "Как учил Александр Суворов – будь к врагу суровым.",   "На краю света фашистов найдем и на суд приведем.",   "Зря фашист блиндажи строит: все равно снаряд накроет.",   "Смерть фашистской своре – на берегу и в море!",   "Солдата мать родит, отец растит, а бой учит.",   "Дерево в огне сгорает, а солдат от огня крепче бывает.",   "Кто первый бой начинает, тот скорее побеждает.",   "Пришла пора гнать фашистов со двора.",   "Фашист наступает – кричит «гут», а отступает – «Гитлер капут».",   "Красна девушка косами, солдат – орденами.",   "Ученый водит, а неуч сзади ходит.",   "Птицу обманывают кормом, а человека – словом.",   "Слово, сказанное без соображения, подобно выстрелу без прицела.",   "Говорить впустую что стрелять вхолостую.",   "У осла длинные уши, а у болтуна длинный язык.",   "У короткого ума длинный язык.",   "Слово не воробей: выпустишь – не поймаешь.",   "Скажешь – не воротишь, напишешь – не сотрешь, отрубишь – не приставишь.",   "Лучше один раз увидеть, чем сто раз услышать.",   "Острый язык – дарование, длинный язык – наказание.",   "Не всегда говори то, что знаешь, но всегда знай, что говоришь.",   "Кто много болтает, тот врагу помогает.",   "Кто зевает – победителем не бывает.",   "Храбрость города берет, а бдительность их бережет.",   "Зря не болтай у телефона: болтун – находка для шпиона.",   "Нет друга – так ищи, а найдешь – береги.",   "Ищи себе друзей таких, чтобы не было стыда от них.",   "Не ходи, дружок, в неизвестный кружок: к таким людям зайдешь, что навек пропадешь.",   "Плохой друг подобен тени: только в светлые дни его и видишь.",   "Не та дружба сильна, что в словах заключена, а та, что в бою скреплена.",   "Для друзей – пироги, для врагов – кулаки.",   "В недруге пуля что во пне, а в друге что во мне.",   "Все за одного, один за всех – вот и обеспечен в бою успех.",   "Не имей сто рублей, а имей сто друзей.",   "В дружбе – правда.",   "Кто нашел друга – нашел сокровище.",   "Сам пропадай, а товарища выручай.",   "Один в поле не воин, а вдвоем с товарищем – взвод.",   "Где дружба и лад – там и клад.",   "Где дружба и совет – там и свет.",   "Трусливый друг опаснее врага, ибо врага опасаешься, а на друга опираешься.",   "Не тот друг, кто медом мажет, а тот, кто правду скажет.",   "Недруг поддакивает, а друг спорит.",   "Дружба крепка не лестью, а правдой и честью.",   "Новых друзей наживай, а старых не забывай.",   "Прямо страху в глаза смотри – и страх смигнет.",   "Волков бояться – в лес не ходить.",   "Трус умирает тысячу раз, а смелый всего один раз.",   "Советские воины из металла скроены.",   "Чем больше героев, тем скорее фашистов зароем.",   "Храбрость – сестра победы.",   "На смелого собака лает, а трусливого – рвет.",   "Не числом, а храбростью побеждают.",   "Лучше быть мертвым героем, чем живым трусом.",   "Смелого и пуля облетит, смелый и мину перехитрит.",   "Если не будешь овцой, то волк не съест.",   "Косил Гитлер глаз на Донбасс, а Донбасс опять у нас.",   "И про солдатскую честь пословица есть.",   "Потому и смешно, что фашистам горе пришло.",   "Гитлеровским сателлитам быть разбитым.",   "Знаем, за что бьем, потому и с победой придем.",   "Кто за правое дело стоит, тот всегда победит.",   "У правого сила удвоится, говорит пословица.",   "Будет праздник и на улице нашей, всякого праздника краше.",   "Войну закончим – и мир упрочим.",   "Как фашисты нам ни грозили, а мы их сразили.",   "Фашистов разгромили – добро сотворили.",   "Хотел Гитлер покорить весь мир, да лопнул как мыльный пузырь.",   "Задохнулась фашистская стая девятого мая.",   "Разбили фашистскую орду в сорок пятом году.",   "Прогнали фрицев – можно веселиться.",   "Советская Армия врага разгромила, она стоит на страже мира.",   "Курские леса и дубравы полны легендарной славы.",   "Виден в курских лесах боевой размах.",   "Защитим курские дубравы от фашистской оравы!",   "В курских городах разбили фашистов в прах.",   "Как фашисты ни рвались к Курску – не дали им спуску.",   "Бей врага, Суджа, зарывай глубже." ];

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 // Демонстрационный режим "Показать все строки"

 var VseStroki_on_off = 0;      // 0 ; 1 //      ("0" — отключить, "1" — включить)

 var d=0;
 if (VseStroki_on_off ==1)  d="показать нули";

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОКНО РЕЗУЛЬТАТОВ  :  Сборка массива с результатами обработки

 var Tf=new Date().getTime();
 var mSt=[];
 var ind=0;
                                        mSt[ind]=" "+ScriptName+" v." + NumerusVersion;  ind++;
                                        mSt[ind]="-----------------------------------------------------------------------";  ind++;
 if (d)                          { mSt[ind]=" Демонстрационный режим";  ind++ }
                                        mSt[ind]="						          ";  ind++;

                                        mSt[ind]="• СТАТИСТИКА:";  ind++;
                                        mSt[ind]="Время выполнения .  .  .  .  .  .  .  .  .	"+time(Tf-Ts);  ind++;
 if (T_pause!=d)     { mSt[ind]="Вычисления   .  .  .  .  .  .  .  .  .  .  .  .	"+time(Tf-Ts-T_pause);  ind++ }
 if (itogi!=d)             { mSt[ind]="Всего исправлений .  .  .  .  .  .  .  .  .	"+itogi;  ind++ }
 if (itogi==0 || d)    { mSt[ind]="";  ind++;
                                        mSt[ind]="   >> Исправлений нет";  ind++; }

 var cTaT=ind;  //  число строк в первом разделе

                                        mSt[ind]="";  ind++;
                                        mSt[ind]="• РАЗНЫЕ ИСПРАВЛЕНИЯ:";  ind++;

 if (count_100!=d)  { mSt[ind]="100. Восстановление параграфов .  .  .  .  .  .  .  .  .  .  .	"+count_100;  ind++ }
 if (count_103!=d)  { mSt[ind]="103. Коррекция внутренних тегов вне параграфа  	"+count_103;  ind++ }
 if (count_150!=d)  { mSt[ind]="150. Добавление разрыва секции перед заголовком	"+count_150;  ind++ }
 if (count_201!=d)  { mSt[ind]="201. Удаление повторных внутренних тегов в строке	"+count_201;  ind++ }
 if (count_202!=d)  { mSt[ind]="202. Добавление формата \"Цитата\" .  .  .  .  .  .  .  .  .  .	"+count_202;  ind++ }
 if (count_211!=d)  { mSt[ind]="211. Замена \"&nbsp;\" на неразрывный пробел .  .  .  .	"+count_211;  ind++ }
 if (count_227!=d)  { mSt[ind]="227. Формат \"подзаголовок\" для строк из символов	"+count_227;  ind++ }
 if (count_228!=d)  { mSt[ind]="228. Коррекция подзаголовков из символов  .  .  .  .  .	"+count_228;  ind++ }
 if (count_231!=d)  { mSt[ind]="231. Удаление мусора из строк с графикой  .  .  .  .  .  .	"+count_231;  ind++ }
 if (count_232!=d)  { mSt[ind]="232. Удаление формата со строки с графикой  .  .  .  .	"+count_232;  ind++ }
 if (count_301!=d)  { mSt[ind]="301. Переоформление графики  .  .  .  .  .  .  .  .  .  .  .  .	"+count_301;  ind++ }
 if (count_320!=d)  { mSt[ind]="320. Удаление формата в примечаниях  .  .  .  .  .  .  .  .	"+count_320;  ind++ }
 if (count_321!=d)  { mSt[ind]="321. Удаление формата в комментариях   .  .  .  .  .  .  .	"+count_321;  ind++ }
 if (count_322!=d)  { mSt[ind]="322. Верхний индекс для комментариев .  .  .  .  .  .  .  .	"+count_322;  ind++ }
 if (count_402!=d)  { mSt[ind]="402. Исправление двойных разделов  .  .  .  .  .  .  .  .  .	"+count_402;  ind++ }
 if (count_501!=d)  { mSt[ind]="501. Преобразование раздела \"body\" в секцию   .  .  .	"+count_501;  ind++ }
 if (count_502!=d)  { mSt[ind]="502. Перестановка заглавной картинки .  .  .  .  .  .  .  .	"+count_502;  ind++ }
 if (count_503!=d)  { mSt[ind]="503. Преобразование имени \"body\" в заголовок .  .  .	"+count_503;  ind++ }
 if (count_511!=d)  { mSt[ind]="511. Удаление лишней секции в \"body\"  .  .  .  .  .  .  .  .	"+count_511;  ind++ }
 if (count_512!=d)  { mSt[ind]="512. Удаление лишних внутренних секций   .  .  .  .  .  .	"+count_512;  ind++ }
if (count_514!=d)  { mSt[ind]="514. Объединение двух секций: заголовок+текст  .  .	"+count_514;  ind++ }
 if (count_521!=d)  { mSt[ind]="521. Заголовок из основной секции  в \"body\" .  .  .  .  .	"+count_521;  ind++ }
 if (count_631!=d)  { mSt[ind]="631. Иллюстрация из \"кармана\"  в новую секцию .  .	"+count_631;  ind++ }
 if (count_632!=d)  { mSt[ind]="632. Иллюстрация из \"body\"  в новую секцию .  .  .  .  .	"+count_632;  ind++ }

 if (cTaT==ind-2) ind=ind-2;  //  Удаление двух последних строк, если нет пунктов в этом разделе
 cTaT=ind;  //  число строк в двух разделах

                                        mSt[ind]="";  ind++;
                                        mSt[ind]="• ОПЕРАЦИИ С ПУСТЫМИ СТРОКАМИ:";  ind++;

 if (count_212!=d)  { mSt[ind]="212. Удаление мусора из пустых строк  .  .  .  .  .  .  .  .	"+count_212;  ind++ }
 if (count_213!=d)  { mSt[ind]="213. Удаление формата \"подзаголовок\"   .  .  .  .  .  .  .	"+count_213;  ind++ }
 if (count_214!=d)  { mSt[ind]="214. Удаление формата \"автор текста\"  .  .  .  .  .  .  .  .	"+count_214;  ind++ }
 if (count_241!=d)  { mSt[ind]="241. Вставка между \"карманом\" и концом секции  	"+count_241;  ind++ }
 if (count_251!=d)  { mSt[ind]="251. Удаление второй пустой строки подряд .  .  .  .  .	"+count_251;  ind++ }
 if (count_252!=d)  { mSt[ind]="252. Удаление внешнего форматирования  .  .  .  .  .  .	"+count_252;  ind++ }
 if (count_253!=d)  { mSt[ind]="253. Удаление в \"body\" и \"fbw_body\"  .  .  .  .  .  .  .  .  .	"+count_253;  ind++ }
 if (count_262!=d)  { mSt[ind]="262. Удаление пустого \"body\" .  .  .  .  .  .  .  .  .  .  .  .  .	"+count_262;  ind++ }
 if (count_263!=d)  { mSt[ind]="263. Удаление пустых секций .  .  .  .  .  .  .  .  .  .  .  .  .	"+count_263;  ind++ }
 if (count_271!=d)  { mSt[ind]="271. Удаление на окраине разделов   .  .  .  .  .  .  .  .  .	"+count_271;  ind++ }
 if (count_272!=d)  { mSt[ind]="272. Удаление за краем разделов и подзаголовков	"+count_272;  ind++ }
 if (count_281!=d)  { mSt[ind]="281. Замена пустых строк в стихах на разрыв строф	"+count_281;  ind++ }
 if (count_311!=d)  { mSt[ind]="311. Удаление  посреди заголовка  .  .  .  .  .  .  .  .  .  .	"+count_311;  ind++ }
 if (count_401!=d)  { mSt[ind]="401. Удаление абсолютно пустых разделов   .  .  .  .  .	"+count_401;  ind++ }
 if (count_601!=d)  { mSt[ind]="601. Удаление возле картинки в \"кармане\" секций	"+count_601;  ind++ }
 if (count_611!=d)  { mSt[ind]="611. Вставка рядом с картинкой посреди секции  .  .	"+count_611;  ind++ }
 if (count_621!=d)  { mSt[ind]="621. Вставка между картинкой и границей секции	"+count_621;  ind++ }
 if (count_622!=d)  { mSt[ind]="622. Удаление между картинкой и границей секции	"+count_622;  ind++ }

 if (cTaT==ind-2) ind=ind-2;  //  Удаление двух последних строк, если нет пунктов в этом разделе

//  История
 if (VersionUp ||  HiCh  ||  d)  { mSt[ind]="";  ind++ }
 if (VersionUp  ||  d)                 { mSt[ind]="• Версия файла:  "+versionFile+"  ›››  "+newVersion;  ind++ }
 if (HiCh==1  ||  d)                    { mSt[ind]="• Добавлена новая строка в историю";  ind++ }
 if (HiCh==2  ||  d)                    { mSt[ind]="• Добавлены две строки в историю";  ind++ }
 if (HiCh==3  ||  d)                    { mSt[ind]="• Изменены данные в строке истории";  ind++ }

//  Сборка строк текущей даты и времени
 mSt[ind]="";  ind++;
 mSt[ind]= "• "+currentDate+" • "+currentTime+" •";  ind++;

//  Сборка строк пословицы
 mSt[ind]="";  ind++;
 mSt[ind]="-----------------------------------------------------------------------";  ind++;
 var reZit = new RegExp("([^ ].{0,50})(?=\\\s\\\s.{0,}|$)","g");   // Рег. выражение для разделения цитаты на строки.
 mSt=mSt.concat(Kn[Rn_(Kn.length)].replace(/ /g, "  ").match(reZit));   //  Добавление массива строк цитаты в основной массив.
 for (j=mSt.length-1; j>=ind; j--)  mSt[j]=" "+mSt[j];   //  Добавление отступа.
 //for (j=mSt.length-1; j>=ind; j--)  { mSt.splice(j+1, 0, ""+mSt[j].length) }   //  Добавление длины строк цитаты (отключено).
 ind = mSt.length;    //  Определение индекса.

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 ///  ВЫВОД ОКНА РЕЗУЛЬТАТОВ НА ЭКРАН

 var st2="";  //  текст результатов

 for  ( j=0; j!=ind; j++ )
        st2 += mSt[j]+"\n";  //  добавление элемента из массива


//  Вывод окна результатов
 MsgBox (st2);

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


}




                 ///  ИСТОРИЯ ИЗМЕНЕНИЙ
                 
//    v.1.0 — Создание скрипта — Александр Ка (27.03.2024)

//    v.1.1 — Исправлена ошибка с добавлением пустых строк — Александр Ка (10.06.2024)

//    v.1.2 — Коррекция метода удаления пустого заголовка — Александр Ка (13.07.2024)

//    v.1.3 — Александр Ка (17.10.2024)
// Добавлен универсальный дизайн окна результатов
// 100. Восстановление параграфов (вместо неработающей операции №101)
// удален №102. Перезапись параграфов (эта дополнительная операция уже не требуется)
// 103. Коррекция внутренних тегов вне параграфов (добавлен перенос тега в параграфы)
// 150. Добавление разрыва секции перед заголовком
// 201. Удаление повторных внутренних тегов в параграфе (добавлен полуавтомат для сложных случаев)
// 202. Добавление формата "Цитата" (дополнение к №201)
// Устранение замедления при выборе в FBE прозрачного символа для н/р пробела

//    v.1.4 — Александр Ка (18.10.2024)
// Исправлена старая ошибка в среде win7, которая приводила к удалению иллюстраций в тексте

//    v.1.5 — Александр Ка (30.11.2024)
// Исправлена ошибка, которая приводила к игнорированию прозрачных н/р пробелов
// 632. Перемещение картинки из "body" в отдельную секцию (новая операция)
// Коррекция диалогов
// Добавление настроек для операции добавления пустых строк между иллюстрациями и текстом в секции

//    v.1.6 — Александр Ка (12.12.2024)
// Добавление настроек для вставки пустых строк между иллюстрациями.
// Коррекция операции 213. Удаление формата "подзаголовок" (для пустой строки)
// Удаление курсора из текста при изменении структуры

//    v.1.7 — Александр Ка (30.03.2025)
// Добавление оп. №514. Объединение двух секций: заголовок+текст
// Удаление универсального дизайна
// Общая правка скрипта

//    v.1.8 - 1.9 — Мелочи — Александр Ка (02.04.2025)

//    v.1.10 — Добавление функции "повышения версии файла и запись в историю изменений" — Александр Ка (27.04.2025)

//    v.1.11 — Изменение функции "повышения версии файла и запись в историю изменений" — Александр Ка (19.05.2025)

//    v.1.12 — Александр Ка (25.07.2025)
// Улучшение операции №150 (Добавление разрыва секции перед заголовком)
// Добавление операций № 320, 321, 322 (обработка примечаний и комментариев)
// Улучшена функция перехода к найденному тексту или строке





