//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//             «Разночтения Ё/Е»
//  Скрипт предназначен для расстановки букв "ё"/"е" в словах, где возможно разночтение
// Скрипт тестировался в FBE v.2.7.8 (win XP, IE8 и win 7, IE11)
//  * История изменений в конце скрипта
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

function Run() {

 var ScriptName="«Разночтения Ё/Е»";
 var NumerusVersion="2.2";
 var Ts=new Date().getTime();
 var W=[];  var n=0;

//--------------------------------------------------------------------
                 ///  НАСТРОЙКИ
//--------------------------------------------------------------------

         //   •  Режим работы
 var Rezhim = 0;      // 0 ; 1 ; 2 //      ("0" — править всё, "1" — только Ёфикация, "2" — только деЁфикация)

         //   •  Показывать окно "Управление"
 var Upravlenie = 1;      // 0 ; 1 //      ("0" — отключить, "1" — показывать)

         //   •  Расположение найденного слова
 var Raspolozhenie = 82;      // проценты //       50% — середина окна с текстом книги;  больше/меньше 50% — выше/ниже середины.

// ---------------------------------------------------------------

         //   •  Максимум строк в окне результатов
//  * Скрипт постарается не превышать это значение, и при необходимости добавит необходимое количество страниц.

 var Vysota_teksta = 50;      // примерно 30-52 //      Ориентировочный максимум строк в окне результатов

// * Для монитора 1024х768 максимальная высота окна равна 52 строкам (в win XP) и 50 строк (в win 7).

// ---------------------------------------------------------------

         //   •  Автоматическое повышение версии файла и запись в историю изменений

 var Version_on_off = 1;      // 0 ; 1 //      ("0" — отключить, "1" — включить)

//  Добавлять, если не сделано ни одного исправления
 var Vsegda_on_off = 0;      // 0 ; 1 //      ("0" — отключить, "1" — включить)

//   Имя используемое в добавленной записи:
 var youName = "Зорро";

//  * Можно использовать почти любые символы. Исключения:   |  "  |  \  |    Но и любой из этих знаков можно добавить, если поставить перед ним наклонную черту ("\"), например: "\\" = "\"
//  ** Или можно оставить эти кавычки пустыми (""), тогда строка в истории будет без имени.

// ---------------------------------------------------------------

         //   •  Заменяемые слова

  //  Здесь можно добавить новые варианты замен, или удалить ненужные.
  //  Для удаления не обязательно удалять всю строку, достаточно отправить её в комментарий, добавив символы "//" в начале строки.

 W[n++] = ["але", "але оп",   "алё", "в телефон"];
 W[n++] = ["бабье", "царство",   "бабьё", "бабы"];
 W[n++] = ["бедра", "походка от бедра",   "бёдра", "стройные"];
 W[n++] = ["берег", "озера",   "берёг", "как зеницу ока"];

 W[n++] = ["берет", "шапка",   "берёт", "в оборот"];
 W[n++] = ["берете", "шапке",   "берёте", "в оборот"];

 W[n++] = ["боек", "резв",   "боёк", "ударный элемент механизма"];
 W[n++] = ["бревна", "два бревна",   "брёвна", "строительные"];
 W[n++] = ["ведра", "пол ведра",   "вёдра", "оцинкованные"];
 W[n++] = ["весел", "в приподнятом настроении",   "вёсел", "гребных"];
 W[n++] = ["весны", "в начале весны",   "вёсны", "многие вёсны"];
 W[n++] = ["все", "вместе",   "всё", "отлично"];
 W[n++] = ["всем", "постам",   "всём", "успешен во всём"];
 W[n++] = ["далеко", "не близко",   "далёко", "прекрасное"];
 W[n++] = ["жены", "три жены",   "жёны", "верные"];

 W[n++] = ["заем", "капустой",   "заём", "денежный"];
 W[n++] = ["запоем", "читать; пить",   "запоём", "песню"];

 W[n++] = ["звезды", "две звезды",   "звёзды", "яркие"];               //  Все звёзды (группа вне сортировки)
 W[n++] = ["квазизвезды", "две квазизвезды",   "квазизвёзды", "яркие"];
 W[n++] = ["кинозвезды", "две кинозвезды",   "кинозвёзды", "яркие"];
 W[n++] = ["порнозвезды", "две порнозвезды",   "порнозвёзды", "дешевые"];
 W[n++] = ["протозвезды", "две протозвезды",   "протозвёзды", "яркие"];
 W[n++] = ["радиозвезды", "две радиозвезды",   "радиозвёзды", "яркие"];
 W[n++] = ["сверхзвезды", "две сверхзвезды",   "сверхзвёзды", "яркие"];
 W[n++] = ["суперзвезды", "две суперзвезды",   "суперзвёзды", "яркие"];
 W[n++] = ["телезвезды", "две телезвезды",   "телезвёзды", "яркие"];

 W[n++] = ["истекшая", "о времени",   "истёкшая", "о жидкости"];
 W[n++] = ["истекшего", "о времени",   "истёкшего", "о жидкости"];
 W[n++] = ["истекшее", "о времени",   "истёкшее", "о жидкости"];
 W[n++] = ["истекшей", "о времени",   "истёкшей", "о жидкости"];
 W[n++] = ["истекшем", "о времени",   "истёкшем", "о жидкости"];
 W[n++] = ["истекшему", "о времени",   "истёкшему", "о жидкости"];
 W[n++] = ["истекшие", "о времени",   "истёкшие", "о жидкости"];
 W[n++] = ["истекший", "о времени",   "истёкший", "о жидкости"];
 W[n++] = ["истекшим", "о времени",   "истёкшим", "о жидкости"];
 W[n++] = ["истекшими", "о времени",   "истёкшими", "о жидкости"];
 W[n++] = ["истекших", "о времени",   "истёкших", "о жидкости"];
 W[n++] = ["истекшую", "о времени",   "истёкшую", "о жидкости"];

 W[n++] = ["крестного", "хода",   "крёстного", "отца"];
 W[n++] = ["крестном", "ходе",   "крёстном", "отце"];
 W[n++] = ["крестному", "ходу",   "крёстному", "отцу"];
 W[n++] = ["крестный", "ход",   "крёстный", "отец"];
 W[n++] = ["крестным", "ходом",   "крёстным", "отцом"];

 W[n++] = ["Лен", "обращение к Елене",   "Лён", "растение"];
 W[n++] = ["Лене", "обращение к Елене",   "Лёне", "обращение к Леониду"];
 W[n++] = ["Лень", "Неохота",   "Лёнь", "обращение к Леониду"];

 W[n++] = ["летом", "сезон года",   "лётом", "туда и обратно"];
 W[n++] = ["маркер", "пишущий прибор",   "маркёр", "служащий при бильярде"];
 W[n++] = ["масел", "эфирных",   "масёл", "кость; конечность"];
 W[n++] = ["мед", "сокращение слова медицинский",   "мёд", "продукт пчеловодства"];
 W[n++] = ["мел", "известняк",   "мёл", "веником"];
 W[n++] = ["моем", "очищаем",   "моём", "местоимение"];

 W[n++] = ["неба", "небосвода",   "нёба", "во рту"];
 W[n++] = ["небе", "небосводе",   "нёбе", "во рту"];
 W[n++] = ["небо", "небосвод",   "нёбо", "во рту"];
 W[n++] = ["небом", "небосводом",   "нёбом", "во рту"];

 W[n++] = ["нем", "глух и нем",   "нём", "это всё о нём"];

 W[n++] = ["нулевая", "под номером «ноль»",   "нулёвая", "новая"];
 W[n++] = ["нулевого", "под номером «ноль»",   "нулёвого", "нового"];
 W[n++] = ["нулевое", "под номером «ноль»",   "нулёвое", "новое"];
 W[n++] = ["нулевой", "под номером «ноль»",   "нулёвой", "новую"];
 W[n++] = ["нулевом", "под номером «ноль»",   "нулёвом", "новом"];
 W[n++] = ["нулевому", "под номером «ноль»",   "нулёвому", "новому"];
 W[n++] = ["нулевую", "под номером «ноль»",   "нулёвую", "новую"];
 W[n++] = ["нулевые", "под номером «ноль»",   "нулёвые", "новые"];
 W[n++] = ["нулевым", "под номером «ноль»",   "нулёвым", "новым"];
 W[n++] = ["нулевыми", "под номером «ноль»",   "нулёвыми", "новыми"];
 W[n++] = ["нулевых", "под номером «ноль»",   "нулёвых", "новых"];

 W[n++] = ["объем", "я вас не объем",   "объём", "шара"];

 W[n++] = ["оглашенная", "полоумная",   "оглашённая", "объявленная"];
 W[n++] = ["оглашенного", "полоумного",   "оглашённого", "объявленного"];
 W[n++] = ["оглашенное", "полоумное",   "оглашённое", "объявленное"];
 W[n++] = ["оглашенной", "полоумной",   "оглашённой", "объявленной"];
 W[n++] = ["оглашенном", "полоумном",   "оглашённом", "объявленном"];
 W[n++] = ["оглашенному", "полоумному",   "оглашённому", "объявленному"];
 W[n++] = ["оглашенную", "полоумную",   "оглашённую", "объявленную"];
 W[n++] = ["оглашенные", "полоумные",   "оглашённые", "объявленные"];
 W[n++] = ["оглашенный", "полоумный",   "оглашённый", "объявленный"];
 W[n++] = ["оглашенным", "полоумным",   "оглашённым", "объявленным"];
 W[n++] = ["оглашенными", "полоумными",   "оглашёнными", "объявленными"];
 W[n++] = ["оглашенных", "полоумных",   "оглашённых", "объявленных"];

 W[n++] = ["окунем", "с окунем на крючке",   "окунём", "в воду"];

 W[n++] = ["опознаем", "после",   "опознаём", "сейчас"];
 W[n++] = ["опознает", "после",   "опознаёт", "сейчас"];
 W[n++] = ["опознаете", "после",   "опознаёте", "сейчас"];
 W[n++] = ["опознаешь", "после",   "опознаёшь", "сейчас"];

 W[n++] = ["осел", "опустился",   "осёл", "ушастое животное"];

 W[n++] = ["осознаем", "после",   "осознаём", "сейчас"];
 W[n++] = ["осознает", "после",   "осознаёт", "сейчас"];
 W[n++] = ["осознаете", "после",   "осознаёте", "сейчас"];
 W[n++] = ["осознаешь", "после",   "осознаёшь", "сейчас"];

 W[n++] = ["отсек", "помещение",   "отсёк", "отрезал"];
 W[n++] = ["падеж", "грамматическая категория",   "падёж", "мор"];

 W[n++] = ["передохнем", "мор",   "передохнём", "отдых"];
 W[n++] = ["передохнет", "мор",   "передохнёт", "отдых"];
 W[n++] = ["передохнете", "мор",   "передохнёте", "отдых"];

 W[n++] = ["перепоем", "злоупотребление спиртным",   "перепоём", "песню"];
 W[n++] = ["погреб", "подвал",   "погрёб", "вёслами"];
 W[n++] = ["подъем", "капусту",   "подъём", "в гору"];
 W[n++] = ["поем", "капусты",   "поём", "песню"];
 W[n++] = ["поешь", "капусты",   "поёшь", "песню"];

 W[n++] = ["познаем", "после",   "познаём", "сейчас"];
 W[n++] = ["познает", "после",   "познаёт", "сейчас"];
 W[n++] = ["познаете", "после",   "познаёте", "сейчас"];
 W[n++] = ["познается", "после",   "познаётся", "сейчас"];
 W[n++] = ["познаешь", "после",   "познаёшь", "сейчас"];

 W[n++] = ["признаем", "после",   "признаём", "сейчас"];
 W[n++] = ["признаемся", "после",   "признаёмся", "сейчас"];
 W[n++] = ["признает", "после",   "признаёт", "сейчас"];
 W[n++] = ["признаете", "после",   "признаёте", "сейчас"];
 W[n++] = ["признаетесь", "после",   "признаётесь", "сейчас"];
 W[n++] = ["признается", "после",   "признаётся", "сейчас"];
 W[n++] = ["признаешь", "после",   "признаёшь", "сейчас"];
 W[n++] = ["признаешься", "после",   "признаёшься", "сейчас"];

 W[n++] = ["проем", "зубами дыру",   "проём", "дверной"];

 W[n++] = ["путевая", "накладная",   "путёвая", "дельная"];
 W[n++] = ["путевого", "обходчика; листа",   "путёвого", "дельного"];
 W[n++] = ["путевое", "оборудование",   "путёвое", "дельное"];
 W[n++] = ["путевой", "обходчик; лист",   "путёвой", "дельной"];
 W[n++] = ["путевом", "обходчике; листе",   "путёвом", "дельном"];
 W[n++] = ["путевому", "обходчику; листу",   "путёвому", "дельному"];
 W[n++] = ["путевую", "накладную",   "путёвую", "дельную"];
 W[n++] = ["путевые", "обходчики; листы",   "путёвые", "дельные"];
 W[n++] = ["путевым", "обходчиком; листом",   "путёвым", "дельным"];
 W[n++] = ["путевыми", "обходчиками; листами",   "путёвыми", "дельными"];
 W[n++] = ["путевых", "обходчиков; листов",   "путёвых", "дельных"];

 W[n++] = ["пчелы", "две пчелы",   "пчёлы", "медоносные"];

 W[n++] = ["распознаем", "после",   "распознаём", "сейчас"];
 W[n++] = ["распознает", "после",   "распознаёт", "сейчас"];
 W[n++] = ["распознаете", "после",   "распознаёте", "сейчас"];
 W[n++] = ["распознается", "после",   "распознаётся", "сейчас"];
 W[n++] = ["распознаешь", "после",   "распознаёшь", "сейчас"];

 W[n++] = ["ребра", "два ребра",   "рёбра", "свинные"];
 W[n++] = ["свеклы", "два свеклы",   "свёклы", "сахарные"];
 W[n++] = ["сверла", "стружка от сверла",   "свёрла", "алмазные"];
 W[n++] = ["седла", "выпал из седла",   "сёдла", "вьючные"];

 W[n++] = ["сел", "на стул",   "сёл", "деревень"];
 W[n++] = ["села", "на стул",   "сёла", "деревни"];

 W[n++] = ["сестры", "три сестры",   "сёстры", "родные"];
 W[n++] = ["слез", "со стула",   "слёз", "капли"];
 W[n++] = ["слезы", "две слезы",   "слёзы", "капали"];
 W[n++] = ["смел", "отважен",   "смёл", "веником"];

 W[n++] = ["совершенная", "идеальная",   "совершённая", "выполненная"];
 W[n++] = ["совершенного", "идеального",   "совершённого", "выполненного"];
 W[n++] = ["совершенное", "идеальное",   "совершённое", "выполненное"];
 W[n++] = ["совершенной", "идеальной",   "совершённой", "выполненной"];
 W[n++] = ["совершенном", "идеальном",   "совершённом", "выполненном"];
 W[n++] = ["совершенному", "идеальному",   "совершённому", "выполненному"];
 W[n++] = ["совершенную", "идеальную",   "совершённую", "выполненную"];
 W[n++] = ["совершенные", "идеальные",   "совершённые", "выполненные"];
 W[n++] = ["совершенный", "идеальный",   "совершённый", "выполненный"];
 W[n++] = ["совершенным", "идеальным",   "совершённым", "выполненным"];
 W[n++] = ["совершенными", "идеальными",   "совершёнными", "выполненными"];
 W[n++] = ["совершенных", "идеальных",   "совершённых", "выполненных"];

 W[n++] = ["стек", "хлыст",   "стёк", "в канализацию; компьютерный термин"];
 W[n++] = ["стекла", "из стекла и бетона; вода на пол",   "стёкла", "разноцветные"];

 W[n++] = ["Степ", "чечётка",   "Стёп", "обращение к Степану"];
 W[n++] = ["Степа", "чечётки",   "Стёпа", "обращение к Степану"];
 W[n++] = ["Степе", "чечётке",   "Стёпе", "обращение к Степану"];
 W[n++] = ["Степу", "чечётку",   "Стёпу", "обращение к Степану"];

 W[n++] = ["съем", "капусту",   "съём", "жилья"];

 W[n++] = ["Тема", "сочинения",   "Тёма", "обращение к Артёму"];
 W[n++] = ["Теме", "сочинения",   "Тёме", "обращение к Артёму"];
 W[n++] = ["Темой", "сочинения",   "Тёмой", "обращение к Артёму"];
 W[n++] = ["Тему", "сочинения",   "Тёму", "обращение к Артёму"];

 W[n++] = ["теплом", "с теплом и любовью",   "тёплом", "в тёплом доме"];

 W[n++] = ["узнаем", "после",   "узнаём", "сейчас"];
 W[n++] = ["узнает", "после",   "узнаёт", "сейчас"];
 W[n++] = ["узнаете", "после",   "узнаёте", "сейчас"];
 W[n++] = ["узнается", "после",   "узнаётся", "сейчас"];
 W[n++] = ["узнаешь", "после",   "узнаёшь", "сейчас"];

 W[n++] = ["чаек", "птиц",   "чаёк", "чай"];
 W[n++] = ["че", "буква; Че Гивара",   "чё", "что; чаво"];
 W[n++] = ["чем", "чем больше, тем лучше",   "чём", "о чём речь"];

 W[n++] = ["черт", "линий",   "чёрт", "рогатый"];
 W[n++] = ["черта", "ни черта; линия",   "чёрта", "рогатого"];
 W[n++] = ["черте", "линии",   "чёрте", "чёрте что"];
 W[n++] = ["черту", "линию",   "чёрту", "рогатому"];

 W[n++] = ["шлем", "велосипедный",   "шлём", "привет"];

 //   Сомнительные замены
// W[n++] = ["запорошенный", "",   "запорошённый", ""];     //  Сложный выбор
// W[n++] = ["позолоченный", "",   "позолочённый", ""];     //  Сложный выбор
// W[n++] = ["припорошенный", "",   "припорошённый", ""];     //  Сложный выбор
// W[n++] = ["уменьшенный", "",   "уменьшённый", "устар."];     //  Сложный выбор
// W[n++] = ["вселенная", "космос",   "вселённая", "квартира"];          //  Популярный и очень редкий случай (мешать будет)
// W[n++] = ["Королева", "снежная",   "Королёва", "фамилия"];       //  Без обработки всех фамилий - почти бесполезная замена
// W[n++] = ["перед", "до; лицевая сторона",   "перёд", "задом на перёд"];          //  Очень популярный и очень редкий случай (мешать будет)
// W[n++] = ["рек", "полноводных",   "рёк", "говорил"];          //  Очень популярный и очень редкий случай (мешать будет)
// W[n++] = ["солитер", "крупный бриллиант",   "солитёр", "ленточный червь"];
// W[n++] = ["стека", "хлыста",   "стёка", "компьютерный термин"];
// W[n++] = ["стекам", "хлыстам",   "стёкам", "компьютерный термин"];
// W[n++] = ["стеками", "хлыстами",   "стёками", "компьютерный термин"];
// W[n++] = ["стеках", "хлыстах",   "стёках", "компьютерный термин"];
// W[n++] = ["стеке", "хлысте",   "стёке", "компьютерный термин"];
// W[n++] = ["стеки", "хлысты",   "стёки", "компьютерный термин"];
// W[n++] = ["стеков", "хлыстов",   "стёков", "компьютерный термин"];
// W[n++] = ["стеком", "хлыстом",   "стёком", "компьютерный термин"];
// W[n++] = ["стеку", "хлысту",   "стёку", "компьютерный термин"];
// W[n++] = ["Тем", "Тем не менее",   "Тём", "обращение к Артёму"];          //  Очень популярный и очень редкий случай (мешать будет)

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОБЩИЕ ПЕРЕМЕННЫЕ

//   Неразрывный пробел из настроек FBE
 try  {
         var nbspEntity=window.external.GetNBSP();   //  Получаем выбранный символ неразрывного пробела.
         if (nbspEntity.charCodeAt(0) == 160)   //  Если используется стандартный символ...
                 nbspEntity = "&nbsp;";   //  то заменяем его на стандартный код.
         }
 catch(e) {            //  Если команда для получения символа н/р пробела вызывает ошибку...
         var nbspEntity="&nbsp;";   //  то используем стандартный код н/р пробела.
         }

 //  Счетчики в циклах
 var k=0;
 var j=0;
 var jj=0;
 var jjj=0;

  var fbwBody=document.getElementById("fbw_body");

 var s="";   //  Содержание строки

 var T_pause=0;  //  Продолжительность диалоговых пауз

 //  Ответ пользователя
 var otvet1;
 var otvet2;
 var otvet3;

 //  Для статистики
 var mSt=[];
 var ind=0;

 //  Для сортировки
 var k1=0;                  //  Индекс первого элемента в фрагменте массива.
 var k2=0;                  //  Индекс последнего элемента в фрагменте массива.
 var k_Midi=0;         //  Индекс для среднего элемента в фрагменте массива.
 var mSort = [" ", "№"];   //  Вспомогательный массив для сортировки.
 var sort = "";             //  Специальный текст, необходимый для правильной сортировки.

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// РАСШИРЕНИЕ СПИСКА ЗАМЕН

         //  Основной массив списка

 var M=[];   //  Отсортированный массив списка (основной).
 var LengthW = W.length;    //  Длина списка замен.
 mSort = [" ", "№"];   //  Очистка вспомогательного массива для сортировки.

 for (k=0; k<LengthW; k++) {    //  Перебор списка.

         //  Проверка пары на ошибки
         if ((W[k][0] + "  " + W[k][2]).search(/^(.*)[ЕЁеё](.*)  \1[ЕЁеё]\2$/) == -1) {
                 T_pause -= new Date().getTime();
                 otvet1 = AskYesNo ("Обнаружено недопустимое различие в паре #" + (k+1) + ":       \n" +
                         "•  " + W[k][0] + "  ›››  " + W[k][2] + "       \n" +
                         "(слова должны отличаться в букве «е»/«ё»)       \n\n" +
                         "◊  Остановить скрипт?       ");
                 T_pause += new Date().getTime();
                 if (otvet1) return;     //  При согласии на прерывание - выход из скрипта.
                 continue;         //  При отказе - пропуск ошибочной пары.
                 }
         if (W[k][0] == W[k][2]) {
                 T_pause -= new Date().getTime();
                 otvet1 = AskYesNo ("Обнаружены одинаковые слова в паре #" + (k+1) + ":       \n" +
                         "•  " + W[k][0] + "  ›››  " + W[k][2] + "       \n\n" +
                         "◊  Остановить скрипт?       ");
                 T_pause += new Date().getTime();
                 if (otvet1) return;     //  При согласии на прерывание - выход из скрипта.
                 continue;         //  При отказе - пропуск ошибочной пары.
                 }

         //  Создание основного массива списка
         for (j=0; j<3; j+=2) {    //  Внутренний цикл - первое и второе слово исходного списка меняются местами.
                 sort = W[k][j].toUpperCase().replace(/Ё(.*)/, "Е$1 ");    //  Специальный текст для сортировки
                 k1=0;                                      //  Исходное значение  для начала фрагмента.
                 k2=mSort.length-1;        //  Исходное значение  для конца фрагмента.
                 while (k2-k1 != 1) {                                        //  Цикл, который будет выполняться, пока фрагмент массива не будет состоять из двух элементов.
                         k_Midi = Math.floor((k2+k1)/2);          //  Получение индекса среднего элемента  внутри фрагмента.
                         if (sort >= mSort[k_Midi])    //  Если слово больше среднего элемента...
                                 k1=k_Midi;                                //   то сдвигаем начало фрагмента на место среднего элемента,
                             else  k2=k_Midi;                          //  а если нет - сдвигаем конец фрагмента.
                         }                                                     //  После того, как фрагмент уменьшился до двух элементов...
                 mSort.splice(k2, 0, sort);                            //  добавляем между этими элементами проверяемый текст
                 n=k2-1;
                 M.splice(n, 0, []);   //  и синхронно добавляем массив слова в сортированный массив.
                 if (j==0) {
                         M[n][0] = W[k][0];         //  Заменяемое слово (1-е)
                         M[n][1] = W[k][1];   //  Подсказка для заменяемого слова
                         M[n][2] = W[k][2];         //  Слово замены (2-е)
                         M[n][3] = W[k][3];   //  Подсказка для слова замены
                         }
                 if (j==2) {
                         M[n][0] = W[k][2];         //  Заменяемое слово (2-е)
                         M[n][1] = W[k][3];   //  Подсказка для заменяемого слова
                         M[n][2] = W[k][0];         //  Слово замены (1-е)
                         M[n][3] = W[k][1];   //  Подсказка для слова замены
                         }
                 M[n][4] = M[n][0].replace(/^(.).+/, "$1").toUpperCase() + M[n][0].replace(/^.(.+)/, "$1");    //  1-е слово с заглавной буквой в начале
                 M[n][5] = M[n][2].replace(/^(.).+/, "$1").toUpperCase() + M[n][2].replace(/^.(.+)/, "$1");    //  2-е слово с заглавной буквой в начале
                 M[n][6] = M[n][0].toUpperCase();        //  1-е слово заглавными буквами
                 M[n][7] = M[n][2].toUpperCase();        //  2-е слово заглавными буквами
                 M[n][8] = 0;             //  Счетчик замен
                 M[n][9] = new RegExp("^("+(M[n][0] + "  " + M[n][2]).replace(/^(.*)[ЕЁеё](.*)  \1[ЕЁеё]\2$/, "$1")+")(.)", "gi");   //  Рег.выражение для определения заменяемой буквы
                 if (j==0)
                         M[n][10] = true;   //  Замена  е ››› ё
                 if (j==2)
                         M[n][10] = false;   //  Замена  ё ››› е
                 M[n][11] = 0;   //  Счетчик найденных слов
                 M[n][12] = [];   //  Массив с найденными словами
                 }
         }

 var LengthM = M.length;    //  Длина списка замен

// MsgBox (M+""); return;


         //  Создание рег-выражения для поиска всех слов с разночтением.

 var f1;
 var allM="(^|[^А-яA-Za-zЁё0-9])(";                          //  Начало рег-выражения.
 for (k=1;  k<LengthM;  k+=2) {                   //  Последовательный просмотр списка замен.
         f1 = (M[k][0] + "  " + M[k][2]).replace(/^(.*)(.)(.*)  \1(.)\3$/g, "$1[$2$4]$3");    //  Создание основного фрагмента.
         if (f1.replace(/^(.).+/, "$1")!="[")           //  Если заменяется не первая буква
                 allM += "["+ f1.replace(/^(.).+/, "$1").toUpperCase() + f1.replace(/^(.).+/, "$1") + "]" + f1.replace(/^.(.+)/, "$1") + "|" + f1.toUpperCase() +"|";   //  Добавление очередного слова.
         if (f1.replace(/^(.).+/, "$1")=="[")         //  Если заменяется первая буква
                 allM += "["+ f1.replace(/^.(..).+/, "$1").toUpperCase() + f1.replace(/^.(..).+/, "$1") + "]" + f1.replace(/^....(.+)/, "$1") + "|" + f1.toUpperCase() +"|";   //  Добавление очередного слова.
         }
 allM = allM.replace(/\|$/, ")(?=[^А-яA-Za-zЁё0-9]|$)");     //  Окончание рег-выражения.
 var reAllM = new RegExp(allM,"g");      //  Формирование рег-выражения.
 var reAllM_ = '$1<LABEL style="border: 1px solid #005B32; padding-left: 1px; padding-right: 1px; padding-bottom: 1px;">$2</LABEL>';   //  Выделение тегами <LABEL>.

// MsgBox (allM); return;


         //  Массив списка для поиска

 var MM=[" ", "№"];   //  Отсортированный массив списка (для поиска).
 mSort = [" ", "№"];   //  Очистка вспомогательного массива для сортировки.

 for (k=0; k<LengthM; k++) {     //  Перебор списка.
         sort = M[k][6];    //  Специальный текст для сортировки
         k1=0;                                      //  Исходное значение  для начала фрагмента.
         k2=mSort.length-1;        //  Исходное значение  для конца фрагмента.
         while (k2-k1 != 1) {                                        //  Цикл, который будет выполняться, пока фрагмент массива не будет состоять из двух элементов.
                 k_Midi = Math.floor((k2+k1)/2);          //  Получение индекса среднего элемента  внутри фрагмента.
                 if (sort >= mSort[k_Midi])    //  Если слово больше среднего элемента...
                         k1=k_Midi;                                //   сдвигаем начало фрагмента на место среднего элемента,
                     else  k2=k_Midi;                          //  а если нет - сдвигаем конец фрагмента.
                 }                                                     //  После того, как фрагмент уменьшился до двух элементов...
         mSort.splice(k2, 0, sort);                            //  добавляем между этими элементами проверяемый текст
         MM.splice(k2, 0, []);   //  и синхронно добавляем массив слова в сортированный массив.
         MM[k2][0]=M[k][6];   //  Искомое слово.
         MM[k2][1]=k;           //  Номер искомого слова в основном массиве.
         }

// MsgBox (MM+""); return;

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 ///   Коррекция введенных настроек

 if (Rezhim != 1  &&  Rezhim != 2)  Rezhim = 0;
 if (Raspolozhenie < 0)  Raspolozhenie = 0;
 if (Raspolozhenie > 100)  Raspolozhenie = 100;

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 ///   Функция преобразования в код

 function inCode(text) {      //  Преобразование обычного текста в код.
         return  text.replace(/&/g, "&amp;").replace(/ /g, nbspEntity).replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/­/g, "&shy;");
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 ///  ФУНКЦИЯ ПОВЫШЕНИЯ ВЕРСИИ ФАЙЛА И ЗАПИСЬ В ИСТОРИЮ ИЗМЕНЕНИЙ

 function HistoryChange(Script_Name, youName) {


         // Получение раздела истории

// var fbwBody=document.getElementById("fbw_body");
 var History=fbwBody.firstChild;   //  Предполагаемый раздел истории.

 //  Поиск раздела "историй"
 while (History != null  &&  History.className != "history")    //  Пока не найдем настоящий раздел истории, или окажется, что истории нет в тексте...
         History = History.nextSibling;         //  переходим на следующий раздел.

//  Добавление раздела истории
 if (History==null)  {                 //   Если нет истории...
         History = document.createElement("DIV");     //   Создание нового раздела
         var Annotation=fbwBody.firstChild;
         while (Annotation!=null  &&  Annotation.className!="annotation") Annotation=Annotation.nextSibling;   //  Поиск аннотации к книге
         if (Annotation!=null)  Annotation.insertAdjacentElement("afterEnd",History);      //  Размещаем новый раздел    или после аннотации (если она есть)...
                 else  fbwBody.insertAdjacentElement("afterBegin",History);                //  ...или в начале "fbwBody"
         History.className = "history";      //  Присваиваем новому разделу    класс "история" и необходимые атрибуты
         History.setAttribute("xmlns:l", xlNS);    //  "xlNS" и "fbNS" - переменные из "main.js"
         History.setAttribute("xmlns:f", fbNS);
         History.insertAdjacentElement("beforeEnd",document.createElement("P"));     //  Добавляем пустую строку
         window.external.inflateBlock(History.lastChild)=true;
         }


         //  Создание массива с прошедшими датами

 var mDate=[];         //  Массив с прошедшими датами.
 var D = new Date().getTime();   //  Начальное значение даты.
 var fullDate;
 var Day;
 var Month;
 var Year;

 for (var j=0; j<10; j++) {              //  Запускаем цикл для получения недавних дат, в котором...
         fullDate = new Date(D);                         //  получаем полную дату,
         Day = fullDate.getDate();                            //  день месяца,
         Month = ("0" + (1+fullDate.getMonth())).replace(/^.*?(\d\d)$/g, "$1");   //  месяц,
         Year = fullDate.getFullYear();       //  год,
         mDate[j] = Day + "." + Month + "." + Year;             //  и заполняем массив текстом очередной даты (Д.ММ.ГГ).
         D -= 86400000;                       //  При этом каждый раз уменьшаем проверяемую дату на один день.
         }


         //  Поиск недавней записи в "истории"

 var povtorD = false;   //  Индикатор повторной обработки в последние 10 дней.
 var mP = History.getElementsByTagName("P");   //  Получение всех строк в "Истории".
 var s="";               //  Содержимое строки.
 var k=0;               //  Счетчик цикла.

fff:
 for (j=mP.length-1;  j>=0;  j--) {    //  Последовательный просмотр строк истории.
         s = mP[j].innerHTML;                //  Содержимое строки.
         for (k=0; k<10; k++) {                //  и запускаем цикл для проверки даты.
                 if (s.search(mDate[k]) !=-1) {   //  Если проверяемая дата есть в строке истории...
                         povtorD = true;                    //  то отмечаем это,
                         break fff;                            //  и прерываем оба цикла проверки.
                         }
                 }
         }


         //  Обновление записи в истории изменений

 try  { youName = fbeUserName }   //  Если есть строка:   var fbeUserName = "Имя";   в файле "main.js"  --  Изменение имени в соответствии с глобальной переменной.
 catch(e)  {}                                            //  Если глобальная переменная отсутствует - пропуск операции по изменению имени.

 var textYouName = inCode(youName+"");    //  Имя в тексте.
 if (youName!="")                           //  Если есть заполненное имя...
         textYouName += ", ";   //  то добавляем к текстовой записи запятую.

 Script_Name = inCode(Script_Name);    //  Имя скрипта текстом.

 var reHist00s = new RegExp("[^А-яЁёA-Za-z0-9]"+Script_Name+"[^А-яЁёA-Za-z0-9]","");   //  Стартовая.
 //  Добавление точки с запятой
 var reHist01 = new RegExp("(.[^…\\\?!\\\.,;:—])(\\\s|"+nbspEntity+")(— "+textYouName+mDate[k]+")","");
 var reHist01_ = "$1; $3";
 //  Добавление точки
 var reHist02 = new RegExp("(.[^…\\\?!\\\.,;:—])[,;:]{0,1}(\\\s|"+nbspEntity+")(— "+textYouName+mDate[k]+")","");
 var reHist02_ = "$1. $3";
 //  Добавление слова "Скрипт"
 var reHist03 = new RegExp("(.)(\\\s|"+nbspEntity+")(— "+textYouName+mDate[k]+")","");
 var reHist03_ = "$1 Скрипт: $3";
 //  Добавление имени скрипта
 var reHist04 = new RegExp("(.)(\\\s|"+nbspEntity+")(— "+textYouName+mDate[k]+")","");
 var reHist04_ = "$1 "+Script_Name+" $3";

 if (povtorD) {                                         //  Если найдена запись с недавней датой...
         if (s.search(reHist04) !=-1) {    //  и если в строке имя пользователя и дата записаны по форме: "— (Имя, Дата)"...
                 if (s.search(reHist00s) ==-1) {    //  то проверяем строку на наличие записи имени скрипта, и если этой записи нет...
                         if (s.search(/([Сс]крипт):/) !=-1)  s = s.replace(/([Сс]крипт):/g, "$1ы:");   //  то заменяем при необходимости слово "Скрипт" на "Скрипты",
                         if (s.search(reHist01) !=-1)  s = s.replace(reHist01, reHist01_);                   //  добавляем при необходимости точку с запятой,
                         if (s.search(/[Сс]крипты?:/) ==-1)  s = s.replace(reHist02, reHist02_).replace(reHist03, reHist03_);   //  добавляем при необходимости слово "Скрипт"
                         s = s.replace(reHist04, reHist04_);      //  и добавляем имя скрипта.
                         }
                 if (k != 0)                                                    //  Затем проверяем дату, и если она не сегодняшняя...
                         s = s.replace(mDate[k], mDate[0]);   //  то заменяем на сегодняшнюю.
                 if (mP[j].innerHTML != s) {                //  Затем проверяем изменилась ли строка истории, и если она изменилась...
                         mP[j].innerHTML = s;          //  то сохраняем её в тексте
                         HiCh=3;   //  и отмечаем это на индикаторе.
                         }
                 }
             else                                  // Если же есть недавняя дата, но запись сделана не по форме...
                 povtorD = false;   //  Объявляем, что недавняя дата - посторонняя, и надо повышать версию и добавлять новую строку в историю.
         }

 if (povtorD)  return;   //  Если производилась обработка записи в истории - выход из функции.


         //  Повышение версии

 var versionText = "";           //  Текст с версией в истории изменений.

 //  Проверка на валидность версии файла
 var ValidationVersion=(versionFile.length <=10  &&  versionFile.search(/^\d{0,10}(\.\d{1,8})?$/g) !=-1);    //  сравнение с шаблоном:  "цифры + (точка + цифры)"

 //   Изменение версии файла
 if (ValidationVersion) {
         if (versionFile =="")          //  Если версия не заполнена...
                 versionFile = "1.0";    //  то изменяем начальную версию на "1.0".
         if (versionFile.search(/^\d+$/g) !=-1)   //  Если версия без точки...
                 newVersion = versionFile + ".1";     //  то для новой версии добавляем ".1".
             else {                                                                                         //  Если в версии есть точка...
                     newVersion = +versionFile.replace(/^\d+\./g, "");  //  извлекаем цифры после точки,
                     newVersion++;                                                                                           //  увеличиваем полученное число на единицу
                     newVersion = versionFile.replace(/\.\d+$/g, "")+"."+newVersion;   //   и добавляем к нему первую группу цифр.
                     }
         if (newVersion.length <=10)                                        //  Если новая версия валидна...
                 document.getElementById("diVersion").value=newVersion;   //  то изменяем версию в файле,
                 VersionUp=true;                                                          //  отмечаем это на индикаторе
                 var versionText="v."+newVersion+" — ";    //  и создаем текст для истории.
         }


         //   Добавление строк в историю изменений

 var reHist11 = new RegExp("^(\\\s|"+nbspEntity+"){0,}$","");   //  Признак пустой строки.
 var reHist12 = new RegExp("(^|\\n)[^0-9]{0,12}"+versionFile.replace(/\./, "\\.")+"([^0-9]|$)","");   //  Поиск старой версии.

 //   Добавление строки с информацией о старой версии
 if (ValidationVersion  &&  History.innerText.search(reHist12)==-1) {       //  Если в истории нет записи о старой версии...
         if (History.lastChild.innerHTML.search(reHist11)==-1)                                               //  то проверяем наличие пустой строки в конце истории
                 History.insertAdjacentElement("beforeEnd",document.createElement("P"));       //  и если ее нет - добавляем новую.
         History.lastChild.innerHTML = "v."+versionFile+" — ?";  //  Затем добавляем в строку информацию о старой версии
         HiCh++;                                        //  и изменяем индикатор истории.
         }

 //   Добавление строки с информацией о новой версии
 if (History.lastChild.innerHTML.search(reHist11)==-1)                                   //  Если в конце истории нет готовой пустой строки...
         History.insertAdjacentElement("beforeEnd",document.createElement("P"));   //  то добавляем новую строку.
 History.lastChild.innerHTML = versionText+" Скрипт: "+Script_Name+" — "+textYouName+mDate[0];  //  Добавляем в строку информацию о новой версии.
 HiCh++;                       //  Изменяем индикатор истории.

 }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ФУНКЦИЯ "Генератор случайных чисел, с округлением"

 var T_random = Ts;   //  Показания времени для генератора случайных чисел.
 var rndN;

 function Rn_(rndN) {
         T_random += Math.random()*2000;                  //  Изменение ключевой переменной.
         return Math.floor(("0000000"+Math.tan(T_random)).replace(/[\.\-]/g, "").replace(/.+(\d\d\d\d\d\d)\d$/g, "0.$1")*rndN);  //  Генерация случайных чисел от 0 до "rndN".
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ФУНКЦИЯ ПЕРЕХОДА (расширенная версия, но без перемещения курсора)

 function GoTo_0(elem) {
         var b=elem.getBoundingClientRect();                     //  Получение координат элемента.
         var c=fbwBody.parentNode.getBoundingClientRect();    //  Получение координат раздела <BODY>.
         var wH=wHeight - 6;         //  Высота окна с текстом книги (с запасом по 3 пикселя по краям).
         var wW=wWidth;         //  Ширина окна с текстом книги.
         var h=b.bottom-b.top;                  //  Высота элемента (в пикселях).
         var Width=c.left;         //  Сдвиг вбок.

         if (b.right-c.left > wW) {      //  Если правый край элемента может выйти за границу окна...
                 if (b.right-b.left < wW)     //  то проверяем длину элемента, и если она меньше длины окна,
                         Width = b.right-wW;   //  то выставляем элемент впритык к правому краю окна,
                     else  Width = b.left;      //  а если больше - то выставляем элемент впритык к левому краю.
                 }

         if (h <= wH)          //  Если высота элемента меньше высоты окна...
                 window.scrollBy(Width, b.top - 3 - (wH-h)*(1-Raspolozhenie*0.01))   //  то выставляем элемент согласно указанному расположению,
             else  window.scrollBy(Width, b.top - 3);       //  а если нет - то выставляем элемент почти впритык к верхнему краю.
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ФУНКЦИЯ КОНВЕРТАЦИИ ВРЕМЕНИ  (мс  => мин., с)

 var tempus=0;
 var T;

 function time(T) {

         var Tmin  = Math.floor(T/60000);
         var TsecD = (T%60000)/1000;
         var Tsec = Math.floor(TsecD);

         if (Tmin ==0)
                 tempus = (+(TsecD+"").replace(/(.{1,5}).*/g, "$1")+"").replace(".", ",")+" сек";
             else {
                     tempus = Tmin+" мин";
                     if (Tsec !=0)
                             tempus += " " + Tsec+ " с" }

         return tempus;

         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ФУНКЦИЯ СКЛОНЕНИЯ ПО ПАДЕЖАМ В ЗАВИСИМОСТИ ОТ ЧИСЛА

 var ok=0;

 function pad(Numer) {
         var m1;
         var m2;
         var Numer;
         ok=2;
         m1=Numer % 10;
         m2=Numer % 100;
         if (m2<11 || m2>19) {
                 if (m1==1) ok=0;
                 else  if (m1==2 || m1==3 || m1==4) ok=1;    }
         return ok;
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ФУНКЦИЯ СОЗДАНИЕ И ОТОБРАЖЕНИЯ СТРАНИЦ

 if (Vysota_teksta<30)  Vysota_teksta=30;  // установка минимальной высоты


function PageF() {

 var Kolo=Vysota_teksta-2;   //  высота колонки (в конце сборки страниц могут добавиться 2 строки)
 var page;   // страницы


         //  Подсчет количества и высоты колонок в таблице с результатами обработки

 if (Vysota_teksta >= ind) {   // Если все строки могут поместиться на одной странице
         page=1;
         Kolo=ind;
         }
     else {         // иначе...
         page=Math.ceil(ind/Kolo);  //  подсчет количества страниц
         Kolo=Math.ceil(ind/page);  //  подсчет высоты колонки при равномерном распределении строк по страницам
         }

 while  ( ind <= Kolo*page)  { mSt[ind]="";  ind++ }  //  Добавление пустых строк до полного заполнения ими общей высоты во всех страницах


         // Распределение строк по страницам

 var mPage=[];   // массив страниц
 var _k=0;  // смещение строк

 for (n=0; n < page; n++) {
         mPage[n]="";
         for (k=0 ;  k<Kolo;  k++)
                 mPage[n]+=mSt[k+n*Kolo+_k]+"\n";        // Стандартное заполнение страницы
         if (page!=1) {
                 mPage[n]+="                                                                                         \n";
                 if (n!=page-1)  mPage[n]+="◊  Стр. "+(n+1)+"  ◊  Показать  следующую  страницу?";
                         else  mPage[n]+="◊  Стр. "+(n+1)+" (последняя)  ◊  Закрыть окно?";
                 }
         }


         // Вывод страниц с результатами на экран

 otvet1 = true;
 n=0;

 while (otvet1) {        // Цикл для страниц
         if (page == 1) {
                 T_pause -= new Date().getTime();
                 MsgBox (mPage[0]);
                 T_pause += new Date().getTime();
                 break;
                 }
         T_pause -= new Date().getTime();
         otvet1 = AskYesNo (mPage[n]);
         T_pause += new Date().getTime();
         n++;
         if (n == page)  {
                 n=0;
                 otvet1 = !otvet1;
                 }
         }

 }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ПРОВЕРКА РЕЖИМА

 if (fbwBody.style.display == "none") {
         window.external.SetStatusBarText("  •  Скрипт "+ScriptName+" v." + NumerusVersion + " можно запустить только в режиме «B» (Дизайн)");
         return;
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ПОИСК СЛОВ С РАЗНОЧТЕНИЕМ

 window.external.BeginUndoUnit(document, ScriptName + " v."+NumerusVersion);    // Начало записи в систему отмен.

 var mP = fbwBody.getElementsByTagName("P");     //  Получение всех строк "fbw_body".
 var mPL = mP.length;       //  Получение количества строк.
 var ptr;      //  Отдельная строка.
 var mElem=[];   var elem1="";   var elem2="";   //  Для элементов <LABEL>

 //  Полное удаление формата <LABEL> в боди (на всякий случай).
 mElem=fbwBody.getElementsByTagName("LABEL");           //  Получение всех узлов <LABEL> в "fbw_body".
 for (jj=mElem.length-1; jj>=0; jj--)
         mElem[jj].removeNode(false);      //  Удаление формата <LABEL>.

 //  Полное удаление формата <FONT> в боди (на всякий случай).
 mElem=fbwBody.getElementsByTagName("FONT");           //  Получение всех узлов <FONT> в "fbw_body".
 for (jj=mElem.length-1; jj>=0; jj--)
         mElem[jj].removeNode(false);      //  Удаление формата <FONT>.

 // Для подсчета всех слов в книге
 var reW_body = new RegExp("(^|\\\s|"+nbspEntity+").{0,}?[А-яA-Za-zЁё].{0,}?(?=\\\s|"+nbspEntity+"|$)","g");
 var count_W_body = 0;

         //  Поиск и добавление слов с разночтением в основной массив

 for (j=0;  j<mPL;  j++) {        //  Последовательный просмотр строк текста.
         ptr = mP[j];             //  Сохранение текущей строки.
         if (ptr.innerText.search(reW_body)!=-1)
                 count_W_body+=ptr.innerText.match(reW_body).length;   //  Все слова книги (после пригодится)
         s=ptr.innerHTML;    // Сохранение содержимого строки.
         if (s.search(reAllM)!=-1) {
                 s=s.replace(reAllM, reAllM_);       //  Выделяем все слова с разночтением тегами <LABEL>
                 ptr.innerHTML=s;             //  и сохраняем измененную строку в структуре текста.
                 mElem=ptr.getElementsByTagName("LABEL");     //  Находим и сохраняем в массиве все узлы <LABEL>.
                aaa:
                 for (jj=0; jj<mElem.length; jj++) {         //  Последовательный просмотр узлов <LABEL>.
                         elem1 = mElem[jj].innerHTML;         //  Содержимое узла <LABEL>.
                         elem2 = elem1.toUpperCase();   //  Стандартизируем слово, добавляя для этого капс.
                         k1=0;                                      //  Исходное значение  для начала фрагмента.
                         k2=MM.length-1;        //  Исходное значение  для конца фрагмента.
                         while (k2-k1 != 1) {                                        //  Цикл, который будет выполняться, пока фрагмент массива не будет состоять из двух элементов.
                                 k_Midi = Math.floor((k2+k1)/2);          //  Получение индекса среднего элемента  внутри фрагмента.
                                 if (elem2 == MM[k_Midi][0]) {     //  Если проверяемый текст уже есть в сортированном массиве...
                                         M[MM[k_Midi][1]][11]++;                          //  то увеличиваем счетчик для этого слова в основном массиве,
                                         M[MM[k_Midi][1]][12].push(mElem[jj]);   //  добавляем в ряд массивов элемент <LABEL> с этим словом
                                         continue aaa;                                   //  и переходим к следующему слову.
                                         }
                                 if (elem2 > MM[k_Midi][0])    //  Если слово больше среднего элемента...
                                         k1=k_Midi;                                //   то сдвигаем начало фрагмента на место среднего элемента,
                                     else  k2=k_Midi;                          //  а если нет - сдвигаем конец фрагмента.
                                 }
                         }
                 }
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// СТАТИСТИКА СЛОВ С РАЗНОЧТЕНИЕМ

 var razdelitel="· · · · · · · · · · · · · · · · · · · · · · · ·";   //  Разделитель
 var count_w01=0;         //  Счетчик всех слов разночтения
 var count_jo01=0;         //  Счетчик ёфицированных слов
 var count_gr=0;          //  Счетчик групп из одинаковых слов
 mSt=[];                //  Очистка массива строк статистики
 ind=0;           //  Обнуление индекса строк

 var slov = ["слово", "слова", "слов"];        //  Спряжение слов
 var gruppah = ["группе", "группах", "группах"];

 mSt[ind++]="  Статистика слов с разночтением";
 mSt[ind++]="-----------------------------------------------------------";

 for (k=0; k<LengthM; k++)    //  Последовательный просмотр списка замен.
         if (M[k][11] !=0) {           //  Если слово есть в тексте...
                 count_gr++;                       //  то увеличиваем счетчик групп,
                 count_w01+=M[k][11];        //  счетчик всех слов разночтения,
                 if (k*0.5 != Math.floor(k*0.5))   //  а если слово с нечетным номером,
                         count_jo01+=M[k][11];      //  то и счетчик ёфицированных слов.
                 }

 mSt[ind++] = "Найдено   .  .  .  .	" + count_w01 + " " + slov[pad(count_w01)] + " в " + count_gr + " " + gruppah[pad(count_gr)];
 mSt[ind++] = "Ёфикация .  .  .  .	" + (+((count_jo01/
                              count_w01*100+"").replace(/(^[0\.]*....).+/, "$1").replace(/(^0\.0*\d\d).+/, "$1")) + "").replace(/(\.)/, ",") + "%";

 mSt[ind++]="                                                                                         ";

 for (k=0; k<LengthM; k+=2)    //  Последовательный просмотр списка замен с буквой  Е.
         if (M[k][11] !=0)            //  Если слово есть в тексте...
                 mSt[ind++]= M[k][11] + "  —	" + M[k][0];   //  то добавляем новую строку.

 if (mSt[ind-1].search(/^ *$/) ==-1)    //  Если последняя строка не пустая...
         mSt[ind++] = razdelitel;   //  то добавляем разделитель.

 for (k=1; k<LengthM; k+=2)    //  Последовательный просмотр списка замен с буквой  Ё.
         if (M[k][11] !=0)           //  Если слово есть в тексте...
                 mSt[ind++]= M[k][11] + "  —	" + M[k][0];   //  то добавляем новую строку.

 if (mSt[ind-1] == razdelitel)  ind--;    //  Удаляем ненужный разделитель.
 if (mSt[ind-1].search(/^ *$/) !=-1)  ind--;    //  Удаляем последнюю пустую строку.

 if (count_w01 != 0)    //  Если в списке есть слова...
         PageF();      //  то запускаем функцию для создания страниц.

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------

                 ///   Окно "Управление"

 var upravlenieText =
         " • УПРАВЛЕНИЕ \n\n\n"+
         " «Да» – разрешить замену \n"+
         " «Нет» – отказаться от замены \n"+
         " «Отмена» – отказаться от группы замен \n\n"+
         " Минус (дефис) в поле ввода + кнопка «Да» – \n"+
         "    отменить последнее действие \n\n"+
         " Несколько минусов – \n"+
         "    отмена нескольких действий \n\n"+
         " Ввод любого другого текста – \n"+
         "    прерывание обработки слов с разночтением. \n";

 if (Upravlenie != 0  &&  count_w01 != 0) {    //  Если включено отображение "управления"...
         T_pause -= new Date().getTime();
         MsgBox (upravlenieText);              //  то создаем окно сообщения
         T_pause += new Date().getTime();    //  и отмечаем время, в течении которого отображалось окно.
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ПОЛУАВТОМАТИЧЕСКИЕ ЗАМЕНЫ СЛОВ С РАЗНОЧТЕНИЕМ

 var mFONT=[];                  //  Массив строк с метками <FONT>
 var otvet_txt="";   var msgTitle="";   var msg="";   var count_msg=0;   //  Для диалога
 var otmena = false;    //  Индикатор кнопки "Отмена"
 var exit = false;     //  Индикатор прерывания скрипта
 var Lj;    //  Количество найденных строк.

 //  Массивы для отмен действий.
 var mUndo_k=[];   //  Массив с номерами групп замен.
 var mUndo_j=[];   //  Массив с номерами замен.
 var mUndo_Lj=[];   //  Массив с длинами групп.
 var mUndo_s=[];   //  Массив исходных слов.
 var mUndo_count=[];   //  Массив значений счетчика замен.
 var mUndo_msg=[];   //  Массив значений счетчика окон.
 var LU=0;   //  Длина массива отмен.

 var fbwBodyMargin=false;   //  Индикатор добавления полей

 if (count_w01 != 0) {   //  Если в списке есть слова...
         var wHeight = window.external.GetViewHeight();
         var wWidth = window.external.GetViewWidth();
         fbwBody.style.paddingTop = wHeight + "px";        //  то добавляем внутренние поля.
         fbwBody.style.paddingBottom = wHeight + "px";
         fbwBodyMargin=true;
         }

 for (k=0; k<LengthM; k++) {    //  Последовательный просмотр списка замен.
         if (M[k][10]  &&  Rezhim == 2)          //  Если отключена Ёфикация и на очереди слово с "е"...
                 continue;                      //  то пропускаем этот шаг цикла.
         if (! M[k][10]  &&  Rezhim == 1)        //  Если отключена деЁфикация и на очереди слово с "ё"...
                 continue;                      //  то пропускаем этот шаг цикла.

         if (exit)  break;         //  Выход из цикла при включении механизма прерывания скрипта.

         if (M[k][10]  &&  Rezhim == 0)         //  Если обрабатывается группа замены е ››› ё, и выбран основной режим скрипта...
                 mFONT=[];         //  то очищаем спец. массив для сохранения строк с замененными словами.

         Lj = M[k][12].length;    //  Длина массива найденных слов.
         count_msg=1;            //  Счетчик окон.
         otmena = false;             //  Кнопка "Отмена" ещё не нажата.

         for (j=0; j<Lj; j++) {                   //  Последовательный просмотр узлов <LABEL>.
                 if (otmena  ||  exit)  break;         //  Выход из цикла при нажатии кнопки "Отмена" или  при включении механизма прерывания скрипта.
                 mElem=M[k][12];         //  Массив группы с узлами <LABEL>.
                 elem1=mElem[j].innerHTML;         //  Содержимое узла <LABEL>

                switch (elem1) {         //  Для определенной формы заменяемого текста выбираем аналогичное слово замены:
                        case M[k][0]:  elem2 = M[k][2];  break;    //  запись строчными буквами,
                        case M[k][4]:  elem2 = M[k][5];  break;    //  запись начинается с заглавной буквы,
                        case M[k][6]:  elem2 = M[k][7];  break;    //  запись заглавными буквами,
                        default:   continue;                      //  для остальных форм замена отклоняется (такой случай невозможен, но вдруг...).
                        }

                 mUndo_k[LU] = k;          //   Добавление данных в массивы "отмены".
                 mUndo_j[LU] = j;
                 mUndo_Lj[LU] = Lj;
                 mUndo_s[LU] = elem1;
                 mUndo_count[LU] = M[k][8];
                 mUndo_msg[LU] = count_msg;
                 LU++;

                 msgTitle = "•  " + M[k][0] + "  ›››  " + M[k][2] + "  —  " + count_msg + " / " + M[k][11];  //  Создаем текст заголовка окна.
                 msg = " ◊  Найден текст:	" + elem1;   //  Начинаем создавать текст в окне (начало первой строки).
                 if (M[k][1])  msg += " (" + M[k][1] + ")";    //  Если есть подсказка для заменяемого слова - добавляем её.
                 msg += "\n ◊  Заменить на:	" + elem2;   //  Создаем начало второй строки.
                 if (M[k][3])  msg += " (" + M[k][3] + ")";    //  Если есть подсказка для слова-замены - добавляем её.

                 mElem[j].style.color="#005B32";          // Добавляем зеленый цвет для слова,
                 mElem[j].style.backgroundColor="#EDEDED";    //  фон (серый),
                 mElem[j].style.fontSize="110%";         //  увеличиваем размер шрифта.
                 if (M[k][10])  mElem[j].style.border = "2px solid #A00000";    //  Красная рамка для замен е ››› ё,
                     else  mElem[j].style.border = "2px solid #0053A0";                 //  синяя рамка для замен ё ››› е.
                 mElem[j].innerHTML=mElem[j].innerHTML.replace(M[k][9], '$1<FONT style="color: #932222">$2</FONT>');   //  Выделяем заменяемую букву.

                 GoTo_0(mElem[j]);       //  Переходим на узел <LABEL>.
                 T_pause -= new Date().getTime();
                 otvet_txt = window.external.InputBox(msg, msgTitle, "");       //  Диалоговое окно, запись введенного текста.
                 T_pause += new Date().getTime();                                  //  Отмечаем время, в течении которого отображалось окно.
                 otvet1 = window.external.GetModalResult();    //  Возвращение кнопки ответа.

                 mElem[j].style.border = "1px solid #005B32";        //  Изменяем рамку выделения.
                 mElem[j].style.removeAttribute("color");                          //  Очищаем цвет слова.
                 mElem[j].style.removeAttribute("backgroundColor");     //  Очищаем фон.
                 mElem[j].style.removeAttribute("fontSize");                             //  Возвращаем исходный размер шрифта.
                 mElem[j].innerHTML = mElem[j].innerHTML.replace(/<\/?FONT[^>]*>/g, "");   //  Удаляем форматирование <FONT> в слове.

                 if (otvet_txt.search(/^-*$/) ==-1) {         //  Если введен любой текст кроме минусов...
                         T_pause -= new Date().getTime();
                         exit = AskYesNo ("◊  Прервать обработку слов с разночтением?       ");     //  то спрашиваем,
                         T_pause += new Date().getTime();    //  отмечаем время, в течении которого отображалось окно,
                         j--;                          //  возвращаем проверяемое слово
                         if (exit)  break;     //  и в зависимости от ответа, либо выходим из внутреннего цикла, и тем самым начинаем механизм выхода из скрипта,
                             else  continue;    //  либо переходим на повторение шага.
                         }

                 if (otvet_txt.search(/^\-+$/) !=-1) {     //  Если введен один или несколько минусов...
                         jjj=otvet_txt.match(/\-/g).length + 1;   //  то считаем минусы.
                         for (; jjj>0  &&  LU>0; jjj--) {     //  Запускаем цикл для построчных отмен.
                                 LU--;                      //  Уменьшаем номер отмены на единицу.
                                 k = mUndo_k[LU];    //  Возвращаем сохраненное значение номера для группы замен.
                                 j = mUndo_j[LU];                //  Возвращаем номер слова в массиве с найденными словами.
                                 Lj = mUndo_Lj[LU];                //  Возвращаем длину группы замен.
                                 M[k][12][j].innerHTML = mUndo_s[LU];   //  Возвращаем исходное слово.
                                 M[k][8] = mUndo_count[LU];            //  Возвращаем значение счетчика замен.
                                 count_msg = mUndo_msg[LU];      //  Возвращаем значение счетчика окон.
                                 }
                         j--;        //  Делаем поправку на то, что при возврате к началу цикла, номер строки будет увеличен,
                         continue;      //  и возвращаемся к началу цикла обработки одной группы замен.
                         }

                 if (otvet1 == 2)  { otmena = true;  break }    // "Отмена":  выход из цикла.

                 if (otvet1 == 6) {                                                  // "Да":
                         mElem[j].innerHTML = elem2;          //  Заменяем слово.
                         if (M[k][10]  &&  Rezhim == 0) {        //   Если это замена вида "е ››› ё", то чтобы следующий вид (если он возможен) "не заметил" измененное слово...
                                 mElem[j].innerHTML=mElem[j].innerHTML.replace(new RegExp("([Ёё])",""), '<FONT style="font-size: 100%">$1</FONT>');   //  помечаем слово
                                 mFONT.push(mElem[j]);      //   и добавляем слово с пометками в массив.
                                 }
                         M[k][8]++;      //  Увеличиваем счетчик замен.
                         }

                 count_msg++;      //  Увеличиваем счетчик окон.
                 }

         if (! M[k][10]  &&  Rezhim == 0)        //   Если замена вида "ё ››› е" пройдена (т.е. метки больше не понадобятся)...
                 for (j=mFONT.length-1; j>=0; j--)
                         mFONT[j].innerHTML = mFONT[j].innerHTML.replace(/<\/?FONT[^>]*>/g, "");      //  то удаляем формат <FONT> в каждом сохраненном слове.
         }

 for (k=0; k<LengthM; k++)     //  Последовательный просмотр списка замен.
         for (j=M[k][12].length-1; j>=0; j--)
                 M[k][12][j].removeNode(false);      //  Полное удаление всего добавленного формата <LABEL>.

 var count_all_1=0;    //  Счетчик всех замен разночтения.
 for (k=0; k<LengthM; k++)
         count_all_1 += M[k][8];   //  Суммирование.

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ПОИСК ЁФИЦИРОВАННЫХ СЛОВ БЕЗ РАЗНОЧТЕНИЯ

 var count_all_2 = 0;     //  Счетчик деЁфицированных слов.

 var reJo = new RegExp("(^|[^А-яA-Za-zЁё0-9])([А-яЁё]*[Ёё][А-яЁё]*)(?=[^А-яA-Za-zЁё0-9]|$)","g");   //  рег-выражение для поиска ёфицированных слов
 var reJo_ = '$1<LABEL style="border: 1px solid #005B32; padding-left: 1px; padding-right: 1px; padding-bottom: 1px;">$2</LABEL>';   //  и их выделение тегами <LABEL>.
//  var mElem=[];   var elem1="";   var elem2="";   //  Для элементов <LABEL>  //  (повтор)

 //  Создание рег-выражения для поиска всех ёфицированных слов с разночтением.
 var allMJo="^(";                          //  Начало рег-выражения.
 for (k=1;  k<LengthM;  k+=2)    //  Последовательный просмотр списка замен.
         allMJo += M[k][0]+"|";                  //  Добавление очередного слова.
 allMJo = allMJo.replace(/\|$/, ")$");     //  Окончание рег-выражения.
 var reAllMJo = new RegExp(allMJo,"i");   //  Формирование рег-выражения.

 var mJo_word = [" ", "№"];       //  Массив для слов.
 var mJo_count = [" ", "№"];      //  Массив для счетчиков количества одного слова.
 var mJo_elem = [" ", "№"];       //  Массив для массивов с одинаковыми словами.
 mSort = [" ", "№"];   //  Очистка вспомогательного массива для сортировки.

 for (j=0;  j<mPL;  j++) {        //  Последовательный просмотр строк текста книги.
         ptr = mP[j];             //  Сохранение текущей строки.
         s=ptr.innerHTML;    // Сохранение содержимого строки.
         if (s.search(/[Ёё]/)!=-1) {         //  Если в строке есть буква ё, то...
                 s=s.replace(reJo, reJo_);       //  Выделяем все слова, содержащие эту букву тегами <LABEL>
                 ptr.innerHTML=s;             //  и сохраняем измененную строку в структуре текста.
                 mElem=ptr.getElementsByTagName("LABEL");     //  Находим и сохраняем в массиве все узлы <LABEL>.
                aaa:
                 for (jj=mElem.length-1; jj>=0; jj--) {         //  Последовательный просмотр узлов <LABEL>.
                         elem1 = mElem[jj].innerHTML;         //  Содержимое узла <LABEL>.
                         if (elem1.length == 1  ||  elem1.search(reAllMJo)!=-1) {   //  Если узел <LABEL> содержит только одну букву, или уже известное слово из списка "разночтений"...
                                 mElem[jj].removeNode(false);     //  то удаляем теги у этого текста
                                 continue;          //  и переходим к следующему узлу.
                                 }
                         elem1 = elem1.replace(/^(.).+/, "$1").toUpperCase() + elem1.replace(/^.(.+)/, "$1");   //  Стандартизируем слово, добавляя для этого капс первой буквы.
                         elem2 = elem1.replace(/Ё/g, "Е№").replace(/ё/g, "е№");   //  Адаптируем слово для сортировки.

                                 //  Сортировка и сборка списка ёфицированных слов без разночтения
                         k1=0;                                      //  Исходное значение  для начала фрагмента.
                         k2=mSort.length-1;        //  Исходное значение  для конца фрагмента.
                         while (k2-k1 != 1) {                                        //  Цикл, который будет выполняться, пока фрагмент массива не будет состоять из двух элементов.
                                 k_Midi = Math.floor((k2+k1)/2);          //  Получение индекса среднего элемента  внутри фрагмента.
                                 if (elem2 == mSort[k_Midi]) {     //  Если проверяемый текст уже есть в сортированном массиве...
                                         mJo_count[k_Midi]++;                          //  то увеличиваем счетчик для этого слова,
                                         mJo_elem[k_Midi].push(mElem[jj]);   //  добавляем в ряд массивов элемент <LABEL> с этим словом
                                         continue aaa;                                   //  и переходим к следующему слову.
                                         }
                                 if (elem2 > mSort[k_Midi])    //  Если слово больше среднего элемента...
                                         k1=k_Midi;                                //   то сдвигаем начало фрагмента на место среднего элемента,
                                     else  k2=k_Midi;                          //  а если нет - сдвигаем конец фрагмента.
                                 }                                                     //  После того, как фрагмент уменьшился до двух элементов...
                         mSort.splice(k2, 0, elem2);    //  то добавляем между этими элементами проверяемый текст,
                         mJo_word.splice(k2, 0, elem1);    //  то добавляем между этими элементами проверяемый текст,
                         mJo_count.splice(k2, 0, 1);             //  добавляем в массив счетчиков количество этого слова ("1"),
                         mJo_elem.splice(k2, 0, []);                 //  добавляем в массив с массивами элементов <LABEL> новый массив
                         mJo_elem[k2].push(mElem[jj]);         //   и добавляем в этот новый массив первый элемент - узел <LABEL> с ёфицированным словом внутри.
                         }
                 }
         }

 mJo_word.pop();    //  Удаление первых и последних элементов у массивов списка.
 mJo_word.shift();
 mJo_count.pop();
 mJo_count.shift();
 mJo_elem.pop();
 mJo_elem.shift();

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// СТАТИСТИКА ЁФИЦИРОВАННЫХ СЛОВ БЕЗ РАЗНОЧТЕНИЯ

 mSt=[];          //  Очистка массива строк статистики
 ind=0;           //  Обнуление индекса строк
 var count_jo02=0;        //  Счетчик всех слов
 var mLength = mJo_word.length;    //  Длина массива списка (= количество групп из одинаковых слов).

 mSt[ind++]="  Статистика\n  ёфицированных слов без разночтения";
 mSt[ind++]="-----------------------------------------------------------";

 for (k=0; k<mLength; k++)
         count_jo02 += mJo_count[k];     //  Подсчет всех найденных слов.

 mSt[ind++] = "Найдено   .  .  .  .	" + count_jo02 + " " + slov[pad(count_jo02)] + " в " + mLength + " " + gruppah[pad(mLength)];
 mSt[ind++] = "Ёфикация .  .  .  .	" + (+((count_jo02/
                              (count_W_body-count_w01)*100+"").replace(/(^[0\.]*....).+/, "$1").replace(/(^0\.0*\d\d).+/, "$1")) + "").replace(/(\.)/, ",") + "%";

 mSt[ind++]="                                                                                         ";

 for (k=0; k<mLength; k++)    //  Последовательный просмотр списка
         mSt[ind++]= mJo_count[k] + "  —	" + mJo_word[k];   //  и добавление каждого слова отдельной строкой в текст статистики.

 if (mLength != 0)    //  Если есть список слов...
         PageF();      //  то запускаем функцию для создания страниц.

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ПОЛУАВТОМАТИЧЕСКАЯ деЁФИКАЦИЯ СЛОВ БЕЗ РАЗНОЧТЕНИЯ

if (Rezhim != 1  &&  mLength != 0) {     //   Если есть список слов, и включен режим, где есть деЁфикация, то...

 T_pause -= new Date().getTime();
 otvet1 = AskYesNo("◊  ДеЁфицировать эти слова?       ");       //  Диалоговое окно, запись введенного текста.
 T_pause += new Date().getTime();               //  Отмечаем время, в течении которого отображалось окно.

 if (otvet1) {            //  Если получено разрешение на деЁфикацию...
         T_pause -= new Date().getTime();
         otvet2 = AskYesNo("◊  Выборочно? \n\n" +
                 "• ДА  —	Выборочно \n" +
                 "• НЕТ  —	ДеЁфицировать всё       ");       //  Диалоговое окно, запись введенного текста.
         T_pause += new Date().getTime();    //  Отмечаем время, в течении которого отображалось окно.
         }

 if (otvet1  &&  !otvet2) {          //  Если получено разрешение на деЁфикацию всех слов без исключений...
         for (k=0; k<mLength; k++) {
                 for (j=mJo_elem[k].length-1;  j>=0;  j--) {
                         mJo_elem[k][j].innerHTML = mJo_elem[k][j].innerHTML.replace(/Ё/g, "Е").replace(/ё/g, "е");    //  то заменяем ё на е во всех найденных словах,
                         mJo_elem[k][j].removeNode(false);           //  удаляем теги <LABEL>
                         }
                 }
         count_all_2 = count_jo02;                //  и фиксируем количество изменений в счетчике.
         }

 if (otvet1  &&  otvet2) {          //  Если получено разрешение на выборочную деЁфикацию, то...

         //   Окно "Управление"
         upravlenieText =
                 " • УПРАВЛЕНИЕ \n\n\n"+
                 " «Да» – разрешить изменение \n"+
                 " «Нет» – отказаться от изменения \n"+
                 " «Отмена» – прерывание деЁфикации \n\n"+
                 " Минус (дефис) в поле ввода + кнопка «Да» – \n"+
                 "    отменить последнее действие \n\n"+
                 " Несколько минусов – \n"+
                 "    отмена нескольких действий \n\n"+
                 " Ввод любого другого текста – \n"+
                 "    прерывание деЁфикации. \n";
         if (Upravlenie != 0  &&  mLength != 0) {    //  Если включено отображение "управления", и есть список слов...
                 T_pause -= new Date().getTime();
                 MsgBox (upravlenieText);              //  то создаем окно сообщения
                 T_pause += new Date().getTime();    //  и отмечаем время, в течении которого отображалось окно.
                 }

         if (!fbwBodyMargin) {   //  Если поля в "fbw_body" не добавлялись...
                 var wHeight = window.external.GetViewHeight();
                 var wWidth = window.external.GetViewWidth();
                 fbwBody.style.paddingTop = wHeight + "px";        //  то добавляем внутренние поля.
                 fbwBody.style.paddingBottom = wHeight + "px";
                 fbwBodyMargin=true;
                 }

         for (k=0; k<mLength; k++) {               //  Запускаем цикл для массивов списка.

                 //  Добавление данных в массивы "отмены".
                 mUndo_s[k] = [];          //  Добавление вложенного массива.
                 for (j=mJo_elem[k].length-1;  j>=0;  j--)
                         mUndo_s[k][j] = mJo_elem[k][j].innerHTML;    //  Добавление текста всех слов группы (слова одинаковые, но могут различаться регистром).
                 mUndo_count[k] = count_all_2;             //  Добавляем значение счетчика изменений.

                 msgTitle = "•  " + (k+1) + "-я группа слов (из " + (mJo_word.length) + ")";              //  Создаем текст заголовка окна.
                 msg = mJo_word[k] + " (" + mJo_count[k] + " " + slov[pad(mJo_count[k])] + ")\n					ДеЁфицировать?";   //  Текст в окне.

                 mJo_elem[k][0].style.color="#EEF47C";      //   Выделяем первое слово из очередной группы одинаковых слов
                 mJo_elem[k][0].style.backgroundColor="#821A1A";
                 mJo_elem[k][0].style.fontSize="115%";
                 GoTo_0(mJo_elem[k][0]);       //  Переходим на узел <LABEL> с этим словом.

                 T_pause -= new Date().getTime();
                 otvet_txt = window.external.InputBox(msg, msgTitle, "");   //  Создаем диалоговое окно, и сохраняем введенный текст.
                 T_pause += new Date().getTime();                //  Отмечаем время, в течении которого отображалось окно.
                 otvet3 = window.external.GetModalResult();    //  Сохраняем код кнопки ответа.

                 mJo_elem[k][0].style.removeAttribute("color");      //  Удаляем добавленное выделение слова.
                 mJo_elem[k][0].style.removeAttribute("backgroundColor");
                 mJo_elem[k][0].style.removeAttribute("fontSize");

                 if (otvet3 == 2  ||  otvet_txt.search(/^-*$/) ==-1) {         //  Если нажата кнопка "Отмена" или введен любой текст кроме минусов...
                         T_pause -= new Date().getTime();
                         exit = AskYesNo ("◊  Прервать выполнение скрипта?       ");     //  то спрашиваем,
                         T_pause += new Date().getTime();    //  отмечаем время, в течении которого отображалось окно,
                         k--;                          //  возвращаем проверяемую группу.
                         if (exit)  break;     //  и в зависимости от ответа, либо выходим из цикла,
                             else  continue;    //  либо переходим на повторение шага.
                         }

                 if (otvet_txt.search(/^\-+$/) !=-1) {     //  Если введен один или несколько минусов...
                         jjj=otvet_txt.match(/\-/g).length;   //  то считаем минусы,
                         for (; jjj>0  &&  k>=1; jjj--) {     //  Запускаем цикл для отмен.
                                 k--;                      //  Уменьшаем номер группы на единицу.
                                 for (j=mJo_elem[k].length-1;  j>=0;  j--) {      //  Запускаем цикл для одной группы, в котором...
                                         mJo_elem[k][j].innerHTML = mUndo_s[k][j];   //  возвращаем исходный текст слова в каждый элемент <LABEL>
                                         count_all_2 = mUndo_count[k];         //  и возвращаем значение счетчика изменений.
                                         }
                                 }
                         k--;        //  Делаем поправку на то, что при возврате к началу цикла, номер группы будет увеличен,
                         continue;      //  и возвращаемся к началу цикла.
                         }

                 if (otvet3 == 6) {                                                 // "Да":
                         for (j=mJo_elem[k].length-1;  j>=0;  j--)
                                 mJo_elem[k][j].innerHTML = mJo_elem[k][j].innerHTML.replace(/Ё/g, "Е").replace(/ё/g, "е");    //  Заменяем во всей группе ё на е
                         count_all_2 += mJo_elem[k].length;         //  и добавляем число изменений в счетчик.
                         }
                 }
         }
 }

 if (Rezhim == 1  ||  !otvet1  ||  otvet2)   //  Если включен режим "Только ёфикация", или отказано в деЁфикации, или получено разрешение на выборочную деЁфикацию...
         for (k=0; k<mLength; k++)                            //  то запускаем цикл для групп из одинаковых слов,
                 for (j=mJo_elem[k].length-1;  j>=0;  j--)     //  внутри него запускаем цикл для отдельных слов, которые выделены тегами <LABEL>
                         mJo_elem[k][j].removeNode(false);     //  и удаляем все эти теги.

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 ///  Очистка полей в "fbw_body"

 if (fbwBodyMargin) {   //  Если поля в "fbw_body" добавлялись...
         var H_first_P = mP[0].getBoundingClientRect().top;   //  то определяем высоту первой строки книги,
         fbwBody.style.removeAttribute("paddingTop");        //  удаляем поля
         fbwBody.style.removeAttribute("paddingBottom");
         window.scrollBy(0, mP[0].getBoundingClientRect().top - H_first_P);   //  и сдвигаем текст в исходное положение.
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 ///  ПОВЫШЕНИЕ ВЕРСИИ ФАЙЛА И ЗАПИСЬ В ИСТОРИЮ ИЗМЕНЕНИЙ
                 //  (применение функции "HistoryChange")

 var versionFile=document.getElementById("diVersion").value; //  Извлечение значения версии файла.
 var newVersion = versionFile;                                                          //  Значение новой версии.

 var HiCh=0;                     //  Код изменения истории.
 var VersionUp=false;   //  Индикатор повышения версии.

//  Если включено автоматическое повышение версии, а также если есть измененные строки или разрешено повышение версии когда нет изменений...
 if (Version_on_off == 1  &&  ((count_all_1+count_all_2  !=0)  ||  Vsegda_on_off ==1))
         HistoryChange(ScriptName + " " + NumerusVersion, youName);   //  то запускаем функцию для изменения данных истории.

// ---------------------------------------------------------------

 window.external.EndUndoUnit(document);    // Конец записи в систему отмен.

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОКНО РЕЗУЛЬТАТОВ  :  Текущее время и дата

 var currentFullDate = new Date();

 var currentHours = currentFullDate.getHours();
 var currentMinutes = currentFullDate.getMinutes();
 var currentSeconds = currentFullDate.getSeconds();

 if (currentMinutes<10) currentMinutes = "0" + currentMinutes;
 if (currentSeconds<10) currentSeconds = "0" + currentSeconds;

 var currentDay = currentFullDate.getDate();
 var currentMonth = 1+currentFullDate.getMonth();
 var currentYear_ = currentFullDate.getFullYear();

 if (currentMonth<10) currentMonth = "0" + currentMonth;
var currentYear = (currentYear_+"").replace(/^.*?(\d{1,2})$/g, "$1");

 var currentTime_ = currentHours + ":" + currentMinutes;
 var currentTime = currentTime_ + ":" + currentSeconds;
 var currentDate_ = currentDay + "." + currentMonth;
 //currentDate_="7.10"   //  для тестирования праздников
 var currentDate = currentDate_ + "." + currentYear;

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// СОЗДАНИЕ СПИСКА ЦИТАТ

//  Из книги "Пословицы и поговорки Великой Отечественной войны"
//  (составитель Павел Федорович Лебедев)

 var Kn=[ "Одна у человека мать, одна у него и Родина.",   "Родина любимая – мать родимая.",   "Родина – мать, умей за нее постоять.",   "Где ни жить – Родине служить.",   "С Родиной разлука – одна мука.",   "Всякому мила своя сторона.",   "Своя земля и в горсти мила.",   "На чужой стороне и весна не красна.",   "Где кто родится, там и пригодится.",   "На чужбине родная землица во сне снится.",   "На своей стороне мило, на чужой – постыло.",   "На чужой стороне и сокола зовут вороною.",   "Всякая сосна своему лесу весть подает.",   "Родная страна – колыбель, чужая – дырявое корыто.",   "На солнце тепло, на родине добро.",   "Человек без Родины что соловей без песни.",   "Глупа та птица, которой свое гнездо не мило.",   "Кукушка кукует – по бездомью горюет.",   "Расставшийся с другом плачет семь лет, расставшийся с Родиной – всю жизнь.",   "Нет ничего на свете краше, чем Родина наша.",   "Нашей страны шире не найти в мире.",   "Русское раздолье – человеку приволье.",   "Богата русская земля – говорится не зря.",   "Я тобой горжусь, милая Русь.",   "Человек без Родины что солдат без оружия.",   "Счастье Родины дороже жизни.",   "Береги страну как зеницу ока.",   "Может, и голову сложу, а Родине послужу.",   "Нам Отчизна дорога, охраняем родные берега.",   "Пусть знает ворог: нам край свой дорог.",   "Кто любовь к Отчизне имеет, тот врага одолеет.",   "Мы бережем свою Родину-мать, за нее мы готовы жизнь отдать.",   "С нами родная земля, нам светят звезды Кремля.",   "Великие победы нас ждут впереди под лучами красной звезды.",   "Красная звезда светит всегда.",   "Теперь все дороги ведут в Москву.",   "Москва от глаз далека, да сердцу близка.",   "Москва – наша столица, Москвой народ гордится.",   "Москва – всем столицам голова.",   "Москва – столица, любо подивиться.",   "У русской столицы не видать границы.",   "По Москве ходить – глаз с нее не сводить.",   "Москва – Родины украшенье, врагам устрашение.",   "Кремль тем и красен, что с народом согласен.",   "Наша страна дружбой сильна.",   "У нас все народы живут в ладу – врагам на беду.",   "Солнце не померкнет над нами, братство – наша сила и знамя.",   "Народное братство дороже всякого богатства.",   "Если дружба велика, будет Родина крепка.",   "Дружбу нашу не разделят просторы, моря и горы.",   "Страна растет – врагов метет.",   "Не тот человек, кто для себя живет, а тот человек, кто народу силы отдает.",   "За Родину и народ иду вперед.",   "Человек без народа что дерево без плода.",   "Чтобы с врагами биться, надо всем сплотиться.",   "Не трудно врагов победить, если всем заодно быть.",   "Наш народ сплочен и един, он непобедим.",   "Кто на нас нападает, тот в могилу попадает.",   "Россия с давних пор давала врагу отпор.",   "Никогда Россия ярма не носила.",   "За наше Отечество все человечество.",   "Не летать фашистским стаям над нашим краем.",   "Мы не боимся свинцовой тучи: наши полки могучи.",   "Кто на Советский Союз покушается, тот после раскается.",   "Бей фашистов не в бровь, а в глаз – таков народа наказ.",   "Любовь к народу, ненависть к врагу – душа победы.",   "От Родины награда – сердцу отрада.",   "Отчизна родная – для нас святая.",   "Знает свет: тверже русских нет.",   "Наш народ – герой, ходит на врага стеной.",   "Сыновья русских матерей славятся удалью богатырей.",   "Наша страна героями славится.",   "Кто за Родину горой – тот истинный герой.",   "Без патриотизма не разбить фашизма.",   "Защищай Советскую державу, бей фашистскую ораву.",   "Фашистам смерть неси – не опозорь Руси.",   "Даю Родине слово: мстить фашистам сурово.",   "Во имя Отчизны своей где фашиста увидел – бей.",   "За народное дело бейся смело.",   "Для Родины своей ни сил, ни жизни не жалей.",   "Жизнь отдам, а Родину не продам.",   "С родной земли – умри не сходи.",   "За Родину-мать не страшно умирать.",   "За Родину жизни не пощадим, но врагу ничего не отдадим.",   "Кому нашей земли захочется, тот под ней скорчится.",   "Родину любить – фашистов бить.",   "Бей фашистский сброд – за Родину, за народ.",   "Родину любить – верно Родине служить.",   "Родину беречь – врагов сечь.",   "Для нас война не страх – развеем врага в прах.",   "Гитлер пришел к нам незваным, а уйдет от нас драным.",   "Не придется Гитлеру из Ленинграда сделать море, а из Москвы – поле.",   "Думал Гитлер нашими землями управлять, а придется ему подыхать.",   "Штык советский молодец – скоро Гитлеру конец.",   "У Гитлера не столько расчетов, сколько просчетов.",   "Гитлер предполагает, а Красная Армия располагает.",   "Посмотрим, как Гитлер завоет, когда наши огонь по Берлину откроют.",   "Раздавим Гитлера в блин, как придем в Берлин.",   "Гитлеру-палачу местью отплачу.",   "Пора с Гитлером кончать – хватит ему рычать.",   "Гитлер и его правительство ответят за грабительство.",   "Гитлер кричит, мы весь свет разрушим, а мы Гитлера наперед задушим.",   "Сколько Гитлер ни крути, а от петли не уйти.",   "Гитлер победами хвалится, да в могилу свалится.",   "Хотел Гитлер Россию съесть, да пришлось в лужу сесть.",   "Не довелось свинье на небо дивиться, а Гитлеру в нашем огороде рыться.",   "Медведя знают по когтям, а Геббельса по лживым речам.",   "Фашистские собаки сочиняют враки.",   "Фашист брехней живет.",   "Солдаты у Гитлера вшивы, сводки у Геббельса лживы.",   "От осины не жди ягоды, от фашиста – правды.",   "Геббельс вертит языком без меры, да нет ему веры.",   "Геббельс мелет, да никто ему не верит.",   "Германия вот-вот развалится, а Геббельс все хвалится.",   "Германия пылает, а Геббельс все лает.",   "Врет, как фашистский бюллетень.",   "Как Геббельс ни врет, а наша берет.",   "Против фашистской лжи ухо востро держи.",   "Фашистские оковы всей Европе знакомы.",   "Лучше волку в зубы, чем фашистам в руки.",   "Фашист гладок, да вид его гадок.",   "Фашист от когтей до носа похож на барбоса.",   "Фашист и сатана – сущность одна.",   "Не ищи в фашисте человека – не найдешь.",   "Легче шакала превратить в голубя, чем фашиста в человека.",   "Фашистов легче убить, чем вразумить.",   "Фашистская власть – грабить и красть.",   "У фашистов особый спорт: кто больше добра сопрет.",   "Видно птицу по полету, а фашиста – по грабежам.",   "Сколько фашисту ни воровать, а виселицы не миновать.",   "Для предателя сгори хоть целый свет, лишь бы он был согрет.",   "Змея один раз в год меняет кожу, а предатель – каждый день.",   "Предатель фашисту пятки лизал, а фашист и спасибо не сказал.",   "У предателя ни Родины, ни друзей.",   "Лучше глаза лишиться, чем доброго имени.",   "Героям – слава, предателям – смерть.",   "Слава греет, позор жжет.",   "Бесчестье хуже смерти.",   "Кто с врагами пьет и гуляет, того и земля не принимает.",   "Думал фриц нашим богатством нажиться, да пришлось в могилу ложиться.",   "Не видать свинье неба, а фашистам нашего хлеба.",   "Кого к столу приглашают, а в фашиста пулю сажают.",   "Кому чарка, кому две, а фашисту – камнем по голове.",   "Угостили фашистов не водкой, а прямой наводкой.",   "Врага не уговаривай: с ним штыком разговаривай.",   "Убил фашистского гада – душа рада.",   "Съели бы фашисты русского мужика, да кишка тонка.",   "Одного фашиста убить – сто детей спасти.",   "Фашиста убить что змею: сто грехов простится.",   "Лучше смерть на поле, чем позор в неволе.",   "Чем позор и неволю терпеть, лучше в бою умереть.",   "Лучше биться орлом, чем жить зайцем.",   "Никогда фашистам не властвовать над нами, никогда не будем рабами.",   "Лучше злая пуля, чем клеймо раба.",   "Славная смерть лучше постыдной жизни.",   "Воевать – не галушки жевать.",   "Не воевать – победы не видать.",   "Слабого огонь войны испепеляет, а сильного как сталь закаляет.",   "Кто за правое дело дерется, у того двойная сила берется.",   "Наше дело правое – бей врага браво.",   "Бей фашистских властей всех мастей.",   "С какой злостью превеликой мы расправимся с фашистской кликой.",   "С врагами биться – на пули не скупиться.",   "Винтовка хлоп – и фашист в гроб.",   "Пришел фашист из Берлина – получил земли три аршина.",   "Не важно, чем бил, – важно, что фашиста убил.",   "Каждой фашистской гадине висеть на перекладине.",   "Всякому свой путь: журавлю – в небо, волку – в лес, а фашисту – в могилу.",   "Упрямого выправит дубина, а фашиста – могила.",   "Какую яму фашист копал – в такую и попал.",   "Фашисты научились воровать, а мы научились фашистов убивать.",   "Наш порог не для фашистских сапог.",   "Фашиста согнем в бараний рог, чтоб не переступал наш порог.",   "Лося бьют в осень, а фашиста всегда.",   "Наше дело святое и правое, мы расправимся с фашистскою оравою.",   "С фашистом разговор короткий: круши его прямой наводкой.",   "Кричал фашист «гоп», да получил пулю в лоб.",   "Фашиста умертвить – доброе дело сотворить.",   "На фронте воевать – славу добывать.",   "Фронт гремит – у врага земля горит.",   "Гремят вспышки на горизонте: то бьют фашистов на фронте.",   "Фашистов разгромили – и в селе порядок водворили.",   "Фашист замахнулся, да промахнулся.",   "Дрался фашист пылко, да остался без затылка.",   "Фашисты козыряли, да головы потеряли.",   "Фашисты пять раз на дню попадают в западню.",   "У фашистов брожение: попали в окружение.",   "Фашистам не все напирать – пришлось и умирать.",   "Трави фашистскую силу – огнем и штыком загоняй в могилу.",   "Чокнемся, фашист, я парень не гордый: я – прикладом, а ты – мордой.",   "На то у винтовок и ложи, чтобы бить фашиста по роже.",   "Слава русского штыка не померкнет века.",   "Штык остёр загнал фрицев в «котел».",   "Наши штыки разгромят фашистские полки.",   "Фашисты войну начали, а мы кончим.",   "Славу свою добывай в бою.",   "Почет и славу собирают по капле.",   "Народ того уважает, кто фашистов уничтожает.",   "На то мы и внуки Суворова, чтобы сражаться здорово.",   "Как учил Александр Суворов – будь к врагу суровым.",   "На краю света фашистов найдем и на суд приведем.",   "Зря фашист блиндажи строит: все равно снаряд накроет.",   "Смерть фашистской своре – на берегу и в море!",   "Солдата мать родит, отец растит, а бой учит.",   "Дерево в огне сгорает, а солдат от огня крепче бывает.",   "Кто первый бой начинает, тот скорее побеждает.",   "Пришла пора гнать фашистов со двора.",   "Фашист наступает – кричит «гут», а отступает – «Гитлер капут».",   "Красна девушка косами, солдат – орденами.",   "Ученый водит, а неуч сзади ходит.",   "Птицу обманывают кормом, а человека – словом.",   "Слово, сказанное без соображения, подобно выстрелу без прицела.",   "Говорить впустую что стрелять вхолостую.",   "У осла длинные уши, а у болтуна длинный язык.",   "У короткого ума длинный язык.",   "Слово не воробей: выпустишь – не поймаешь.",   "Скажешь – не воротишь, напишешь – не сотрешь, отрубишь – не приставишь.",   "Лучше один раз увидеть, чем сто раз услышать.",   "Острый язык – дарование, длинный язык – наказание.",   "Не всегда говори то, что знаешь, но всегда знай, что говоришь.",   "Кто много болтает, тот врагу помогает.",   "Кто зевает – победителем не бывает.",   "Храбрость города берет, а бдительность их бережет.",   "Зря не болтай у телефона: болтун – находка для шпиона.",   "Нет друга – так ищи, а найдешь – береги.",   "Ищи себе друзей таких, чтобы не было стыда от них.",   "Не ходи, дружок, в неизвестный кружок: к таким людям зайдешь, что навек пропадешь.",   "Плохой друг подобен тени: только в светлые дни его и видишь.",   "Не та дружба сильна, что в словах заключена, а та, что в бою скреплена.",   "Для друзей – пироги, для врагов – кулаки.",   "В недруге пуля что во пне, а в друге что во мне.",   "Все за одного, один за всех – вот и обеспечен в бою успех.",   "Не имей сто рублей, а имей сто друзей.",   "В дружбе – правда.",   "Кто нашел друга – нашел сокровище.",   "Сам пропадай, а товарища выручай.",   "Один в поле не воин, а вдвоем с товарищем – взвод.",   "Где дружба и лад – там и клад.",   "Где дружба и совет – там и свет.",   "Трусливый друг опаснее врага, ибо врага опасаешься, а на друга опираешься.",   "Не тот друг, кто медом мажет, а тот, кто правду скажет.",   "Недруг поддакивает, а друг спорит.",   "Дружба крепка не лестью, а правдой и честью.",   "Новых друзей наживай, а старых не забывай.",   "Прямо страху в глаза смотри – и страх смигнет.",   "Волков бояться – в лес не ходить.",   "Трус умирает тысячу раз, а смелый всего один раз.",   "Советские воины из металла скроены.",   "Чем больше героев, тем скорее фашистов зароем.",   "Храбрость – сестра победы.",   "На смелого собака лает, а трусливого – рвет.",   "Не числом, а храбростью побеждают.",   "Лучше быть мертвым героем, чем живым трусом.",   "Смелого и пуля облетит, смелый и мину перехитрит.",   "Если не будешь овцой, то волк не съест.",   "Косил Гитлер глаз на Донбасс, а Донбасс опять у нас.",   "И про солдатскую честь пословица есть.",   "Потому и смешно, что фашистам горе пришло.",   "Гитлеровским сателлитам быть разбитым.",   "Знаем, за что бьем, потому и с победой придем.",   "Кто за правое дело стоит, тот всегда победит.",   "У правого сила удвоится, говорит пословица.",   "Будет праздник и на улице нашей, всякого праздника краше.",   "Войну закончим – и мир упрочим.",   "Как фашисты нам ни грозили, а мы их сразили.",   "Фашистов разгромили – добро сотворили.",   "Хотел Гитлер покорить весь мир, да лопнул как мыльный пузырь.",   "Задохнулась фашистская стая девятого мая.",   "Разбили фашистскую орду в сорок пятом году.",   "Прогнали фрицев – можно веселиться.",   "Советская Армия врага разгромила, она стоит на страже мира.",   "Курские леса и дубравы полны легендарной славы.",   "Виден в курских лесах боевой размах.",   "Защитим курские дубравы от фашистской оравы!",   "В курских городах разбили фашистов в прах.",   "Как фашисты ни рвались к Курску – не дали им спуску.",   "Бей врага, Суджа, зарывай глубже." ];

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОКНО РЕЗУЛЬТАТОВ  :  Демонстрационный режим

 var VseStroki_on_off = 0;      // 0 ; 1 //      ("0" — отключить, "1" — включить)

 var d=0;
 if (VseStroki_on_off == 1)  d="показать нули";

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОКНО РЕЗУЛЬТАТОВ  :  Сборка массива с результатами обработки (для win XP)

 var Tf=new Date().getTime();   //  Момент окончания работы скрипта.
 mSt=[];          //  Очистка массива строк статистики
 ind=0;           //  Обнуление индекса строк

 //  Подсчет финального числа ёфицированных слов
 var count_joAll = count_jo01 + count_jo02 - count_all_2;
 for (k=0; k<LengthM; k+=2)    //  Последовательный просмотр списка замен с буквой  Е.
         count_joAll += M[k][8];         //  Добавление количества ёфицированных слов разночтения.
 for (k=1; k<LengthM; k+=2)    //  Последовательный просмотр списка замен с буквой  Ё.
         count_joAll -= M[k][8];         //  Вычитание количества деёфицированных слов разночтения.

                                 mSt[ind++]=" "+ScriptName+" v."+NumerusVersion;
                                 mSt[ind++]="-----------------------------------------------------------";
 if (Rezhim == 1)  mSt[ind++]="  режим «Только Ёфикация»";
 if (Rezhim == 2)  mSt[ind++]="  режим «Только деЁфикация»";
 if (d)                      mSt[ind++]="  = Демонстрационный режим =";
                                 mSt[ind++]="                                                                                         ";

                                 mSt[ind++]="Вычисления  .  .  .  .  .  .  .	"+time(Tf - Ts - T_pause);
 if (T_pause!=d) mSt[ind++]="Диалоговые паузы .  .  .  .	"+time(T_pause);
                                 mSt[ind++]="Всего слов .  .  .  .  .  .  .  .	"+count_W_body;

 if (count_W_body == 0)  count_W_body=1;    //  Защита от деления ноль на ноль.

                                 mSt[ind++]= "С буквой «Ё»   .  .  .  .  .  .	" + (+((count_joAll/
                                           count_W_body*100+"").replace(/(^[0\.]*....).+/, "$1").replace(/(^0\.0*\d\d).+/, "$1")) + "").replace(/(\.)/, ",") + "%";

 if (count_all_1 !=d)  mSt[ind++]="Замен «разночтения»  .  .	"+count_all_1;
 if (count_all_2 !=d)  mSt[ind++]="ДеЁфицированно слов .  .	"+count_all_2;

 if (count_all_1 !=d) {
         mSt[ind++]="";
         mSt[ind++]="• Подробно (разночтения):";
         for (k=0; k<LengthM; k++)    //  Последовательный просмотр списка замен.
                 if (M[k][8] !=d)           //  Если производилась замена в группе...
                         mSt[ind++]= M[k][8] + "  —	" + M[k][0] + "  ›››  " + M[k][2];   //  то добавляем новую строку.
         }


 if (count_all_1+count_all_2 ==0  ||  d) {  //  Если замен нет...
         mSt[ind++]="";
         mSt[ind++]="   >> Исправлений нет";   //  то добавляем соответствующий текст.
         }

//  История
 if (VersionUp ||  HiCh  ||  d)  mSt[ind++]="";
 if (VersionUp  ||  d)                  mSt[ind++]="• Версия файла:  "+versionFile+"  ›››  "+newVersion;
 if (HiCh==1  ||  d)                     mSt[ind++]="• Добавлена новая строка в историю";
 if (HiCh==2  ||  d)                     mSt[ind++]="• Добавлены две строки в историю";
 if (HiCh==3  ||  d)                     mSt[ind++]="• Изменены данные в строке истории";


//  Сборка строк текущей даты и времени
 mSt[ind++]="";
 mSt[ind++]= "• "+currentDate+" • "+currentTime+" •";


 mSt[ind++]="";
 mSt[ind++]="-----------------------------------------------------------";

//  Сборка строк цитаты
 var reZit = new RegExp("([^ ].{0,47})(?=\\\s\\\s.{0,}|$)","g");   // Рег. выражение для разделения цитаты на строки.
 mSt= mSt.concat(Kn[Rn_(Kn.length)].replace(/ /g, "  ").match(reZit));   //  Добавление массива строк цитаты в основной массив.
 for (j=mSt.length-1; j>=ind; j--)  mSt[j]=" "+mSt[j];   //  Добавление отступа.
 //for (j=mSt.length-1; j>=ind; j--)  { mSt.splice(j+1, 0, ""+mSt[j].length) }   //  Добавление длины строк цитаты (отключено)
 ind = mSt.length;    //  Определение индекса.


 PageF();      //  Запуск функции для создания страниц.

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------

}




                 ///  ИСТОРИЯ ИЗМЕНЕНИЙ

// v.1.0 — Создание скрипта — Александр Ка (26.06.2025)
// v.2.0 — Александр Ка (5.07.2025)
// ДеЁфикация слов без разночтения.
// Начальная статистика.
// Выбор режима: "Править всё", "Только Ёфикация", "Только деЁфикация".
// Добавлены 66 пар разночтения.
// Автоматическая сортировка и проверка пар разночтения.
// Увеличена скорость поиска слов разночтения (примерно в 3 раза).
// Улучшена система отмен.
// Увеличена скорость перехода от одного проверяемого слова к другому.
// Любое проверяемое слово теперь располагается на указанной в настройках высоте, даже если оно в самом начале, или в самом конце книги.
// Добавлены некоторые детали в финальную статистику.
// v.2.1 — Исправлена ошибка (сдвиг текста в финале) — Александр Ка (7.07.2025)
// v.2.2 — Добавлены 22 пары разночтения — Александр Ка (10.07.2025)



