//======================================
//             «Скрипт-конструктор» v.1.4
//  Предназначен для быстрого и удобного создания несложных скриптов по поиску и замене в строках текста (с тегами).
//  Скрипт тестировался в FBE v.2.7.7 (win XP, IE8 и win 7, IE11)
//  * Раздел для добавления операций начинается сразу после "настроек";  чуть ниже шаблон операций  и  пояснения.
//======================================

function Run() {
 var Ts=new Date().getTime();

// ---------------------------------------------------------------
                 ///  НАСТРОЙКИ
// ---------------------------------------------------------------

         //     Название скрипта

var ScriptName = "Скрипт-конструктор";      // текст //


         //     Номер версии скрипта

var NumerusVersion="1.4";      // текст //

// * Название и версия скрипта отображаются  в окне статистики  и  в списке системы отмен "FictionBook Editor"

// ---------------------------------------------------------------

         //     Обработка текста внутри "Истории изменений файла"

var ObrabotkaHistory_on_off = 1;      // 0 ; 1 //      ("0" — отключить, "1" — включить)


         //     Обработка текста внутри аннотации к книге

var ObrabotkaAnnotation_on_off = 1;      // 0 ; 1 //      ("0" — отключить, "1" — включить)

// ---------------------------------------------------------------

         //   •  Максимум строк в окне результатов
//  * Скрипт постарается не превышать это значение, и при необходимости разделит текст на несколько страниц.

 var Vysota_teksta = 50;      // примерно 25-52 //      Ориентировочный максимум строк в окне результатов

// * Для монитора 1024х768 максимальная высота окна равна 52 строкам (в win XP) и 50 строк (в win 7).

// ---------------------------------------------------------------

         //     Демонстрационный режим
//  Включает присмотр всех возможных строк статистики.
//  Помогает находить ошибки в строках статистики, регулировать длину строки, расставлять ряд точек.

var VseStroki_on_off = 1;      // 0 ; 1 //      ("0" — отключить, "1" — включить)

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОПЕРАЦИИ

 function Opertiones() {


//  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         //  Сюда можно добавлять свои операции по поиску/замене.




 //  Пример поиска:     Поиск любых подзаголовков
 n=101;
 if (nachalo) {
         re[n] = new RegExp("^","g");
         stroka_v_statistike[n] = "Подзаголовков   /пример/   .  .  .  .  .  .  .";
         }
 if (subtitle)
 if (s.search(re[n]) != -1) {
         count[n] += s.match(re[n]).length;
         }

 //  Пример поиска:     Поиск слова "Глава" в начале строки (не в заголовках/подзаголовках)
 n++;
 if (nachalo) {
         re[n] = new RegExp("^(\\\s|"+nbspEntity+"|"+NC+"|<[^>]{1,}>){0,}([Гг]лава|ГЛАВА)[^А-яЁё]","g");
         stroka_v_statistike[n] = "Неразмеченных глав   /пример/   .  .  .  .";
         }
 if (! title  &&  ! subtitle)
 if (s.search(re[n]) != -1) {
         count[n] += s.match(re[n]).length;
         }

 //  Пример поиска:     Поиск буквы "R" (не в </тегах>)
 n++;
 if (nachalo) {
         re[n] = new RegExp("[Rr](?=[^>]{0,}(<|$))","g");
         stroka_v_statistike[n] = "Букв \"R\"   /пример/  .  .  .  .  .  .  .  .  .  .  .";
         }
 if (s.search(re[n]) != -1) {
         count[n] += s.match(re[n]).length;
         }

 //  Пример замены:     Ряд пробелов  ›››  обычный пробел (не в стихах)      - операция из "ген.уборки" v.3.10
 n=201;   //  Номер операции
 if (nachalo) {
         re[n] = new RegExp("(\\\s|"+nbspEntity+"){2,}","g");
         re_[n] = " ";
         stroka_v_statistike[n] = "Ряд пробелов на обычный   /пример/    ";
         }
 if (! stanza)
 if (s.search(re[n]) != -1) {
         count[n] += s.match(re[n]).length;
         s = s.replace(re[n], re_[n]);
         }

 //  Пример замены:     "?!"  +  две точки или запятая   ›››     "?!."      - операция из "ген.уборки" v.3.10
 n++;
 if (nachalo) {
         re[n] = new RegExp("((^|[^\\\?!])[\\\?!]{2})(\\\.\\\.|,)","g");
         re_[n] = "$1.";
         stroka_v_statistike[n] = "?!  + точки/запятая  ›››  ?!.   /пример/    ";
         }
 if (s.search(re[n]) != -1) {
         count[n] += s.match(re[n]).length;
         s = s.replace(re[n], re_[n]);
         }

//  Чтобы не мешались, примеры операций можно удалить или отправить в комментарий.




//  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------



                 ///  ИНСТРУКЦИЯ


  /*  // (начало комментария)


         ///  Шаблон операции

 n = 1;   //  Номер операции
 if (nachalo) {
         re[n] = new RegExp("<Регулярное выражение для поиска>","g");
         re_[n] = "<Регулярное выражение для замены>";
         stroka_v_statistike[n] = "<Текст в статистике>  .  .  .  .  .  .  .  .  .";
         }
 if (true)        //  annotation, history, title, subtitle, poem, stanza, cite, epigraph, table, text_author, text
 if (s.search(re[n]) != -1) {
         count[n] += s.match(re[n]).length;    // для статистики
         s = s.replace(re[n], re_[n]);    //  для замены
         }


         ///  Пояснения

   Для создания новой операции достаточно скопировать шаблон в подходящее место.
   Добавить:  номер операции,  регулярные выражения  и  текст, который будет отображаться в статистике.
   При необходимости:  указать область поиска  и  удалить лишние строки.


•  n = 1;

   В этой строке записывается уникальный номер для каждой операции.
   Номер операции задается в промежутке от  0  до  999.
   Если номера операций идут по порядку, то можно указать номер только для первой операции, а для всех последующих использовать одну и ту же строку:
   n++;
   Выполняются операции независимо от номера, в порядке их записи в скрипте. А в окне статистики строки операций будут отсортированы по их номеру, и распределены по двум разделам: "Поиск и подсчёт" и "Исправления".

•  if (nachalo) {

   Эта техническая строка нужна для того, чтобы скрипт при каждом переходе на следующую строку текста книги не записывал один и тот же текст регулярных выражений в одни и те же переменные.
   Здесь ничего изменять не требуется.

•  re[n] = new RegExp("<Регулярное выражение для поиска>","g");

   В этой строке записывается регулярное выражение для поиска.
   Записи регулярных выражений немного отличаются от записей, используемых для поиска в текстовых редакторах.
   Специальный символ «\», который отменяет функциональность следующего за ним символа, одного здесь недостаточно, поскольку текст при объявлении рег. выражения, просматривается компьютером дважды. Сначала как текст <"текст рег. выражения">, у которого одни управляющие символы, а затем как реальное рег. выражение, у которого уже другие управляющие символы.

   Обычно во всём скрипте используется удвоенный или утроенный обратный слэш. Но с некоторыми исключениями.
   Для удвоенного обратного слэша исключениями будет запись символов «"», «'», «\».
   Кавычки и апостроф требуют один или три обратных слэша: «\"», «\\\"», «\'», «\\\'». А для записи самого обратного слэша нужны три дополнительных «\\\\».
   Для утроенного обратного слэша исключениями будет запись команд «\u», «\х», «\1», «\2», «\3» и т.д.
   Команды записи символа через шестнадцатеричный код будут работать с одним или с двумя обратными слэшами: «\u», «\\u», «\х», «\\х». А для команд повторения блока в круглых скобках необходимо ровно два обратных слэша: «\\1», «\\2», «\\3» и т.д.
   Возможно есть ещё какие-то исключения, но я на них ещё не натыкался.

   В регулярные выражения можно добавлять переменные, которые могут значительно расширить возможности поиска и замены:
   nbspEntity — неразрывный пробел, который в зависимости от настроек FBE, может принимать 4 разных значения.
   sIB — начальные (стартовые) теги курсива, жирности, или жирного курсива.
   fIB — конечные (финальные) теги курсива, жирности, или жирного курсива.
   aIB — начальные или конечные теги (all).
   NC — любая стандартная сноска (на примечание или на комментарий).
   Поскольку переменные могут содержать в себе управляющий символ "|", то записывать их удобнее в круглых скобках:
   "<текст рег. выражения> ("+nbspEntity+") <текст рег. выражения>"
   "<текст рег. выражения> ("+sIB+") <текст рег. выражения>"
   "<текст рег. выражения> ("+fIB+") <текст рег. выражения>"
   "<текст рег. выражения> ("+aIB+") <текст рег. выражения>"
   "<текст рег. выражения> ("+NC+") <текст рег. выражения>"
   Точный текст переменных можно посмотреть немного ниже, в разделе "Общие переменные".

•  re_[n] = "<Регулярное выражение для замены>";

   В этой строке записывается регулярное выражение для замены.
   Здесь утроение символа «\»  не нужно.
   Из всех переменных можно добавлять только "nbspEntity", без скобок:
   "<текст рег. выражения>"+nbspEntity+"<текст рег. выражения>"
   Если в операции будет производиться только поиск, то эта строка удаляется.

•  stroka_v_statistike[n] = "<Текст в статистике>   .  .  .  .  .  .  .  .  .";    };

   В эту строку вписывается текст, который будет отображаться в статистике.
   Для нормального отображения статистики  требуется, чтобы все ее строки были одинаковой длины.
   Добиться этого можно сокращая или увеличивая строку.
   Проверить качество всех строк статистики можно включением демонстрационного режима.
   Если не планируется отображение действий этой операции в статистике, то эта строка удаляется.

•  if (true)

   Эта строка определяет область поиска и замены.
   Внутрь скобок оператора условия «if» добавляются переменные, имена которых соответствует разделам, в которых может быть замена (или поиск).
   Можно использовать следующие имена:
   annotation, history, title, subtitle, poem, stanza, cite, epigraph, table, text_author, text.
   (именем «text_author»  обозначается формат «text-author»)
   (именем «text»  обозначается текст расположенный непосредственно в секции, т.е. без внешнего форматирования)
   Если область поиска/замены включает в себя только один формат, то соответствующая переменная просто добавляется внутрь скобок.
   например:  if (annotation)
   Если область поиска/замены включает в себя несколько форматов, то имена следует записывать с использованием оператора логического сложения «||» («или»).
   например:  if (annotation  ||  epigraph  ||  text_author)
   Если область поиска/замены не должна включать в себя один формат, то имя предваряется оператором отрицания «!» («не»).
   например:  if (! annotation)
   Если область поиска/замены НЕ включает в себя несколько форматов, то имена следует записывать с использованием оператора логического умножения «&&» («и»).
   например:  if (! annotation  &&  ! epigraph  &&  ! text_author)
   Если область поиска/замены ничем не ограничена, то эта строка просто удаляется. Либо сохраняется значение «true».

•  if (s.search(re[n]) != -1) {

   Эта строка запускает поиск в тексте параграфа, и, если поиск результативен, то выполняются строки в фигурных скобках.
   Здесь ничего изменять не требуется.

•  count[n] += s.match(re[n]).length;

   Эта строка подсчитывает количество найденных фрагментов в строке, и добавляет это число к счетчику.
   Здесь ничего изменять не требуется.
   Но если не планируется отображение действий этой операции в статистике, то эта строка удаляется.

•  s = s.replace(re[n], re_[n]);

   В этой строке производится замена с использованием рег. выражений.
   Здесь ничего изменять не требуется.
   Но если в операции производится только поиск, то чтобы не произошла ошибочная замена, эту строку надо удалить.


         * * *
   Для просмотра структуры текста, с котором взаимодействует скрипт, можно воспользоваться набором скриптов «Для программистов».

         * * *
   Изменять скрипт лучше при включенном FBE, иначе если в скрипте окажется ошибка, то при запуске программы, FBE удалит этот скрипт из меню программы и панели скриптов, и тем самым вызовет коллапс панели скриптов. Если это всё-таки произошло, то постарайтесь исправить ошибку скрипта, и перезапустите FBE — список скриптов вернётся в первоначальное состояние, и коллапс панели скриптов самоликвидируется.

*/  // (конец комментария)

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОБЩИЕ ПЕРЕМЕННЫЕ

         //   Неразрывный пробел:  ("+nbspEntity+")
 try {
         var nbspEntity=window.external.GetNBSP();   //  Выбранный символ для н/р пробела в настройках FBE.
         if (nbspEntity.charCodeAt(0)==160)               //  Если выбран прозрачный н/р пробел...
                 nbspEntity="&nbsp;";                                //  то этот символ записывается как код <&nbsp;>
         }
 // Для FBE в котором отсутствуют настройки н/р пробела, и в котором команда "window.external.GetNBSP()" вызывает ошибку...
 catch(e) { var nbspEntity="&nbsp;" }     //  символ н/р пробела всегда записывается как код <&nbsp;>

//   Теги курсива и жирности
var sIB="<EM><STRONG>|<STRONG><EM>|<EM>|<STRONG>";
var fIB="</EM></STRONG>|</STRONG></EM>|</EM>|</STRONG>";
var aIB="<EM><STRONG>|<STRONG><EM>|</EM></STRONG>|</STRONG></EM>|<EM>|<STRONG>|</EM>|</STRONG>";
var NC="<A href=[^>]{0,}?><SUP>\\\{\\\d{1,5}\\\}</SUP></A>|<A class=note [^<]{1,}?</A>";   //  Любая стандартная сноска (на примечание или на комментарий)

 var k=0;  //   Локальная переменная для небольших областей.

 var fbwBody=document.getElementById("fbw_body");

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОБРАБОТКА ТЕКСТА
                 //      (сборка функции "HandleP")

 var n;      // Номер операции
 var re=[];      // Регулярные выражения для поиска
 var re_=[];      // Регулярные выражения для замены
 var stroka_v_statistike=[];      // Строки в статистике
 var count=[];      // Счетчики
 for (k=0; k<=999; k++)  count[k]=0;    // Обнуление всех возможных счетчиков

 var ptr;     // Параграф <P> в виде структуры
 var ptrUp;  //  Раздел над строкой
 var s="";      // Копия строки из параграфа <P>  (<P>строка</P>)

 var count_P=0;      // Счетчик строк
 var count_GU=0;      // Счетчик измененных строк

 var title;
 var history;
 var stanza;
 var poem;
 var epigraph;
 var annotation;
 var cite;
 var table;
 var subtitle;
 var text_author;
 var text;


 function HandleP(ptr) {

         s=ptr.innerHTML;  //  Получение текста параграфа (с внутренними тегами).

         count_P++;     // Счетчик строк.


                   // Определение форматирования строки

         ptrUp = ptr.parentNode;  //  раздел над строкой
         subtitle = (ptr.className == "subtitle");         //   подзаголовки
         text_author = (ptr.className == "text-author")         //   автор текста
         text = (! subtitle  &&  ptrUp.className == "section")        //   текст без форматирования

         title = false;      //  исходные значения
         history = false;
         stanza = false;
         poem = false;
         epigraph = false;
         annotation = false;
         cite = false;
         table = false;

         while(ptrUp.className != "section"  &&  ptrUp != fbwBody) {
                 if (ptrUp.className == "title")  title = true;       //   заголовки
                 if (ptrUp.className == "history")  history = true;        //   история
                 if (ptrUp.className == "stanza")  stanza = true;        //   строфы
                 if (ptrUp.className == "poem")  poem  = true;        //   стихи
                 if (ptrUp.className == "epigraph")  epigraph = true;        //   эпиграф
                 if (ptrUp.className == "annotation")  annotation = true;        //   аннотация
                 if (ptrUp.className == "cite")  cite = true;        //   цитата
                 if (ptrUp.className == "table")  table = true;        //   таблица
                 ptrUp = ptrUp.parentNode;
                 }


                   //  Выполнение пользовательских операций

         Opertiones();


                   //  Сохранение текста абзаца

         if (ptr.innerHTML != s) {     //  Если строка изменилась...
                 count_GU++;                      //  увеличиваем счетчик изменений строк
                 ptr.innerHTML=s;           //  и сохраняем измененную строку.
                 }

         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОБРАБОТКА ТЕКСТА  :  Параграфы <P>
                 //      (применение функции "HandleP")

 var div;
 var mP;
 var mPLength;
 var j;
 var jj;
 var nachalo = true;

 window.external.BeginUndoUnit(document,"«"+ScriptName+"» v."+NumerusVersion);  // Начало записи в систему отмен FBE

 var mChild = fbwBody.children;     //  Получение всех первых разделов "fbw_body"
 for (j=0;  j<mChild.length;  j++) {            //  Последовательный просмотр этих разделов
         div =   mChild[j];
         //  Далее условие для выбора раздела "DIV"
         if (div.nodeName == "DIV"  &&  (div.className != "history"  ||  ObrabotkaHistory_on_off != 0)  &&  (div.className != "annotation"  ||  ObrabotkaAnnotation_on_off != 0)) {
                 mP = div.getElementsByTagName("P");          //  Получение всех строк в найденном разделе
                 mPLength = mP.length;                                       //  Получение количества строк
                 if (mPLength > 0) {
                         HandleP(mP[0]);                                       //  Отдельная обработка первой строки функцией "HandleP"
                         nachalo = false;    }                                     //  ... после которой "nachalo" уже не "начало"
                 for (jj=1;  jj<mPLength;  jj++)                       //  Последовательный просмотр остальных строк
                         HandleP(mP[jj]);                                    //   ... и применение к ним функции "HandleP"
                 }
         }


 window.external.EndUndoUnit(document);  // Конец записи в систему отмен FBE

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОКНО РЕЗУЛЬТАТОВ  :  Текущее время и дата

 var currentFullDate = new Date();

 var currentHours = currentFullDate.getHours();
 var currentMinutes = currentFullDate.getMinutes();
 var currentSeconds = currentFullDate.getSeconds();

 if (currentMinutes<10) currentMinutes = "0" + currentMinutes;
 if (currentSeconds<10) currentSeconds = "0" + currentSeconds;

 var currentDay = currentFullDate.getDate();
 var currentMonth = 1+currentFullDate.getMonth();
 var currentYear = currentFullDate.getFullYear();

 if (currentMonth<10) currentMonth = "0" + currentMonth;
 currentYear = (currentYear+"").replace(/^.*?(\d{1,2})$/g, "$1");

 var currentTime = currentHours + ":" + currentMinutes + ":" + currentSeconds;
 var currentDate = currentDay + "." + currentMonth + "." + currentYear;

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОКНО РЕЗУЛЬТАТОВ  :  Подсчет чистого компьютерного времени, потраченного на обработку текста

 var Tf=new Date().getTime();
 var tempus=0;

 var T2=(Tf-Ts);
 var Tmin  = Math.floor((T2)/60000);
 var TsecD = ((T2)%60000)/1000;
 var Tsec = Math.floor(TsecD);

 if (Tmin ==0)
         tempus = (+(TsecD+"").replace(/(.{1,5}).*/g, "$1")+"").replace(".", ",")+" сек";
     else {
             tempus = Tmin+" мин";
             if (Tsec !=0)
                     tempus += " " + Tsec+ " с" }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОКНО РЕЗУЛЬТАТОВ  :  Сборка массива с результатами обработки

 var mSt=[];
 var ind=0;

 var d = 0;
 if (VseStroki_on_off == 1)  d = "показать нули";

                 mSt[ind]=" «"+ScriptName+"» v."+NumerusVersion;  ind++;
                 mSt[ind]="---------------------------------------------------------------";  ind++;
 if (d)   { mSt[ind]=" Демонстрационный режим";  ind++ }
                 mSt[ind]="						       ";  ind++;

 mSt[ind]="• СТАТИСТИКА:				";  ind++;
 mSt[ind]="   Время выполнения  .  .  .  .  .  .  .  .	"+tempus;  ind++;
 mSt[ind]="   Проверено строк  .  .  .  .  .  .  .  .  .	"+count_P;  ind++;
 mSt[ind]="   Исправлено строк   .  .  .  .  .  .  .  .	"+count_GU;  ind++;

var cTaT=ind;  //  число строк в первом разделе

 mSt[ind]="";  ind++;
 mSt[ind]="• ПОИСК И ПОДСЧЁТ:";  ind++;

 for (k=0; k<=999; k++)
         if (stroka_v_statistike[k] != undefined  &&  count[k] != d  &&  re_[k]  == undefined)
                 { mSt[ind]= ("00"+k).replace(/.*(...)$/g, "$1. ")+stroka_v_statistike[k]+"	"+count[k];  ind++ }

         //  Удаление последних строк, если нет пунктов в разделе с операциями
 if (cTaT==ind-2) ind=ind-2;
var cTaT=ind;  //  число строк во втором разделе

 mSt[ind]="";  ind++;
 mSt[ind]="• ИСПРАВЛЕНИЯ:";  ind++;

 for (k=0; k<=999; k++)
         if (stroka_v_statistike[k] != undefined  &&  count[k] != d  &&  re_[k]  != undefined)
                 { mSt[ind]= ("00"+k).replace(/.*(...)$/g, "$1. ")+stroka_v_statistike[k]+"	"+count[k];  ind++ }

         //  Удаление последних строк, если нет пунктов в разделе с операциями
 if (cTaT==ind-2) ind=ind-2;

//  Сборка строк текущей даты и времени
 mSt[ind]="";  ind++;
 mSt[ind]="---------------------------------------------------------------";  ind++;
 mSt[ind]= "• "+currentDate+" • "+currentTime+" •";  ind++;

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОКНО РЕЗУЛЬТАТОВ  :  Определение высоты страниц и их количества

 if (Vysota_teksta<25)  Vysota_teksta=25;  // установка минимальной высоты
 var Kolo=Vysota_teksta-3;   //  высота колонки (в конце сборки страниц могут добавиться 3 строки)
 var page;   // страницы
//  Кроме того,  "ind" - теперь общее число строк статистики

 page = Math.ceil(ind/Kolo);  //  Определение количества страниц
 Kolo = Math.ceil((ind-1)/page +1); //  Переопределение высоты колонки

//  * Почти в каждой колонке может понадобиться перенос висящих строк, поэтому количество строк в колонке увеличено на 1.
//  * Исключается только последняя страница, для которой запасная строка не нужна, поэтому общее количество строк уменьшено на 1.

 while  ( ind <= Kolo*page)  { mSt[ind]="";  ind++ }  //  Добавление пустых строк

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОКНО РЕЗУЛЬТАТОВ  :  Распределение строк по страницам

 var mPage=[];   // массив страниц
 var _k=0;  // смещение строк

 for (n=0; n < page; n++) {              //  Последовательный вызов страниц.
         mPage[n]="";
         if (mSt[n*Kolo+_k] == "")  _k++;  //  Пропуск пустой строки в начале страницы.
         for (k=0 ;  k<Kolo;  k++)                // Заполнение страницы.
                 if (k==Kolo-1  &&  mSt[k+n*Kolo+_k].search(/^• [^0-9]/) != -1)     //   Если "последняя" строка на странице это заголовок раздела
                         { mPage[n]+="\n";  _k-- }                         //  то в конце страницы добавляется пустая строка, а "последняя" строка переносятся на следующую страницу.
                     else  mPage[n]+=mSt[k+n*Kolo+_k]+"\n";        // Если нет - Стандартное заполнение страницы.
         if (page!=1) {               //  Если это не первая страница, то добавляются ещё две строки.
                 mPage[n]+="						       \n";
                 if (n!=page-1)  mPage[n]+="◊  Стр. "+(n+1)+"  ◊  Показать  следующую  страницу?";
                         else  mPage[n]+="◊  Стр. "+(n+1)+" (последняя)  ◊  Закрыть окно?";
                 }
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------


                 /// ОКНО РЕЗУЛЬТАТОВ  :  Вывод страниц с результатами на экран

 var otvet = true;
 n=0;

 while (otvet) {        // Цикл для страниц
         if (page == 1) {
                 MsgBox (mPage[0]);
                 break;
                 }
         otvet = AskYesNo (mPage[n]);
         n++;
         if (n == page)  {
                 n=0;
                 otvet = !otvet;
                 }
         }

// ---------------------------------------------------------------
// ----------------------------------------------
// -----------------------------

}



                 ///  ИСТОРИЯ ИЗМЕНЕНИЙ

//======================================
// v.1.0 — Создание оболочки скрипта — Александр Ка (12.08.2024)
// v.1.1 — Небольшое улучшение — Александр Ка (16.08.2024)
// Все полезные разделы перенесены в начало скрипта
// Добавлена возможность добавления операции с номером "0"
// v.1.2 — Александр Ка (22.08.2024)
// Исправлена ошибка с невозможностью добавления области поиска
// v.1.3 — Александр Ка (24.02.2025)
// Добавлен автоматический выбор раздела для операций
// Добавлены примеры
// Улучшена инструкция
// Колонки статистики заменены на страницы
// v.1.4 — Александр Ка (01.05.2025)
// Удалены пословицы
// Мелкие правки
//======================================






